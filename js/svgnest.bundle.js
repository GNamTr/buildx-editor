!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var e=n();for(var i in e)("object"==typeof exports?exports:t)[i]=e[i]}}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var e={};return n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="/js/",n(n.s=692)}({692:function(t,n,e){"use strict";function i(){if(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect)throw new Error("Your browser does not have SVG support");if(!window.SvgNest)throw new Error("Couldn't initialize SVGnest");if(!window.File||!window.FileReader)throw new Error("Your browser does not have file upload support");if(!window.Worker)throw new Error("Your browser does not have web worker support")}function r(t,n){n||(n=document.createElementNS("http://www.w3.org/2000/svg","svg"));var e=n.cloneNode(!1);SvgNest.style&&e.appendChild(SvgNest.style);for(var i=0;i<t.childNodes.length;i++)e.appendChild(t.childNodes[i].cloneNode(!0));return"undefined"!=typeof XMLSerializer?(new XMLSerializer).serializeToString(e):e.outerHTML}function a(t,n,e,i){function a(t){if(SvgNest.stop(),!f)return i(new Error("Timeout without a single placement"),null,{});var n={efficiency:f.efficiency,placedParts:f.placedParts,totalParts:f.totalParts,placementProgress:y.placementPercent,iterations:u};if(t)return i(t,null,n);if(n.totalParts!=n.placedParts){var e=n.placedParts+"/"+n.totalParts;return i(new Error("Not all parts were placed: "+e),null,n)}console.log("la",f,y);var a=f.svglist.map(function(t){return r(t)});return a.length>=1?i(t,a,n):i(new Error("No sheets where returned from nesting"),null,n)}function o(t,n,i,r){if(console.log("iteration",u,t,n,i,r),u+=1,t){f={svglist:t,placedParts:i,totalParts:r,efficiency:n};return n>=e.efficiencyTarget?a(null):void 0}}function s(t){y={placementPercent:t};var n=(new Date).getTime()-g.getTime();if((new Date).getTime()-m.getTime()>2e3&&(console.log("Running: ",t,(n/1e3).toFixed(2)),m=new Date),n>1e3*e.maxTime)return a(null)}e.efficiencyTarget=e.efficiencyTarget||1,e.maxTime=e.maxTime||60,e.SvgNest=e.SvgNest||{};var l={spacing:12,curveTolerance:5,rotations:4,populationSize:10,mutationRate:10,useHoles:!1,exploreConcave:!0};for(key in e.SvgNest)l[key]=e.SvgNest[key];window.SvgNest.config(l);var p=null;try{p=window.SvgNest.parsesvg(t)}catch(t){return i(t)}for(var c=null,h=0;h<p.childNodes.length;h++){var d=p.childNodes[h];d.id==n&&(c=d)}if(!c)throw new Error("Could not find bin to fit into: "+n);window.SvgNest.setbin(c);var u=0,f=null,y=null,g=new Date,m=new Date;SvgNest.start(s,o)}var o=e(693),s=function(t){return t&&t.__esModule?t:{default:t}}(o);e(699),e(701),e(703),e(705),e(707),e(709),e(711),e(713),console.log("all deps loaded"),window.SvgNest.workerCode=s.default,console.log("worker code loaded"),window.jsJobRun=function(t,n,e){try{i()}catch(t){return e(t)}try{return a(t.svg,t.bin,n,e)}catch(t){return e(t)}}},693:function(t,n,e){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(n,"__esModule",{value:!0});var r=e(694),a=i(r),o=e(695),s=i(o),l=e(696),p=i(l),c=e(697),h=i(c),d=e(698),u=i(d),f=a.default+s.default+p.default+h.default+u.default;n.default=f},694:function(t,n){t.exports='"use strict";\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar JSON;if (!JSON) {\n  JSON = {};\n}(function () {\n  function f(n) {\n    return n < 10 ? "0" + n : n;\n  }if (typeof Date.prototype.toJSON !== "function") {\n    Date.prototype.toJSON = function (key) {\n      return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + f(this.getUTCMonth() + 1) + "-" + f(this.getUTCDate()) + "T" + f(this.getUTCHours()) + ":" + f(this.getUTCMinutes()) + ":" + f(this.getUTCSeconds()) + "Z" : null;\n    };String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function (key) {\n      return this.valueOf();\n    };\n  }var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      escapable = /[\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n      gap,\n      indent,\n      meta = { "\\b": "\\\\b", "\\t": "\\\\t", "\\n": "\\\\n", "\\f": "\\\\f", "\\r": "\\\\r", \'"\': \'\\\\"\', "\\\\": "\\\\\\\\" },\n      rep;function quote(string) {\n    escapable.lastIndex = 0;return escapable.test(string) ? \'"\' + string.replace(escapable, function (a) {\n      var c = meta[a];return typeof c === "string" ? c : "\\\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + \'"\' : \'"\' + string + \'"\';\n  }function str(key, holder) {\n    var i,\n        k,\n        v,\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && typeof value.toJSON === "function") {\n      value = value.toJSON(key);\n    }if (typeof rep === "function") {\n      value = rep.call(holder, key, value);\n    }switch (typeof value === "undefined" ? "undefined" : _typeof(value)) {case "string":\n        return quote(value);case "number":\n        return isFinite(value) ? String(value) : "null";case "boolean":case "null":\n        return String(value);case "object":\n        if (!value) {\n          return "null";\n        }gap += indent;partial = [];if (Object.prototype.toString.apply(value) === "[object Array]") {\n          length = value.length;for (i = 0; i < length; i += 1) {\n            partial[i] = str(i, value) || "null";\n          }v = partial.length === 0 ? "[]" : gap ? "[\\n" + gap + partial.join(",\\n" + gap) + "\\n" + mind + "]" : "[" + partial.join(",") + "]";gap = mind;return v;\n        }if (rep && (typeof rep === "undefined" ? "undefined" : _typeof(rep)) === "object") {\n          length = rep.length;for (i = 0; i < length; i += 1) {\n            if (typeof rep[i] === "string") {\n              k = rep[i];v = str(k, value);if (v) {\n                partial.push(quote(k) + (gap ? ": " : ":") + v);\n              }\n            }\n          }\n        } else {\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              v = str(k, value);if (v) {\n                partial.push(quote(k) + (gap ? ": " : ":") + v);\n              }\n            }\n          }\n        }v = partial.length === 0 ? "{}" : gap ? "{\\n" + gap + partial.join(",\\n" + gap) + "\\n" + mind + "}" : "{" + partial.join(",") + "}";gap = mind;return v;}\n  }if (typeof JSON.stringify !== "function") {\n    JSON.stringify = function (value, replacer, space) {\n      var i;gap = "";indent = "";if (typeof space === "number") {\n        for (i = 0; i < space; i += 1) {\n          indent += " ";\n        }\n      } else {\n        if (typeof space === "string") {\n          indent = space;\n        }\n      }rep = replacer;if (replacer && typeof replacer !== "function" && ((typeof replacer === "undefined" ? "undefined" : _typeof(replacer)) !== "object" || typeof replacer.length !== "number")) {\n        throw new Error("JSON.stringify");\n      }return str("", { "": value });\n    };\n  }if (typeof JSON.parse !== "function") {\n    JSON.parse = function (text, reviver) {\n      var j;function walk(holder, key) {\n        var k,\n            v,\n            value = holder[key];if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object") {\n          for (k in value) {\n            if (Object.prototype.hasOwnProperty.call(value, k)) {\n              v = walk(value, k);if (v !== undefined) {\n                value[k] = v;\n              } else {\n                delete value[k];\n              }\n            }\n          }\n        }return reviver.call(holder, key, value);\n      }text = String(text);cx.lastIndex = 0;if (cx.test(text)) {\n        text = text.replace(cx, function (a) {\n          return "\\\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);\n        });\n      }if (/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, "]").replace(/(?:^|:|,)(?:\\s*\\[)+/g, ""))) {\n        j = eval("(" + text + ")");return typeof reviver === "function" ? walk({ "": j }, "") : j;\n      }throw new SyntaxError("JSON.parse");\n    };\n  }\n})();'},695:function(t,n){t.exports="// matrix utility from SvgPath\n// https://github.com/fontello/svgpath\n\n'use strict';\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) {\n    return new Matrix();\n  }\n  this.queue = []; // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\nif (typeof window !== 'undefined') window.Matrix = Matrix;\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nMatrix.prototype.combine = function (m1, m2) {\n  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n};\n\nMatrix.prototype.isIdentity = function () {\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  var m = this.cache;\n\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return true;\n  }\n  return false;\n};\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, 0, 1, tx, ty]);\n  }\n  return this;\n};\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([sx, 0, 0, sy, 0, 0]);\n  }\n  return this;\n};\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([cos, sin, -sin, cos, 0, 0]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);\n  }\n  return this;\n};\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);\n  }\n  return this;\n};\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [1, 0, 0, 1, 0, 0];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = this.combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m, i, len;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) {\n    return [x, y];\n  }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [x * m[0] + y * m[2] + (isRelative ? 0 : m[4]), x * m[1] + y * m[3] + (isRelative ? 0 : m[5])];\n};"},696:function(t,n){t.exports='"use strict";\n\n// rev 452\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.1.3a                                                          *\n * Date      :  22 January 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti\'s clipping algorithm: *\n * "A generic solution to polygon clipping"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * "Polygon Offsetting by Computing Winding Numbers"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.1.3.2                                                         *\n * Date      :  1 February 2014                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu\'s JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See "LICENSE" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function () {\n  function k(a, b, c) {\n    d.biginteger_used = 1;null != a && ("number" == typeof a && "undefined" == typeof b ? this.fromInt(a) : "number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b));\n  }function q() {\n    return new k(null);\n  }function Q(a, b, c, e, d, g) {\n    for (; 0 <= --g;) {\n      var h = b * this[a++] + c[e] + d;d = Math.floor(h / 67108864);c[e++] = h & 67108863;\n    }return d;\n  }function R(a, b, c, e, d, g) {\n    var h = b & 32767;for (b >>= 15; 0 <= --g;) {\n      var l = this[a] & 32767,\n          k = this[a++] >> 15,\n          n = b * l + k * h,\n          l = h * l + ((n & 32767) << 15) + c[e] + (d & 1073741823);d = (l >>> 30) + (n >>> 15) + b * k + (d >>> 30);c[e++] = l & 1073741823;\n    }return d;\n  }function S(a, b, c, e, d, g) {\n    var h = b & 16383;for (b >>= 14; 0 <= --g;) {\n      var l = this[a] & 16383,\n          k = this[a++] >> 14,\n          n = b * l + k * h,\n          l = h * l + ((n & 16383) << 14) + c[e] + d;d = (l >> 28) + (n >> 14) + b * k;c[e++] = l & 268435455;\n    }return d;\n  }function L(a, b) {\n    var c = B[a.charCodeAt(b)];return null == c ? -1 : c;\n  }function v(a) {\n    var b = q();b.fromInt(a);return b;\n  }function C(a) {\n    var b = 1,\n        c;0 != (c = a >>> 16) && (a = c, b += 16);0 != (c = a >> 8) && (a = c, b += 8);0 != (c = a >> 4) && (a = c, b += 4);0 != (c = a >> 2) && (a = c, b += 2);0 != a >> 1 && (b += 1);return b;\n  }function x(a) {\n    this.m = a;\n  }function y(a) {\n    this.m = a;this.mp = a.invDigit();this.mpl = this.mp & 32767;this.mph = this.mp >> 15;this.um = (1 << a.DB - 15) - 1;this.mt2 = 2 * a.t;\n  }function T(a, b) {\n    return a & b;\n  }function I(a, b) {\n    return a | b;\n  }function M(a, b) {\n    return a ^ b;\n  }function N(a, b) {\n    return a & ~b;\n  }function A() {}function O(a) {\n    return a;\n  }function w(a) {\n    this.r2 = q();this.q3 = q();k.ONE.dlShiftTo(2 * a.t, this.r2);this.mu = this.r2.divide(a);this.m = a;\n  }var d = {},\n      D = !1;"undefined" !== typeof module && module.exports ? (module.exports = d, D = !0) : "undefined" !== typeof document ? window.ClipperLib = d : self.ClipperLib = d;var r;if (D) p = "chrome", r = "Netscape";else {\n    var p = navigator.userAgent.toString().toLowerCase();r = navigator.appName;\n  }var E, J, F, G, H, P;E = -1 != p.indexOf("chrome") && -1 == p.indexOf("chromium") ? 1 : 0;D = -1 != p.indexOf("chromium") ? 1 : 0;J = -1 != p.indexOf("safari") && -1 == p.indexOf("chrome") && -1 == p.indexOf("chromium") ? 1 : 0;F = -1 != p.indexOf("firefox") ? 1 : 0;p.indexOf("firefox/17");p.indexOf("firefox/15");p.indexOf("firefox/3");G = -1 != p.indexOf("opera") ? 1 : 0;p.indexOf("msie 10");\n  p.indexOf("msie 9");H = -1 != p.indexOf("msie 8") ? 1 : 0;P = -1 != p.indexOf("msie 7") ? 1 : 0;p = -1 != p.indexOf("msie ") ? 1 : 0;d.biginteger_used = null;"Microsoft Internet Explorer" == r ? (k.prototype.am = R, r = 30) : "Netscape" != r ? (k.prototype.am = Q, r = 26) : (k.prototype.am = S, r = 28);k.prototype.DB = r;k.prototype.DM = (1 << r) - 1;k.prototype.DV = 1 << r;k.prototype.FV = Math.pow(2, 52);k.prototype.F1 = 52 - r;k.prototype.F2 = 2 * r - 52;var B = [],\n      u;r = 48;for (u = 0; 9 >= u; ++u) {\n    B[r++] = u;\n  }r = 97;for (u = 10; 36 > u; ++u) {\n    B[r++] = u;\n  }r = 65;for (u = 10; 36 > u; ++u) {\n    B[r++] = u;\n  }x.prototype.convert = function (a) {\n    return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;\n  };x.prototype.revert = function (a) {\n    return a;\n  };x.prototype.reduce = function (a) {\n    a.divRemTo(this.m, null, a);\n  };x.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };x.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };y.prototype.convert = function (a) {\n    var b = q();a.abs().dlShiftTo(this.m.t, b);b.divRemTo(this.m, null, b);0 > a.s && 0 < b.compareTo(k.ZERO) && this.m.subTo(b, b);return b;\n  };y.prototype.revert = function (a) {\n    var b = q();a.copyTo(b);\n    this.reduce(b);return b;\n  };y.prototype.reduce = function (a) {\n    for (; a.t <= this.mt2;) {\n      a[a.t++] = 0;\n    }for (var b = 0; b < this.m.t; ++b) {\n      var c = a[b] & 32767,\n          e = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM,\n          c = b + this.m.t;for (a[c] += this.m.am(0, e, a, b, 0, this.m.t); a[c] >= a.DV;) {\n        a[c] -= a.DV, a[++c]++;\n      }\n    }a.clamp();a.drShiftTo(this.m.t, a);0 <= a.compareTo(this.m) && a.subTo(this.m, a);\n  };y.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };y.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };k.prototype.copyTo = function (a) {\n    for (var b = this.t - 1; 0 <= b; --b) {\n      a[b] = this[b];\n    }a.t = this.t;a.s = this.s;\n  };k.prototype.fromInt = function (a) {\n    this.t = 1;this.s = 0 > a ? -1 : 0;0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;\n  };k.prototype.fromString = function (a, b) {\n    var c;if (16 == b) c = 4;else if (8 == b) c = 3;else if (256 == b) c = 8;else if (2 == b) c = 1;else if (32 == b) c = 5;else if (4 == b) c = 2;else {\n      this.fromRadix(a, b);return;\n    }this.s = this.t = 0;for (var e = a.length, d = !1, g = 0; 0 <= --e;) {\n      var h = 8 == c ? a[e] & 255 : L(a, e);0 > h ? "-" == a.charAt(e) && (d = !0) : (d = !1, 0 == g ? this[this.t++] = h : g + c > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - g) - 1) << g, this[this.t++] = h >> this.DB - g) : this[this.t - 1] |= h << g, g += c, g >= this.DB && (g -= this.DB));\n    }8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < g && (this[this.t - 1] |= (1 << this.DB - g) - 1 << g));this.clamp();d && k.ZERO.subTo(this, this);\n  };k.prototype.clamp = function () {\n    for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;) {\n      --this.t;\n    }\n  };k.prototype.dlShiftTo = function (a, b) {\n    var c;for (c = this.t - 1; 0 <= c; --c) {\n      b[c + a] = this[c];\n    }for (c = a - 1; 0 <= c; --c) {\n      b[c] = 0;\n    }b.t = this.t + a;b.s = this.s;\n  };k.prototype.drShiftTo = function (a, b) {\n    for (var c = a; c < this.t; ++c) {\n      b[c - a] = this[c];\n    }b.t = Math.max(this.t - a, 0);b.s = this.s;\n  };k.prototype.lShiftTo = function (a, b) {\n    var c = a % this.DB,\n        e = this.DB - c,\n        d = (1 << e) - 1,\n        g = Math.floor(a / this.DB),\n        h = this.s << c & this.DM,\n        l;for (l = this.t - 1; 0 <= l; --l) {\n      b[l + g + 1] = this[l] >> e | h, h = (this[l] & d) << c;\n    }for (l = g - 1; 0 <= l; --l) {\n      b[l] = 0;\n    }b[g] = h;b.t = this.t + g + 1;b.s = this.s;b.clamp();\n  };k.prototype.rShiftTo = function (a, b) {\n    b.s = this.s;var c = Math.floor(a / this.DB);if (c >= this.t) b.t = 0;else {\n      var e = a % this.DB,\n          d = this.DB - e,\n          g = (1 << e) - 1;b[0] = this[c] >> e;for (var h = c + 1; h < this.t; ++h) {\n        b[h - c - 1] |= (this[h] & g) << d, b[h - c] = this[h] >> e;\n      }0 < e && (b[this.t - c - 1] |= (this.s & g) << d);b.t = this.t - c;b.clamp();\n    }\n  };k.prototype.subTo = function (a, b) {\n    for (var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;) {\n      e += this[c] - a[c], b[c++] = e & this.DM, e >>= this.DB;\n    }if (a.t < this.t) {\n      for (e -= a.s; c < this.t;) {\n        e += this[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += this.s;\n    } else {\n      for (e += this.s; c < a.t;) {\n        e -= a[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e -= a.s;\n    }b.s = 0 > e ? -1 : 0;-1 > e ? b[c++] = this.DV + e : 0 < e && (b[c++] = e);b.t = c;b.clamp();\n  };k.prototype.multiplyTo = function (a, b) {\n    var c = this.abs(),\n        e = a.abs(),\n        d = c.t;for (b.t = d + e.t; 0 <= --d;) {\n      b[d] = 0;\n    }for (d = 0; d < e.t; ++d) {\n      b[d + c.t] = c.am(0, e[d], b, d, 0, c.t);\n    }b.s = 0;b.clamp();this.s != a.s && k.ZERO.subTo(b, b);\n  };k.prototype.squareTo = function (a) {\n    for (var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;) {\n      a[c] = 0;\n    }for (c = 0; c < b.t - 1; ++c) {\n      var e = b.am(c, b[c], a, 2 * c, 0, 1);(a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, e, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);\n    }0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));a.s = 0;a.clamp();\n  };k.prototype.divRemTo = function (a, b, c) {\n    var e = a.abs();if (!(0 >= e.t)) {\n      var d = this.abs();if (d.t < e.t) null != b && b.fromInt(0), null != c && this.copyTo(c);else {\n        null == c && (c = q());var g = q(),\n            h = this.s;a = a.s;var l = this.DB - C(e[e.t - 1]);0 < l ? (e.lShiftTo(l, g), d.lShiftTo(l, c)) : (e.copyTo(g), d.copyTo(c));e = g.t;d = g[e - 1];if (0 != d) {\n          var z = d * (1 << this.F1) + (1 < e ? g[e - 2] >> this.F2 : 0),\n              n = this.FV / z,\n              z = (1 << this.F1) / z,\n              U = 1 << this.F2,\n              m = c.t,\n              p = m - e,\n              s = null == b ? q() : b;g.dlShiftTo(p, s);0 <= c.compareTo(s) && (c[c.t++] = 1, c.subTo(s, c));k.ONE.dlShiftTo(e, s);for (s.subTo(g, g); g.t < e;) {\n            g[g.t++] = 0;\n          }for (; 0 <= --p;) {\n            var r = c[--m] == d ? this.DM : Math.floor(c[m] * n + (c[m - 1] + U) * z);if ((c[m] += g.am(0, r, c, p, 0, e)) < r) for (g.dlShiftTo(p, s), c.subTo(s, c); c[m] < --r;) {\n              c.subTo(s, c);\n            }\n          }null != b && (c.drShiftTo(e, b), h != a && k.ZERO.subTo(b, b));c.t = e;c.clamp();0 < l && c.rShiftTo(l, c);0 > h && k.ZERO.subTo(c, c);\n        }\n      }\n    }\n  };k.prototype.invDigit = function () {\n    if (1 > this.t) return 0;var a = this[0];if (0 == (a & 1)) return 0;var b = a & 3,\n        b = b * (2 - (a & 15) * b) & 15,\n        b = b * (2 - (a & 255) * b) & 255,\n        b = b * (2 - ((a & 65535) * b & 65535)) & 65535,\n        b = b * (2 - a * b % this.DV) % this.DV;return 0 < b ? this.DV - b : -b;\n  };k.prototype.isEven = function () {\n    return 0 == (0 < this.t ? this[0] & 1 : this.s);\n  };\n  k.prototype.exp = function (a, b) {\n    if (4294967295 < a || 1 > a) return k.ONE;var c = q(),\n        e = q(),\n        d = b.convert(this),\n        g = C(a) - 1;for (d.copyTo(c); 0 <= --g;) {\n      if (b.sqrTo(c, e), 0 < (a & 1 << g)) b.mulTo(e, d, c);else var h = c,\n          c = e,\n          e = h;\n    }return b.revert(c);\n  };k.prototype.toString = function (a) {\n    if (0 > this.s) return "-" + this.negate().toString(a);if (16 == a) a = 4;else if (8 == a) a = 3;else if (2 == a) a = 1;else if (32 == a) a = 5;else if (4 == a) a = 2;else return this.toRadix(a);var b = (1 << a) - 1,\n        c,\n        e = !1,\n        d = "",\n        g = this.t,\n        h = this.DB - g * this.DB % a;if (0 < g--) for (h < this.DB && 0 < (c = this[g] >> h) && (e = !0, d = "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c)); 0 <= g;) {\n      h < a ? (c = (this[g] & (1 << h) - 1) << a - h, c |= this[--g] >> (h += this.DB - a)) : (c = this[g] >> (h -= a) & b, 0 >= h && (h += this.DB, --g)), 0 < c && (e = !0), e && (d += "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));\n    }return e ? d : "0";\n  };k.prototype.negate = function () {\n    var a = q();k.ZERO.subTo(this, a);return a;\n  };k.prototype.abs = function () {\n    return 0 > this.s ? this.negate() : this;\n  };k.prototype.compareTo = function (a) {\n    var b = this.s - a.s;if (0 != b) return b;var c = this.t,\n        b = c - a.t;if (0 != b) return 0 > this.s ? -b : b;for (; 0 <= --c;) {\n      if (0 != (b = this[c] - a[c])) return b;\n    }return 0;\n  };k.prototype.bitLength = function () {\n    return 0 >= this.t ? 0 : this.DB * (this.t - 1) + C(this[this.t - 1] ^ this.s & this.DM);\n  };k.prototype.mod = function (a) {\n    var b = q();this.abs().divRemTo(a, null, b);0 > this.s && 0 < b.compareTo(k.ZERO) && a.subTo(b, b);return b;\n  };k.prototype.modPowInt = function (a, b) {\n    var c;c = 256 > a || b.isEven() ? new x(b) : new y(b);return this.exp(a, c);\n  };k.ZERO = v(0);k.ONE = v(1);A.prototype.convert = O;A.prototype.revert = O;A.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);\n  };A.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);\n  };w.prototype.convert = function (a) {\n    if (0 > a.s || a.t > 2 * this.m.t) return a.mod(this.m);if (0 > a.compareTo(this.m)) return a;var b = q();a.copyTo(b);this.reduce(b);return b;\n  };w.prototype.revert = function (a) {\n    return a;\n  };w.prototype.reduce = function (a) {\n    a.drShiftTo(this.m.t - 1, this.r2);a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);for (this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);) {\n      a.dAddOffset(1, this.m.t + 1);\n    }for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m);) {\n      a.subTo(this.m, a);\n    }\n  };w.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };w.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };var t = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],\n      V = 67108864 / t[t.length - 1];k.prototype.chunkSize = function (a) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(a));\n  };k.prototype.toRadix = function (a) {\n    null == a && (a = 10);if (0 == this.signum() || 2 > a || 36 < a) return "0";var b = this.chunkSize(a),\n        b = Math.pow(a, b),\n        c = v(b),\n        e = q(),\n        d = q(),\n        g = "";for (this.divRemTo(c, e, d); 0 < e.signum();) {\n      g = (b + d.intValue()).toString(a).substr(1) + g, e.divRemTo(c, e, d);\n    }return d.intValue().toString(a) + g;\n  };k.prototype.fromRadix = function (a, b) {\n    this.fromInt(0);null == b && (b = 10);for (var c = this.chunkSize(b), e = Math.pow(b, c), d = !1, g = 0, h = 0, l = 0; l < a.length; ++l) {\n      var z = L(a, l);0 > z ? "-" == a.charAt(l) && 0 == this.signum() && (d = !0) : (h = b * h + z, ++g >= c && (this.dMultiply(e), this.dAddOffset(h, 0), h = g = 0));\n    }0 < g && (this.dMultiply(Math.pow(b, g)), this.dAddOffset(h, 0));d && k.ZERO.subTo(this, this);\n  };k.prototype.fromNumber = function (a, b, c) {\n    if ("number" == typeof b) {\n      if (2 > a) this.fromInt(1);else for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(k.ONE.shiftLeft(a - 1), I, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);) {\n        this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(k.ONE.shiftLeft(a - 1), this);\n      }\n    } else {\n      c = [];var e = a & 7;c.length = (a >> 3) + 1;b.nextBytes(c);c[0] = 0 < e ? c[0] & (1 << e) - 1 : 0;this.fromString(c, 256);\n    }\n  };k.prototype.bitwiseTo = function (a, b, c) {\n    var e,\n        d,\n        g = Math.min(a.t, this.t);for (e = 0; e < g; ++e) {\n      c[e] = b(this[e], a[e]);\n    }if (a.t < this.t) {\n      d = a.s & this.DM;for (e = g; e < this.t; ++e) {\n        c[e] = b(this[e], d);\n      }c.t = this.t;\n    } else {\n      d = this.s & this.DM;for (e = g; e < a.t; ++e) {\n        c[e] = b(d, a[e]);\n      }c.t = a.t;\n    }c.s = b(this.s, a.s);c.clamp();\n  };k.prototype.changeBit = function (a, b) {\n    var c = k.ONE.shiftLeft(a);this.bitwiseTo(c, b, c);return c;\n  };k.prototype.addTo = function (a, b) {\n    for (var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;) {\n      e += this[c] + a[c], b[c++] = e & this.DM, e >>= this.DB;\n    }if (a.t < this.t) {\n      for (e += a.s; c < this.t;) {\n        e += this[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += this.s;\n    } else {\n      for (e += this.s; c < a.t;) {\n        e += a[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += a.s;\n    }b.s = 0 > e ? -1 : 0;0 < e ? b[c++] = e : -1 > e && (b[c++] = this.DV + e);b.t = c;b.clamp();\n  };k.prototype.dMultiply = function (a) {\n    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);++this.t;this.clamp();\n  };k.prototype.dAddOffset = function (a, b) {\n    if (0 != a) {\n      for (; this.t <= b;) {\n        this[this.t++] = 0;\n      }for (this[b] += a; this[b] >= this.DV;) {\n        this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];\n      }\n    }\n  };k.prototype.multiplyLowerTo = function (a, b, c) {\n    var e = Math.min(this.t + a.t, b);c.s = 0;for (c.t = e; 0 < e;) {\n      c[--e] = 0;\n    }var d;for (d = c.t - this.t; e < d; ++e) {\n      c[e + this.t] = this.am(0, a[e], c, e, 0, this.t);\n    }for (d = Math.min(a.t, b); e < d; ++e) {\n      this.am(0, a[e], c, e, 0, b - e);\n    }c.clamp();\n  };k.prototype.multiplyUpperTo = function (a, b, c) {\n    --b;var e = c.t = this.t + a.t - b;for (c.s = 0; 0 <= --e;) {\n      c[e] = 0;\n    }for (e = Math.max(b - this.t, 0); e < a.t; ++e) {\n      c[this.t + e - b] = this.am(b - e, a[e], c, 0, 0, this.t + e - b);\n    }c.clamp();c.drShiftTo(1, c);\n  };k.prototype.modInt = function (a) {\n    if (0 >= a) return 0;var b = this.DV % a,\n        c = 0 > this.s ? a - 1 : 0;if (0 < this.t) if (0 == b) c = this[0] % a;else for (var e = this.t - 1; 0 <= e; --e) {\n      c = (b * c + this[e]) % a;\n    }return c;\n  };k.prototype.millerRabin = function (a) {\n    var b = this.subtract(k.ONE),\n        c = b.getLowestSetBit();if (0 >= c) return !1;var e = b.shiftRight(c);a = a + 1 >> 1;a > t.length && (a = t.length);for (var d = q(), g = 0; g < a; ++g) {\n      d.fromInt(t[Math.floor(Math.random() * t.length)]);var h = d.modPow(e, this);if (0 != h.compareTo(k.ONE) && 0 != h.compareTo(b)) {\n        for (var l = 1; l++ < c && 0 != h.compareTo(b);) {\n          if (h = h.modPowInt(2, this), 0 == h.compareTo(k.ONE)) return !1;\n        }if (0 != h.compareTo(b)) return !1;\n      }\n    }return !0;\n  };\n  k.prototype.clone = function () {\n    var a = q();this.copyTo(a);return a;\n  };k.prototype.intValue = function () {\n    if (0 > this.s) {\n      if (1 == this.t) return this[0] - this.DV;if (0 == this.t) return -1;\n    } else {\n      if (1 == this.t) return this[0];if (0 == this.t) return 0;\n    }return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];\n  };k.prototype.byteValue = function () {\n    return 0 == this.t ? this.s : this[0] << 24 >> 24;\n  };k.prototype.shortValue = function () {\n    return 0 == this.t ? this.s : this[0] << 16 >> 16;\n  };k.prototype.signum = function () {\n    return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;\n  };k.prototype.toByteArray = function () {\n    var a = this.t,\n        b = [];b[0] = this.s;var c = this.DB - a * this.DB % 8,\n        e,\n        d = 0;if (0 < a--) for (c < this.DB && (e = this[a] >> c) != (this.s & this.DM) >> c && (b[d++] = e | this.s << this.DB - c); 0 <= a;) {\n      if (8 > c ? (e = (this[a] & (1 << c) - 1) << 8 - c, e |= this[--a] >> (c += this.DB - 8)) : (e = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (e & 128) && (e |= -256), 0 == d && (this.s & 128) != (e & 128) && ++d, 0 < d || e != this.s) b[d++] = e;\n    }return b;\n  };k.prototype.equals = function (a) {\n    return 0 == this.compareTo(a);\n  };k.prototype.min = function (a) {\n    return 0 > this.compareTo(a) ? this : a;\n  };k.prototype.max = function (a) {\n    return 0 < this.compareTo(a) ? this : a;\n  };k.prototype.and = function (a) {\n    var b = q();this.bitwiseTo(a, T, b);return b;\n  };k.prototype.or = function (a) {\n    var b = q();this.bitwiseTo(a, I, b);return b;\n  };k.prototype.xor = function (a) {\n    var b = q();this.bitwiseTo(a, M, b);return b;\n  };k.prototype.andNot = function (a) {\n    var b = q();this.bitwiseTo(a, N, b);return b;\n  };k.prototype.not = function () {\n    for (var a = q(), b = 0; b < this.t; ++b) {\n      a[b] = this.DM & ~this[b];\n    }a.t = this.t;a.s = ~this.s;return a;\n  };k.prototype.shiftLeft = function (a) {\n    var b = q();0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);return b;\n  };k.prototype.shiftRight = function (a) {\n    var b = q();0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);return b;\n  };k.prototype.getLowestSetBit = function () {\n    for (var a = 0; a < this.t; ++a) {\n      if (0 != this[a]) {\n        var b = a * this.DB;a = this[a];if (0 == a) a = -1;else {\n          var c = 0;0 == (a & 65535) && (a >>= 16, c += 16);0 == (a & 255) && (a >>= 8, c += 8);0 == (a & 15) && (a >>= 4, c += 4);0 == (a & 3) && (a >>= 2, c += 2);0 == (a & 1) && ++c;a = c;\n        }return b + a;\n      }\n    }return 0 > this.s ? this.t * this.DB : -1;\n  };k.prototype.bitCount = function () {\n    for (var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c) {\n      for (var e = this[c] ^ b, d = 0; 0 != e;) {\n        e &= e - 1, ++d;\n      }a += d;\n    }return a;\n  };k.prototype.testBit = function (a) {\n    var b = Math.floor(a / this.DB);return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);\n  };k.prototype.setBit = function (a) {\n    return this.changeBit(a, I);\n  };k.prototype.clearBit = function (a) {\n    return this.changeBit(a, N);\n  };k.prototype.flipBit = function (a) {\n    return this.changeBit(a, M);\n  };k.prototype.add = function (a) {\n    var b = q();this.addTo(a, b);return b;\n  };k.prototype.subtract = function (a) {\n    var b = q();this.subTo(a, b);return b;\n  };\n  k.prototype.multiply = function (a) {\n    var b = q();this.multiplyTo(a, b);return b;\n  };k.prototype.divide = function (a) {\n    var b = q();this.divRemTo(a, b, null);return b;\n  };k.prototype.remainder = function (a) {\n    var b = q();this.divRemTo(a, null, b);return b;\n  };k.prototype.divideAndRemainder = function (a) {\n    var b = q(),\n        c = q();this.divRemTo(a, b, c);return [b, c];\n  };k.prototype.modPow = function (a, b) {\n    var c = a.bitLength(),\n        e,\n        d = v(1),\n        g;if (0 >= c) return d;e = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;g = 8 > c ? new x(b) : b.isEven() ? new w(b) : new y(b);var h = [],\n        l = 3,\n        k = e - 1,\n        n = (1 << e) - 1;h[1] = g.convert(this);if (1 < e) for (c = q(), g.sqrTo(h[1], c); l <= n;) {\n      h[l] = q(), g.mulTo(c, h[l - 2], h[l]), l += 2;\n    }for (var m = a.t - 1, p, r = !0, s = q(), c = C(a[m]) - 1; 0 <= m;) {\n      c >= k ? p = a[m] >> c - k & n : (p = (a[m] & (1 << c + 1) - 1) << k - c, 0 < m && (p |= a[m - 1] >> this.DB + c - k));for (l = e; 0 == (p & 1);) {\n        p >>= 1, --l;\n      }0 > (c -= l) && (c += this.DB, --m);if (r) h[p].copyTo(d), r = !1;else {\n        for (; 1 < l;) {\n          g.sqrTo(d, s), g.sqrTo(s, d), l -= 2;\n        }0 < l ? g.sqrTo(d, s) : (l = d, d = s, s = l);g.mulTo(s, h[p], d);\n      }for (; 0 <= m && 0 == (a[m] & 1 << c);) {\n        g.sqrTo(d, s), l = d, d = s, s = l, 0 > --c && (c = this.DB - 1, --m);\n      }\n    }return g.revert(d);\n  };k.prototype.modInverse = function (a) {\n    var b = a.isEven();if (this.isEven() && b || 0 == a.signum()) return k.ZERO;for (var c = a.clone(), e = this.clone(), d = v(1), g = v(0), h = v(0), l = v(1); 0 != c.signum();) {\n      for (; c.isEven();) {\n        c.rShiftTo(1, c), b ? (d.isEven() && g.isEven() || (d.addTo(this, d), g.subTo(a, g)), d.rShiftTo(1, d)) : g.isEven() || g.subTo(a, g), g.rShiftTo(1, g);\n      }for (; e.isEven();) {\n        e.rShiftTo(1, e), b ? (h.isEven() && l.isEven() || (h.addTo(this, h), l.subTo(a, l)), h.rShiftTo(1, h)) : l.isEven() || l.subTo(a, l), l.rShiftTo(1, l);\n      }0 <= c.compareTo(e) ? (c.subTo(e, c), b && d.subTo(h, d), g.subTo(l, g)) : (e.subTo(c, e), b && h.subTo(d, h), l.subTo(g, l));\n    }if (0 != e.compareTo(k.ONE)) return k.ZERO;if (0 <= l.compareTo(a)) return l.subtract(a);if (0 > l.signum()) l.addTo(a, l);else return l;return 0 > l.signum() ? l.add(a) : l;\n  };k.prototype.pow = function (a) {\n    return this.exp(a, new A());\n  };k.prototype.gcd = function (a) {\n    var b = 0 > this.s ? this.negate() : this.clone();a = 0 > a.s ? a.negate() : a.clone();if (0 > b.compareTo(a)) {\n      var c = b,\n          b = a;a = c;\n    }var c = b.getLowestSetBit(),\n        e = a.getLowestSetBit();if (0 > e) return b;c < e && (e = c);0 < e && (b.rShiftTo(e, b), a.rShiftTo(e, a));for (; 0 < b.signum();) {\n      0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));\n    }0 < e && a.lShiftTo(e, a);return a;\n  };k.prototype.isProbablePrime = function (a) {\n    var b,\n        c = this.abs();if (1 == c.t && c[0] <= t[t.length - 1]) {\n      for (b = 0; b < t.length; ++b) {\n        if (c[0] == t[b]) return !0;\n      }return !1;\n    }if (c.isEven()) return !1;for (b = 1; b < t.length;) {\n      for (var e = t[b], d = b + 1; d < t.length && e < V;) {\n        e *= t[d++];\n      }for (e = c.modInt(e); b < d;) {\n        if (0 == e % t[b++]) return !1;\n      }\n    }return c.millerRabin(a);\n  };k.prototype.square = function () {\n    var a = q();this.squareTo(a);return a;\n  };var m = k;m.prototype.IsNegative = function () {\n    return -1 == this.compareTo(m.ZERO) ? !0 : !1;\n  };m.op_Equality = function (a, b) {\n    return 0 == a.compareTo(b) ? !0 : !1;\n  };m.op_Inequality = function (a, b) {\n    return 0 != a.compareTo(b) ? !0 : !1;\n  };m.op_GreaterThan = function (a, b) {\n    return 0 < a.compareTo(b) ? !0 : !1;\n  };m.op_LessThan = function (a, b) {\n    return 0 > a.compareTo(b) ? !0 : !1;\n  };m.op_Addition = function (a, b) {\n    return new m(a).add(new m(b));\n  };m.op_Subtraction = function (a, b) {\n    return new m(a).subtract(new m(b));\n  };m.Int128Mul = function (a, b) {\n    return new m(a).multiply(new m(b));\n  };m.op_Division = function (a, b) {\n    return a.divide(b);\n  };m.prototype.ToDouble = function () {\n    return parseFloat(this.toString());\n  };if ("undefined" == typeof K) var K = function K(a, b) {\n    var c;if ("undefined" == typeof Object.getOwnPropertyNames) for (c in b.prototype) {\n      if ("undefined" == typeof a.prototype[c] || a.prototype[c] == Object.prototype[c]) a.prototype[c] = b.prototype[c];\n    } else for (var e = Object.getOwnPropertyNames(b.prototype), d = 0; d < e.length; d++) {\n      "undefined" == typeof Object.getOwnPropertyDescriptor(a.prototype, e[d]) && Object.defineProperty(a.prototype, e[d], Object.getOwnPropertyDescriptor(b.prototype, e[d]));\n    }for (c in b) {\n      "undefined" == typeof a[c] && (a[c] = b[c]);\n    }a.$baseCtor = b;\n  };d.Path = function () {\n    return [];\n  };d.Paths = function () {\n    return [];\n  };d.DoublePoint = function () {\n    var a = arguments;this.Y = this.X = 0;1 == a.length ? (this.X = a[0].X, this.Y = a[0].Y) : 2 == a.length && (this.X = a[0], this.Y = a[1]);\n  };d.DoublePoint0 = function () {\n    this.Y = this.X = 0;\n  };d.DoublePoint1 = function (a) {\n    this.X = a.X;this.Y = a.Y;\n  };d.DoublePoint2 = function (a, b) {\n    this.X = a;this.Y = b;\n  };d.PolyNode = function () {\n    this.m_Parent = null;this.m_polygon = new d.Path();this.m_endtype = this.m_jointype = this.m_Index = 0;this.m_Childs = [];this.IsOpen = !1;\n  };d.PolyNode.prototype.IsHoleNode = function () {\n    for (var a = !0, b = this.m_Parent; null !== b;) {\n      a = !a, b = b.m_Parent;\n    }return a;\n  };d.PolyNode.prototype.ChildCount = function () {\n    return this.m_Childs.length;\n  };d.PolyNode.prototype.Contour = function () {\n    return this.m_polygon;\n  };d.PolyNode.prototype.AddChild = function (a) {\n    var b = this.m_Childs.length;this.m_Childs.push(a);a.m_Parent = this;a.m_Index = b;\n  };d.PolyNode.prototype.GetNext = function () {\n    return 0 < this.m_Childs.length ? this.m_Childs[0] : this.GetNextSiblingUp();\n  };d.PolyNode.prototype.GetNextSiblingUp = function () {\n    return null === this.m_Parent ? null : this.m_Index == this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];\n  };d.PolyNode.prototype.Childs = function () {\n    return this.m_Childs;\n  };d.PolyNode.prototype.Parent = function () {\n    return this.m_Parent;\n  };\n  d.PolyNode.prototype.IsHole = function () {\n    return this.IsHoleNode();\n  };d.PolyTree = function () {\n    this.m_AllPolys = [];d.PolyNode.call(this);\n  };d.PolyTree.prototype.Clear = function () {\n    for (var a = 0, b = this.m_AllPolys.length; a < b; a++) {\n      this.m_AllPolys[a] = null;\n    }this.m_AllPolys.length = 0;this.m_Childs.length = 0;\n  };d.PolyTree.prototype.GetFirst = function () {\n    return 0 < this.m_Childs.length ? this.m_Childs[0] : null;\n  };d.PolyTree.prototype.Total = function () {\n    return this.m_AllPolys.length;\n  };K(d.PolyTree, d.PolyNode);d.Math_Abs_Int64 = d.Math_Abs_Int32 = d.Math_Abs_Double = function (a) {\n    return Math.abs(a);\n  };d.Math_Max_Int32_Int32 = function (a, b) {\n    return Math.max(a, b);\n  };d.Cast_Int32 = p || G || J ? function (a) {\n    return a | 0;\n  } : function (a) {\n    return ~~a;\n  };d.Cast_Int64 = E ? function (a) {\n    return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : ~~a;\n  } : F && "function" == typeof Number.toInteger ? function (a) {\n    return Number.toInteger(a);\n  } : P || H ? function (a) {\n    return parseInt(a, 10);\n  } : p ? function (a) {\n    return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : a | 0;\n  } : function (a) {\n    return 0 > a ? Math.ceil(a) : Math.floor(a);\n  };d.Clear = function (a) {\n    a.length = 0;\n  };d.PI = 3.141592653589793;d.PI2 = 6.283185307179586;d.IntPoint = function () {\n    var a;a = arguments;var b = a.length;this.Y = this.X = 0;2 == b ? (this.X = a[0], this.Y = a[1]) : 1 == b ? a[0] instanceof d.DoublePoint ? (a = a[0], this.X = d.Clipper.Round(a.X), this.Y = d.Clipper.Round(a.Y)) : (a = a[0], this.X = a.X, this.Y = a.Y) : this.Y = this.X = 0;\n  };d.IntPoint.op_Equality = function (a, b) {\n    return a.X == b.X && a.Y == b.Y;\n  };d.IntPoint.op_Inequality = function (a, b) {\n    return a.X != b.X || a.Y != b.Y;\n  };d.IntPoint0 = function () {\n    this.Y = this.X = 0;\n  };d.IntPoint1 = function (a) {\n    this.X = a.X;this.Y = a.Y;\n  };d.IntPoint1dp = function (a) {\n    this.X = d.Clipper.Round(a.X);this.Y = d.Clipper.Round(a.Y);\n  };d.IntPoint2 = function (a, b) {\n    this.X = a;this.Y = b;\n  };d.IntRect = function () {\n    var a = arguments,\n        b = a.length;4 == b ? (this.left = a[0], this.top = a[1], this.right = a[2], this.bottom = a[3]) : 1 == b ? (this.left = ir.left, this.top = ir.top, this.right = ir.right, this.bottom = ir.bottom) : this.bottom = this.right = this.top = this.left = 0;\n  };d.IntRect0 = function () {\n    this.bottom = this.right = this.top = this.left = 0;\n  };d.IntRect1 = function (a) {\n    this.left = a.left;this.top = a.top;this.right = a.right;this.bottom = a.bottom;\n  };d.IntRect4 = function (a, b, c, e) {\n    this.left = a;this.top = b;this.right = c;this.bottom = e;\n  };d.ClipType = { ctIntersection: 0, ctUnion: 1, ctDifference: 2, ctXor: 3 };d.PolyType = { ptSubject: 0, ptClip: 1 };d.PolyFillType = { pftEvenOdd: 0, pftNonZero: 1, pftPositive: 2, pftNegative: 3 };d.JoinType = { jtSquare: 0, jtRound: 1, jtMiter: 2 };d.EndType = { etOpenSquare: 0, etOpenRound: 1, etOpenButt: 2, etClosedLine: 3, etClosedPolygon: 4 };d.EdgeSide = { esLeft: 0, esRight: 1 };d.Direction = { dRightToLeft: 0, dLeftToRight: 1 };d.TEdge = function () {\n    this.Bot = new d.IntPoint();this.Curr = new d.IntPoint();this.Top = new d.IntPoint();this.Delta = new d.IntPoint();this.Dx = 0;this.PolyTyp = d.PolyType.ptSubject;this.Side = d.EdgeSide.esLeft;this.OutIdx = this.WindCnt2 = this.WindCnt = this.WindDelta = 0;this.PrevInSEL = this.NextInSEL = this.PrevInAEL = this.NextInAEL = this.NextInLML = this.Prev = this.Next = null;\n  };d.IntersectNode = function () {\n    this.Edge2 = this.Edge1 = null;this.Pt = new d.IntPoint();\n  };d.MyIntersectNodeSort = function () {};d.MyIntersectNodeSort.Compare = function (a, b) {\n    return b.Pt.Y - a.Pt.Y;\n  };d.LocalMinima = function () {\n    this.Y = 0;this.Next = this.RightBound = this.LeftBound = null;\n  };d.Scanbeam = function () {\n    this.Y = 0;this.Next = null;\n  };d.OutRec = function () {\n    this.Idx = 0;this.IsOpen = this.IsHole = !1;this.PolyNode = this.BottomPt = this.Pts = this.FirstLeft = null;\n  };d.OutPt = function () {\n    this.Idx = 0;this.Pt = new d.IntPoint();this.Prev = this.Next = null;\n  };d.Join = function () {\n    this.OutPt2 = this.OutPt1 = null;this.OffPt = new d.IntPoint();\n  };d.ClipperBase = function () {\n    this.m_CurrentLM = this.m_MinimaList = null;this.m_edges = [];this.PreserveCollinear = this.m_HasOpenPaths = this.m_UseFullRange = !1;this.m_CurrentLM = this.m_MinimaList = null;this.m_HasOpenPaths = this.m_UseFullRange = !1;\n  };d.ClipperBase.horizontal = -9007199254740992;d.ClipperBase.Skip = -2;d.ClipperBase.Unassigned = -1;d.ClipperBase.tolerance = 1E-20;d.ClipperBase.loRange = 47453132;d.ClipperBase.hiRange = 0xfffffffffffff;d.ClipperBase.near_zero = function (a) {\n    return a > -d.ClipperBase.tolerance && a < d.ClipperBase.tolerance;\n  };d.ClipperBase.IsHorizontal = function (a) {\n    return 0 === a.Delta.Y;\n  };\n  d.ClipperBase.prototype.PointIsVertex = function (a, b) {\n    var c = b;do {\n      if (d.IntPoint.op_Equality(c.Pt, a)) return !0;c = c.Next;\n    } while (c != b);return !1;\n  };d.ClipperBase.prototype.PointOnLineSegment = function (a, b, c, e) {\n    return e ? a.X == b.X && a.Y == b.Y || a.X == c.X && a.Y == c.Y || a.X > b.X == a.X < c.X && a.Y > b.Y == a.Y < c.Y && m.op_Equality(m.Int128Mul(a.X - b.X, c.Y - b.Y), m.Int128Mul(c.X - b.X, a.Y - b.Y)) : a.X == b.X && a.Y == b.Y || a.X == c.X && a.Y == c.Y || a.X > b.X == a.X < c.X && a.Y > b.Y == a.Y < c.Y && (a.X - b.X) * (c.Y - b.Y) == (c.X - b.X) * (a.Y - b.Y);\n  };d.ClipperBase.prototype.PointOnPolygon = function (a, b, c) {\n    for (var e = b;;) {\n      if (this.PointOnLineSegment(a, e.Pt, e.Next.Pt, c)) return !0;e = e.Next;if (e == b) break;\n    }return !1;\n  };d.ClipperBase.prototype.SlopesEqual = d.ClipperBase.SlopesEqual = function () {\n    var a = arguments,\n        b = a.length,\n        c,\n        e,\n        f;if (3 == b) return b = a[0], c = a[1], (a = a[2]) ? m.op_Equality(m.Int128Mul(b.Delta.Y, c.Delta.X), m.Int128Mul(b.Delta.X, c.Delta.Y)) : d.Cast_Int64(b.Delta.Y * c.Delta.X) == d.Cast_Int64(b.Delta.X * c.Delta.Y);if (4 == b) return b = a[0], c = a[1], e = a[2], (a = a[3]) ? m.op_Equality(m.Int128Mul(b.Y - c.Y, c.X - e.X), m.Int128Mul(b.X - c.X, c.Y - e.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (c.X - e.X)) - d.Cast_Int64((b.X - c.X) * (c.Y - e.Y));b = a[0];c = a[1];e = a[2];f = a[3];return (a = a[4]) ? m.op_Equality(m.Int128Mul(b.Y - c.Y, e.X - f.X), m.Int128Mul(b.X - c.X, e.Y - f.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (e.X - f.X)) - d.Cast_Int64((b.X - c.X) * (e.Y - f.Y));\n  };d.ClipperBase.SlopesEqual3 = function (a, b, c) {\n    return c ? m.op_Equality(m.Int128Mul(a.Delta.Y, b.Delta.X), m.Int128Mul(a.Delta.X, b.Delta.Y)) : d.Cast_Int64(a.Delta.Y * b.Delta.X) == d.Cast_Int64(a.Delta.X * b.Delta.Y);\n  };d.ClipperBase.SlopesEqual4 = function (a, b, c, e) {\n    return e ? m.op_Equality(m.Int128Mul(a.Y - b.Y, b.X - c.X), m.Int128Mul(a.X - b.X, b.Y - c.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (b.X - c.X)) - d.Cast_Int64((a.X - b.X) * (b.Y - c.Y));\n  };d.ClipperBase.SlopesEqual5 = function (a, b, c, e, f) {\n    return f ? m.op_Equality(m.Int128Mul(a.Y - b.Y, c.X - e.X), m.Int128Mul(a.X - b.X, c.Y - e.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (c.X - e.X)) - d.Cast_Int64((a.X - b.X) * (c.Y - e.Y));\n  };d.ClipperBase.prototype.Clear = function () {\n    this.DisposeLocalMinimaList();for (var a = 0, b = this.m_edges.length; a < b; ++a) {\n      for (var c = 0, e = this.m_edges[a].length; c < e; ++c) {\n        this.m_edges[a][c] = null;\n      }d.Clear(this.m_edges[a]);\n    }d.Clear(this.m_edges);this.m_HasOpenPaths = this.m_UseFullRange = !1;\n  };d.ClipperBase.prototype.DisposeLocalMinimaList = function () {\n    for (; null !== this.m_MinimaList;) {\n      var a = this.m_MinimaList.Next;this.m_MinimaList = null;this.m_MinimaList = a;\n    }this.m_CurrentLM = null;\n  };d.ClipperBase.prototype.RangeTest = function (a, b) {\n    if (b.Value) (a.X > d.ClipperBase.hiRange || a.Y > d.ClipperBase.hiRange || -a.X > d.ClipperBase.hiRange || -a.Y > d.ClipperBase.hiRange) && d.Error("Coordinate outside allowed range in RangeTest().");else if (a.X > d.ClipperBase.loRange || a.Y > d.ClipperBase.loRange || -a.X > d.ClipperBase.loRange || -a.Y > d.ClipperBase.loRange) b.Value = !0, this.RangeTest(a, b);\n  };d.ClipperBase.prototype.InitEdge = function (a, b, c, e) {\n    a.Next = b;a.Prev = c;a.Curr.X = e.X;a.Curr.Y = e.Y;a.OutIdx = -1;\n  };d.ClipperBase.prototype.InitEdge2 = function (a, b) {\n    a.Curr.Y >= a.Next.Curr.Y ? (a.Bot.X = a.Curr.X, a.Bot.Y = a.Curr.Y, a.Top.X = a.Next.Curr.X, a.Top.Y = a.Next.Curr.Y) : (a.Top.X = a.Curr.X, a.Top.Y = a.Curr.Y, a.Bot.X = a.Next.Curr.X, a.Bot.Y = a.Next.Curr.Y);this.SetDx(a);a.PolyTyp = b;\n  };d.ClipperBase.prototype.FindNextLocMin = function (a) {\n    for (var b;;) {\n      for (; d.IntPoint.op_Inequality(a.Bot, a.Prev.Bot) || d.IntPoint.op_Equality(a.Curr, a.Top);) {\n        a = a.Next;\n      }if (a.Dx != d.ClipperBase.horizontal && a.Prev.Dx != d.ClipperBase.horizontal) break;for (; a.Prev.Dx == d.ClipperBase.horizontal;) {\n        a = a.Prev;\n      }for (b = a; a.Dx == d.ClipperBase.horizontal;) {\n        a = a.Next;\n      }if (a.Top.Y != a.Prev.Bot.Y) {\n        b.Prev.Bot.X < a.Bot.X && (a = b);break;\n      }\n    }return a;\n  };d.ClipperBase.prototype.ProcessBound = function (a, b) {\n    var c = a,\n        e = a,\n        f;a.Dx == d.ClipperBase.horizontal && (f = b ? a.Prev.Bot.X : a.Next.Bot.X, a.Bot.X != f && this.ReverseHorizontal(a));if (e.OutIdx != d.ClipperBase.Skip) if (b) {\n      for (; e.Top.Y == e.Next.Bot.Y && e.Next.OutIdx != d.ClipperBase.Skip;) {\n        e = e.Next;\n      }if (e.Dx == d.ClipperBase.horizontal && e.Next.OutIdx != d.ClipperBase.Skip) {\n        for (f = e; f.Prev.Dx == d.ClipperBase.horizontal;) {\n          f = f.Prev;\n        }f.Prev.Top.X == e.Next.Top.X ? b || (e = f.Prev) : f.Prev.Top.X > e.Next.Top.X && (e = f.Prev);\n      }for (; a != e;) {\n        a.NextInLML = a.Next, a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a), a = a.Next;\n      }a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a);e = e.Next;\n    } else {\n      for (; e.Top.Y == e.Prev.Bot.Y && e.Prev.OutIdx != d.ClipperBase.Skip;) {\n        e = e.Prev;\n      }if (e.Dx == d.ClipperBase.horizontal && e.Prev.OutIdx != d.ClipperBase.Skip) {\n        for (f = e; f.Next.Dx == d.ClipperBase.horizontal;) {\n          f = f.Next;\n        }f.Next.Top.X == e.Prev.Top.X ? b || (e = f.Next) : f.Next.Top.X > e.Prev.Top.X && (e = f.Next);\n      }for (; a != e;) {\n        a.NextInLML = a.Prev, a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Next.Top.X && this.ReverseHorizontal(a), a = a.Prev;\n      }a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Next.Top.X && this.ReverseHorizontal(a);e = e.Prev;\n    }if (e.OutIdx == d.ClipperBase.Skip) {\n      a = e;if (b) {\n        for (; a.Top.Y == a.Next.Bot.Y;) {\n          a = a.Next;\n        }for (; a != e && a.Dx == d.ClipperBase.horizontal;) {\n          a = a.Prev;\n        }\n      } else {\n        for (; a.Top.Y == a.Prev.Bot.Y;) {\n          a = a.Prev;\n        }for (; a != e && a.Dx == d.ClipperBase.horizontal;) {\n          a = a.Next;\n        }\n      }a == e ? e = b ? a.Next : a.Prev : (a = b ? e.Next : e.Prev, c = new d.LocalMinima(), c.Next = null, c.Y = a.Bot.Y, c.LeftBound = null, c.RightBound = a, c.RightBound.WindDelta = 0, e = this.ProcessBound(c.RightBound, b), this.InsertLocalMinima(c));\n    }return e;\n  };d.ClipperBase.prototype.AddPath = function (a, b, c) {\n    c || b != d.PolyType.ptClip || d.Error("AddPath: Open paths must be subject.");var e = a.length - 1;if (c) for (; 0 < e && d.IntPoint.op_Equality(a[e], a[0]);) {\n      --e;\n    }for (; 0 < e && d.IntPoint.op_Equality(a[e], a[e - 1]);) {\n      --e;\n    }if (c && 2 > e || !c && 1 > e) return !1;for (var f = [], g = 0; g <= e; g++) {\n      f.push(new d.TEdge());\n    }var h = !0;f[1].Curr.X = a[1].X;f[1].Curr.Y = a[1].Y;var l = { Value: this.m_UseFullRange };this.RangeTest(a[0], l);this.m_UseFullRange = l.Value;l.Value = this.m_UseFullRange;this.RangeTest(a[e], l);this.m_UseFullRange = l.Value;this.InitEdge(f[0], f[1], f[e], a[0]);this.InitEdge(f[e], f[0], f[e - 1], a[e]);for (g = e - 1; 1 <= g; --g) {\n      l.Value = this.m_UseFullRange, this.RangeTest(a[g], l), this.m_UseFullRange = l.Value, this.InitEdge(f[g], f[g + 1], f[g - 1], a[g]);\n    }for (g = a = e = f[0];;) {\n      if (d.IntPoint.op_Equality(a.Curr, a.Next.Curr)) {\n        if (a == a.Next) break;a == e && (e = a.Next);g = a = this.RemoveEdge(a);\n      } else {\n        if (a.Prev == a.Next) break;else if (c && d.ClipperBase.SlopesEqual(a.Prev.Curr, a.Curr, a.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(a.Prev.Curr, a.Curr, a.Next.Curr))) {\n          a == e && (e = a.Next);a = this.RemoveEdge(a);g = a = a.Prev;continue;\n        }a = a.Next;if (a == g) break;\n      }\n    }if (!c && a == a.Next || c && a.Prev == a.Next) return !1;c || (this.m_HasOpenPaths = !0, e.Prev.OutIdx = d.ClipperBase.Skip);a = e;do {\n      this.InitEdge2(a, b), a = a.Next, h && a.Curr.Y != e.Curr.Y && (h = !1);\n    } while (a != e);if (h) {\n      if (c) return !1;a.Prev.OutIdx = d.ClipperBase.Skip;a.Prev.Bot.X < a.Prev.Top.X && this.ReverseHorizontal(a.Prev);\n      b = new d.LocalMinima();b.Next = null;b.Y = a.Bot.Y;b.LeftBound = null;b.RightBound = a;b.RightBound.Side = d.EdgeSide.esRight;for (b.RightBound.WindDelta = 0; a.Next.OutIdx != d.ClipperBase.Skip;) {\n        a.NextInLML = a.Next, a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a), a = a.Next;\n      }this.InsertLocalMinima(b);this.m_edges.push(f);return !0;\n    }this.m_edges.push(f);for (h = null;;) {\n      a = this.FindNextLocMin(a);if (a == h) break;else null == h && (h = a);b = new d.LocalMinima();b.Next = null;b.Y = a.Bot.Y;a.Dx < a.Prev.Dx ? (b.LeftBound = a.Prev, b.RightBound = a, f = !1) : (b.LeftBound = a, b.RightBound = a.Prev, f = !0);b.LeftBound.Side = d.EdgeSide.esLeft;b.RightBound.Side = d.EdgeSide.esRight;b.LeftBound.WindDelta = c ? b.LeftBound.Next == b.RightBound ? -1 : 1 : 0;b.RightBound.WindDelta = -b.LeftBound.WindDelta;a = this.ProcessBound(b.LeftBound, f);e = this.ProcessBound(b.RightBound, !f);b.LeftBound.OutIdx == d.ClipperBase.Skip ? b.LeftBound = null : b.RightBound.OutIdx == d.ClipperBase.Skip && (b.RightBound = null);this.InsertLocalMinima(b);f || (a = e);\n    }return !0;\n  };d.ClipperBase.prototype.AddPaths = function (a, b, c) {\n    for (var e = !1, d = 0, g = a.length; d < g; ++d) {\n      this.AddPath(a[d], b, c) && (e = !0);\n    }return e;\n  };d.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (a, b, c) {\n    return d.IntPoint.op_Equality(a, c) || d.IntPoint.op_Equality(a, b) || d.IntPoint.op_Equality(c, b) ? !1 : a.X != c.X ? b.X > a.X == b.X < c.X : b.Y > a.Y == b.Y < c.Y;\n  };d.ClipperBase.prototype.RemoveEdge = function (a) {\n    a.Prev.Next = a.Next;a.Next.Prev = a.Prev;var b = a.Next;a.Prev = null;return b;\n  };d.ClipperBase.prototype.SetDx = function (a) {\n    a.Delta.X = a.Top.X - a.Bot.X;a.Delta.Y = a.Top.Y - a.Bot.Y;a.Dx = 0 === a.Delta.Y ? d.ClipperBase.horizontal : a.Delta.X / a.Delta.Y;\n  };d.ClipperBase.prototype.InsertLocalMinima = function (a) {\n    if (null === this.m_MinimaList) this.m_MinimaList = a;else if (a.Y >= this.m_MinimaList.Y) a.Next = this.m_MinimaList, this.m_MinimaList = a;else {\n      for (var b = this.m_MinimaList; null !== b.Next && a.Y < b.Next.Y;) {\n        b = b.Next;\n      }a.Next = b.Next;b.Next = a;\n    }\n  };d.ClipperBase.prototype.PopLocalMinima = function () {\n    null !== this.m_CurrentLM && (this.m_CurrentLM = this.m_CurrentLM.Next);\n  };d.ClipperBase.prototype.ReverseHorizontal = function (a) {\n    var b = a.Top.X;a.Top.X = a.Bot.X;a.Bot.X = b;\n  };d.ClipperBase.prototype.Reset = function () {\n    this.m_CurrentLM = this.m_MinimaList;if (null != this.m_CurrentLM) for (var a = this.m_MinimaList; null != a;) {\n      var b = a.LeftBound;null != b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, b.Side = d.EdgeSide.esLeft, b.OutIdx = d.ClipperBase.Unassigned);b = a.RightBound;null != b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, b.Side = d.EdgeSide.esRight, b.OutIdx = d.ClipperBase.Unassigned);a = a.Next;\n    }\n  };d.Clipper = function (a) {\n    "undefined" == typeof a && (a = 0);this.m_PolyOuts = null;this.m_ClipType = d.ClipType.ctIntersection;this.m_IntersectNodeComparer = this.m_IntersectList = this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;this.m_ExecuteLocked = !1;this.m_SubjFillType = this.m_ClipFillType = d.PolyFillType.pftEvenOdd;this.m_GhostJoins = this.m_Joins = null;this.StrictlySimple = this.ReverseSolution = this.m_UsingPolyTree = !1;d.ClipperBase.call(this);this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;this.m_IntersectList = [];this.m_IntersectNodeComparer = d.MyIntersectNodeSort.Compare;this.m_UsingPolyTree = this.m_ExecuteLocked = !1;this.m_PolyOuts = [];this.m_Joins = [];this.m_GhostJoins = [];this.ReverseSolution = 0 !== (1 & a);this.StrictlySimple = 0 !== (2 & a);this.PreserveCollinear = 0 !== (4 & a);\n  };d.Clipper.ioReverseSolution = 1;d.Clipper.ioStrictlySimple = 2;d.Clipper.ioPreserveCollinear = 4;d.Clipper.prototype.Clear = function () {\n    0 !== this.m_edges.length && (this.DisposeAllPolyPts(), d.ClipperBase.prototype.Clear.call(this));\n  };d.Clipper.prototype.DisposeScanbeamList = function () {\n    for (; null !== this.m_Scanbeam;) {\n      var a = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;this.m_Scanbeam = a;\n    }\n  };d.Clipper.prototype.Reset = function () {\n    d.ClipperBase.prototype.Reset.call(this);this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;for (var a = this.m_MinimaList; null !== a;) {\n      this.InsertScanbeam(a.Y), a = a.Next;\n    }\n  };d.Clipper.prototype.InsertScanbeam = function (a) {\n    if (null === this.m_Scanbeam) this.m_Scanbeam = new d.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = a;else if (a > this.m_Scanbeam.Y) {\n      var b = new d.Scanbeam();b.Y = a;b.Next = this.m_Scanbeam;this.m_Scanbeam = b;\n    } else {\n      for (var c = this.m_Scanbeam; null !== c.Next && a <= c.Next.Y;) {\n        c = c.Next;\n      }a != c.Y && (b = new d.Scanbeam(), b.Y = a, b.Next = c.Next, c.Next = b);\n    }\n  };d.Clipper.prototype.Execute = function () {\n    var a = arguments,\n        b = a.length,\n        c = a[1] instanceof d.PolyTree;if (4 != b || c) {\n      if (4 == b && c) {\n        var b = a[0],\n            e = a[1],\n            c = a[2],\n            a = a[3];if (this.m_ExecuteLocked) return !1;this.m_ExecuteLocked = !0;this.m_SubjFillType = c;this.m_ClipFillType = a;this.m_ClipType = b;this.m_UsingPolyTree = !0;try {\n          (f = this.ExecuteInternal()) && this.BuildResult2(e);\n        } finally {\n          this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;\n        }return f;\n      }if (2 == b && !c || 2 == b && c) return b = a[0], e = a[1], this.Execute(b, e, d.PolyFillType.pftEvenOdd, d.PolyFillType.pftEvenOdd);\n    } else {\n      b = a[0];e = a[1];c = a[2];a = a[3];if (this.m_ExecuteLocked) return !1;this.m_HasOpenPaths && d.Error("Error: PolyTree struct is need for open path clipping.");this.m_ExecuteLocked = !0;d.Clear(e);this.m_SubjFillType = c;this.m_ClipFillType = a;this.m_ClipType = b;this.m_UsingPolyTree = !1;try {\n        var f = this.ExecuteInternal();f && this.BuildResult(e);\n      } finally {\n        this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;\n      }return f;\n    }\n  };d.Clipper.prototype.FixHoleLinkage = function (a) {\n    if (null !== a.FirstLeft && (a.IsHole == a.FirstLeft.IsHole || null === a.FirstLeft.Pts)) {\n      for (var b = a.FirstLeft; null !== b && (b.IsHole == a.IsHole || null === b.Pts);) {\n        b = b.FirstLeft;\n      }a.FirstLeft = b;\n    }\n  };d.Clipper.prototype.ExecuteInternal = function () {\n    try {\n      this.Reset();if (null === this.m_CurrentLM) return !1;var a = this.PopScanbeam();do {\n        this.InsertLocalMinimaIntoAEL(a);d.Clear(this.m_GhostJoins);this.ProcessHorizontals(!1);if (null === this.m_Scanbeam) break;var b = this.PopScanbeam();\n        if (!this.ProcessIntersections(a, b)) return !1;this.ProcessEdgesAtTopOfScanbeam(b);a = b;\n      } while (null !== this.m_Scanbeam || null !== this.m_CurrentLM);for (var a = 0, c = this.m_PolyOuts.length; a < c; a++) {\n        var e = this.m_PolyOuts[a];null === e.Pts || e.IsOpen || (e.IsHole ^ this.ReverseSolution) == 0 < this.Area(e) && this.ReversePolyPtLinks(e.Pts);\n      }this.JoinCommonEdges();a = 0;for (c = this.m_PolyOuts.length; a < c; a++) {\n        e = this.m_PolyOuts[a], null === e.Pts || e.IsOpen || this.FixupOutPolygon(e);\n      }this.StrictlySimple && this.DoSimplePolygons();return !0;\n    } finally {\n      d.Clear(this.m_Joins), d.Clear(this.m_GhostJoins);\n    }\n  };d.Clipper.prototype.PopScanbeam = function () {\n    var a = this.m_Scanbeam.Y;this.m_Scanbeam = this.m_Scanbeam.Next;return a;\n  };d.Clipper.prototype.DisposeAllPolyPts = function () {\n    for (var a = 0, b = this.m_PolyOuts.length; a < b; ++a) {\n      this.DisposeOutRec(a);\n    }d.Clear(this.m_PolyOuts);\n  };d.Clipper.prototype.DisposeOutRec = function (a) {\n    var b = this.m_PolyOuts[a];null !== b.Pts && this.DisposeOutPts(b.Pts);this.m_PolyOuts[a] = null;\n  };d.Clipper.prototype.DisposeOutPts = function (a) {\n    if (null !== a) for (a.Prev.Next = null; null !== a;) {\n      a = a.Next;\n    }\n  };d.Clipper.prototype.AddJoin = function (a, b, c) {\n    var e = new d.Join();e.OutPt1 = a;e.OutPt2 = b;e.OffPt.X = c.X;e.OffPt.Y = c.Y;this.m_Joins.push(e);\n  };d.Clipper.prototype.AddGhostJoin = function (a, b) {\n    var c = new d.Join();c.OutPt1 = a;c.OffPt.X = b.X;c.OffPt.Y = b.Y;this.m_GhostJoins.push(c);\n  };d.Clipper.prototype.InsertLocalMinimaIntoAEL = function (a) {\n    for (; null !== this.m_CurrentLM && this.m_CurrentLM.Y == a;) {\n      var b = this.m_CurrentLM.LeftBound,\n          c = this.m_CurrentLM.RightBound;this.PopLocalMinima();var e = null;null === b ? (this.InsertEdgeIntoAEL(c, null), this.SetWindingCount(c), this.IsContributing(c) && (e = this.AddOutPt(c, c.Bot))) : (null == c ? (this.InsertEdgeIntoAEL(b, null), this.SetWindingCount(b), this.IsContributing(b) && (e = this.AddOutPt(b, b.Bot))) : (this.InsertEdgeIntoAEL(b, null), this.InsertEdgeIntoAEL(c, b), this.SetWindingCount(b), c.WindCnt = b.WindCnt, c.WindCnt2 = b.WindCnt2, this.IsContributing(b) && (e = this.AddLocalMinPoly(b, c, b.Bot))), this.InsertScanbeam(b.Top.Y));null != c && (d.ClipperBase.IsHorizontal(c) ? this.AddEdgeToSEL(c) : this.InsertScanbeam(c.Top.Y));\n      if (null != b && null != c) {\n        if (null !== e && d.ClipperBase.IsHorizontal(c) && 0 < this.m_GhostJoins.length && 0 !== c.WindDelta) for (var f = 0, g = this.m_GhostJoins.length; f < g; f++) {\n          var h = this.m_GhostJoins[f];this.HorzSegmentsOverlap(h.OutPt1.Pt, h.OffPt, c.Bot, c.Top) && this.AddJoin(h.OutPt1, e, h.OffPt);\n        }0 <= b.OutIdx && null !== b.PrevInAEL && b.PrevInAEL.Curr.X == b.Bot.X && 0 <= b.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual(b.PrevInAEL, b, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== b.PrevInAEL.WindDelta && (f = this.AddOutPt(b.PrevInAEL, b.Bot), this.AddJoin(e, f, b.Top));if (b.NextInAEL != c && (0 <= c.OutIdx && 0 <= c.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual(c.PrevInAEL, c, this.m_UseFullRange) && 0 !== c.WindDelta && 0 !== c.PrevInAEL.WindDelta && (f = this.AddOutPt(c.PrevInAEL, c.Bot), this.AddJoin(e, f, c.Top)), e = b.NextInAEL, null !== e)) for (; e != c;) {\n          this.IntersectEdges(c, e, b.Curr, !1), e = e.NextInAEL;\n        }\n      }\n    }\n  };d.Clipper.prototype.InsertEdgeIntoAEL = function (a, b) {\n    if (null === this.m_ActiveEdges) a.PrevInAEL = null, a.NextInAEL = null, this.m_ActiveEdges = a;else if (null === b && this.E2InsertsBeforeE1(this.m_ActiveEdges, a)) a.PrevInAEL = null, a.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges = this.m_ActiveEdges.PrevInAEL = a;else {\n      null === b && (b = this.m_ActiveEdges);for (; null !== b.NextInAEL && !this.E2InsertsBeforeE1(b.NextInAEL, a);) {\n        b = b.NextInAEL;\n      }a.NextInAEL = b.NextInAEL;null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = a);a.PrevInAEL = b;b.NextInAEL = a;\n    }\n  };d.Clipper.prototype.E2InsertsBeforeE1 = function (a, b) {\n    return b.Curr.X == a.Curr.X ? b.Top.Y > a.Top.Y ? b.Top.X < d.Clipper.TopX(a, b.Top.Y) : a.Top.X > d.Clipper.TopX(b, a.Top.Y) : b.Curr.X < a.Curr.X;\n  };d.Clipper.prototype.IsEvenOddFillType = function (a) {\n    return a.PolyTyp == d.PolyType.ptSubject ? this.m_SubjFillType == d.PolyFillType.pftEvenOdd : this.m_ClipFillType == d.PolyFillType.pftEvenOdd;\n  };d.Clipper.prototype.IsEvenOddAltFillType = function (a) {\n    return a.PolyTyp == d.PolyType.ptSubject ? this.m_ClipFillType == d.PolyFillType.pftEvenOdd : this.m_SubjFillType == d.PolyFillType.pftEvenOdd;\n  };d.Clipper.prototype.IsContributing = function (a) {\n    var b, c;a.PolyTyp == d.PolyType.ptSubject ? (b = this.m_SubjFillType, c = this.m_ClipFillType) : (b = this.m_ClipFillType, c = this.m_SubjFillType);\n    switch (b) {case d.PolyFillType.pftEvenOdd:\n        if (0 === a.WindDelta && 1 != a.WindCnt) return !1;break;case d.PolyFillType.pftNonZero:\n        if (1 != Math.abs(a.WindCnt)) return !1;break;case d.PolyFillType.pftPositive:\n        if (1 != a.WindCnt) return !1;break;default:\n        if (-1 != a.WindCnt) return !1;}switch (this.m_ClipType) {case d.ClipType.ctIntersection:\n        switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 !== a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 < a.WindCnt2;default:\n            return 0 > a.WindCnt2;}case d.ClipType.ctUnion:\n        switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;}case d.ClipType.ctDifference:\n        if (a.PolyTyp == d.PolyType.ptSubject) switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;} else switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 !== a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 < a.WindCnt2;default:\n            return 0 > a.WindCnt2;}case d.ClipType.ctXor:\n        if (0 === a.WindDelta) switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;}}return !0;\n  };d.Clipper.prototype.SetWindingCount = function (a) {\n    for (var b = a.PrevInAEL; null !== b && (b.PolyTyp != a.PolyTyp || 0 === b.WindDelta);) {\n      b = b.PrevInAEL;\n    }if (null === b) a.WindCnt = 0 === a.WindDelta ? 1 : a.WindDelta, a.WindCnt2 = 0, b = this.m_ActiveEdges;else {\n      if (0 === a.WindDelta && this.m_ClipType != d.ClipType.ctUnion) a.WindCnt = 1;else if (this.IsEvenOddFillType(a)) {\n        if (0 === a.WindDelta) {\n          for (var c = !0, e = b.PrevInAEL; null !== e;) {\n            e.PolyTyp == b.PolyTyp && 0 !== e.WindDelta && (c = !c), e = e.PrevInAEL;\n          }a.WindCnt = c ? 0 : 1;\n        } else a.WindCnt = a.WindDelta;\n      } else 0 > b.WindCnt * b.WindDelta ? 1 < Math.abs(b.WindCnt) ? a.WindCnt = 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta : a.WindCnt = 0 === a.WindDelta ? 1 : a.WindDelta : a.WindCnt = 0 === a.WindDelta ? 0 > b.WindCnt ? b.WindCnt - 1 : b.WindCnt + 1 : 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta;\n      a.WindCnt2 = b.WindCnt2;b = b.NextInAEL;\n    }if (this.IsEvenOddAltFillType(a)) for (; b != a;) {\n      0 !== b.WindDelta && (a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0), b = b.NextInAEL;\n    } else for (; b != a;) {\n      a.WindCnt2 += b.WindDelta, b = b.NextInAEL;\n    }\n  };d.Clipper.prototype.AddEdgeToSEL = function (a) {\n    null === this.m_SortedEdges ? (this.m_SortedEdges = a, a.PrevInSEL = null, a.NextInSEL = null) : (a.NextInSEL = this.m_SortedEdges, a.PrevInSEL = null, this.m_SortedEdges = this.m_SortedEdges.PrevInSEL = a);\n  };d.Clipper.prototype.CopyAELToSEL = function () {\n    var a = this.m_ActiveEdges;for (this.m_SortedEdges = a; null !== a;) {\n      a.PrevInSEL = a.PrevInAEL, a = a.NextInSEL = a.NextInAEL;\n    }\n  };d.Clipper.prototype.SwapPositionsInAEL = function (a, b) {\n    if (a.NextInAEL != a.PrevInAEL && b.NextInAEL != b.PrevInAEL) {\n      if (a.NextInAEL == b) {\n        var c = b.NextInAEL;null !== c && (c.PrevInAEL = a);var e = a.PrevInAEL;null !== e && (e.NextInAEL = b);b.PrevInAEL = e;b.NextInAEL = a;a.PrevInAEL = b;a.NextInAEL = c;\n      } else b.NextInAEL == a ? (c = a.NextInAEL, null !== c && (c.PrevInAEL = b), e = b.PrevInAEL, null !== e && (e.NextInAEL = a), a.PrevInAEL = e, a.NextInAEL = b, b.PrevInAEL = a, b.NextInAEL = c) : (c = a.NextInAEL, e = a.PrevInAEL, a.NextInAEL = b.NextInAEL, null !== a.NextInAEL && (a.NextInAEL.PrevInAEL = a), a.PrevInAEL = b.PrevInAEL, null !== a.PrevInAEL && (a.PrevInAEL.NextInAEL = a), b.NextInAEL = c, null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = b), b.PrevInAEL = e, null !== b.PrevInAEL && (b.PrevInAEL.NextInAEL = b));null === a.PrevInAEL ? this.m_ActiveEdges = a : null === b.PrevInAEL && (this.m_ActiveEdges = b);\n    }\n  };d.Clipper.prototype.SwapPositionsInSEL = function (a, b) {\n    if (null !== a.NextInSEL || null !== a.PrevInSEL) if (null !== b.NextInSEL || null !== b.PrevInSEL) {\n      if (a.NextInSEL == b) {\n        var c = b.NextInSEL;null !== c && (c.PrevInSEL = a);var e = a.PrevInSEL;null !== e && (e.NextInSEL = b);b.PrevInSEL = e;b.NextInSEL = a;a.PrevInSEL = b;a.NextInSEL = c;\n      } else b.NextInSEL == a ? (c = a.NextInSEL, null !== c && (c.PrevInSEL = b), e = b.PrevInSEL, null !== e && (e.NextInSEL = a), a.PrevInSEL = e, a.NextInSEL = b, b.PrevInSEL = a, b.NextInSEL = c) : (c = a.NextInSEL, e = a.PrevInSEL, a.NextInSEL = b.NextInSEL, null !== a.NextInSEL && (a.NextInSEL.PrevInSEL = a), a.PrevInSEL = b.PrevInSEL, null !== a.PrevInSEL && (a.PrevInSEL.NextInSEL = a), b.NextInSEL = c, null !== b.NextInSEL && (b.NextInSEL.PrevInSEL = b), b.PrevInSEL = e, null !== b.PrevInSEL && (b.PrevInSEL.NextInSEL = b));null === a.PrevInSEL ? this.m_SortedEdges = a : null === b.PrevInSEL && (this.m_SortedEdges = b);\n    }\n  };d.Clipper.prototype.AddLocalMaxPoly = function (a, b, c) {\n    this.AddOutPt(a, c);0 == b.WindDelta && this.AddOutPt(b, c);a.OutIdx == b.OutIdx ? (a.OutIdx = -1, b.OutIdx = -1) : a.OutIdx < b.OutIdx ? this.AppendPolygon(a, b) : this.AppendPolygon(b, a);\n  };d.Clipper.prototype.AddLocalMinPoly = function (a, b, c) {\n    var e, f;d.ClipperBase.IsHorizontal(b) || a.Dx > b.Dx ? (e = this.AddOutPt(a, c), b.OutIdx = a.OutIdx, a.Side = d.EdgeSide.esLeft, b.Side = d.EdgeSide.esRight, f = a, a = f.PrevInAEL == b ? b.PrevInAEL : f.PrevInAEL) : (e = this.AddOutPt(b, c), a.OutIdx = b.OutIdx, a.Side = d.EdgeSide.esRight, b.Side = d.EdgeSide.esLeft, f = b, a = f.PrevInAEL == a ? a.PrevInAEL : f.PrevInAEL);null !== a && 0 <= a.OutIdx && d.Clipper.TopX(a, c.Y) == d.Clipper.TopX(f, c.Y) && d.ClipperBase.SlopesEqual(f, a, this.m_UseFullRange) && 0 !== f.WindDelta && 0 !== a.WindDelta && (c = this.AddOutPt(a, c), this.AddJoin(e, c, f.Top));return e;\n  };d.Clipper.prototype.CreateOutRec = function () {\n    var a = new d.OutRec();a.Idx = -1;a.IsHole = !1;a.IsOpen = !1;a.FirstLeft = null;a.Pts = null;a.BottomPt = null;a.PolyNode = null;this.m_PolyOuts.push(a);a.Idx = this.m_PolyOuts.length - 1;return a;\n  };d.Clipper.prototype.AddOutPt = function (a, b) {\n    var c = a.Side == d.EdgeSide.esLeft;if (0 > a.OutIdx) {\n      var e = this.CreateOutRec();e.IsOpen = 0 === a.WindDelta;var f = new d.OutPt();e.Pts = f;f.Idx = e.Idx;f.Pt.X = b.X;f.Pt.Y = b.Y;f.Next = f;f.Prev = f;e.IsOpen || this.SetHoleState(a, e);a.OutIdx = e.Idx;\n    } else {\n      var e = this.m_PolyOuts[a.OutIdx],\n          g = e.Pts;if (c && d.IntPoint.op_Equality(b, g.Pt)) return g;if (!c && d.IntPoint.op_Equality(b, g.Prev.Pt)) return g.Prev;f = new d.OutPt();f.Idx = e.Idx;f.Pt.X = b.X;f.Pt.Y = b.Y;f.Next = g;f.Prev = g.Prev;f.Prev.Next = f;g.Prev = f;c && (e.Pts = f);\n    }return f;\n  };d.Clipper.prototype.SwapPoints = function (a, b) {\n    var c = new d.IntPoint(a.Value);a.Value.X = b.Value.X;a.Value.Y = b.Value.Y;b.Value.X = c.X;b.Value.Y = c.Y;\n  };d.Clipper.prototype.HorzSegmentsOverlap = function (a, b, c, e) {\n    return a.X > c.X == a.X < e.X ? !0 : b.X > c.X == b.X < e.X ? !0 : c.X > a.X == c.X < b.X ? !0 : e.X > a.X == e.X < b.X ? !0 : a.X == c.X && b.X == e.X ? !0 : a.X == e.X && b.X == c.X ? !0 : !1;\n  };d.Clipper.prototype.InsertPolyPtBetween = function (a, b, c) {\n    var e = new d.OutPt();e.Pt.X = c.X;e.Pt.Y = c.Y;b == a.Next ? (a.Next = e, b.Prev = e, e.Next = b, e.Prev = a) : (b.Next = e, a.Prev = e, e.Next = a, e.Prev = b);return e;\n  };d.Clipper.prototype.SetHoleState = function (a, b) {\n    for (var c = !1, e = a.PrevInAEL; null !== e;) {\n      0 <= e.OutIdx && 0 != e.WindDelta && (c = !c, null === b.FirstLeft && (b.FirstLeft = this.m_PolyOuts[e.OutIdx])), e = e.PrevInAEL;\n    }c && (b.IsHole = !0);\n  };d.Clipper.prototype.GetDx = function (a, b) {\n    return a.Y == b.Y ? d.ClipperBase.horizontal : (b.X - a.X) / (b.Y - a.Y);\n  };d.Clipper.prototype.FirstIsBottomPt = function (a, b) {\n    for (var c = a.Prev; d.IntPoint.op_Equality(c.Pt, a.Pt) && c != a;) {\n      c = c.Prev;\n    }for (var e = Math.abs(this.GetDx(a.Pt, c.Pt)), c = a.Next; d.IntPoint.op_Equality(c.Pt, a.Pt) && c != a;) {\n      c = c.Next;\n    }for (var f = Math.abs(this.GetDx(a.Pt, c.Pt)), c = b.Prev; d.IntPoint.op_Equality(c.Pt, b.Pt) && c != b;) {\n      c = c.Prev;\n    }for (var g = Math.abs(this.GetDx(b.Pt, c.Pt)), c = b.Next; d.IntPoint.op_Equality(c.Pt, b.Pt) && c != b;) {\n      c = c.Next;\n    }c = Math.abs(this.GetDx(b.Pt, c.Pt));return e >= g && e >= c || f >= g && f >= c;\n  };d.Clipper.prototype.GetBottomPt = function (a) {\n    for (var b = null, c = a.Next; c != a;) {\n      c.Pt.Y > a.Pt.Y ? (a = c, b = null) : c.Pt.Y == a.Pt.Y && c.Pt.X <= a.Pt.X && (c.Pt.X < a.Pt.X ? (b = null, a = c) : c.Next != a && c.Prev != a && (b = c)), c = c.Next;\n    }if (null !== b) for (; b != c;) {\n      for (this.FirstIsBottomPt(c, b) || (a = b), b = b.Next; d.IntPoint.op_Inequality(b.Pt, a.Pt);) {\n        b = b.Next;\n      }\n    }return a;\n  };d.Clipper.prototype.GetLowermostRec = function (a, b) {\n    null === a.BottomPt && (a.BottomPt = this.GetBottomPt(a.Pts));null === b.BottomPt && (b.BottomPt = this.GetBottomPt(b.Pts));var c = a.BottomPt,\n        e = b.BottomPt;return c.Pt.Y > e.Pt.Y ? a : c.Pt.Y < e.Pt.Y ? b : c.Pt.X < e.Pt.X ? a : c.Pt.X > e.Pt.X ? b : c.Next == c ? b : e.Next == e ? a : this.FirstIsBottomPt(c, e) ? a : b;\n  };d.Clipper.prototype.Param1RightOfParam2 = function (a, b) {\n    do {\n      if (a = a.FirstLeft, a == b) return !0;\n    } while (null !== a);return !1;\n  };d.Clipper.prototype.GetOutRec = function (a) {\n    for (a = this.m_PolyOuts[a]; a != this.m_PolyOuts[a.Idx];) {\n      a = this.m_PolyOuts[a.Idx];\n    }return a;\n  };d.Clipper.prototype.AppendPolygon = function (a, b) {\n    var c = this.m_PolyOuts[a.OutIdx],\n        e = this.m_PolyOuts[b.OutIdx],\n        f;f = this.Param1RightOfParam2(c, e) ? e : this.Param1RightOfParam2(e, c) ? c : this.GetLowermostRec(c, e);var g = c.Pts,\n        h = g.Prev,\n        l = e.Pts,\n        k = l.Prev;a.Side == d.EdgeSide.esLeft ? (b.Side == d.EdgeSide.esLeft ? (this.ReversePolyPtLinks(l), l.Next = g, g.Prev = l, h.Next = k, k.Prev = h, c.Pts = k) : (k.Next = g, g.Prev = k, l.Prev = h, h.Next = l, c.Pts = l), g = d.EdgeSide.esLeft) : (b.Side == d.EdgeSide.esRight ? (this.ReversePolyPtLinks(l), h.Next = k, k.Prev = h, l.Next = g, g.Prev = l) : (h.Next = l, l.Prev = h, g.Prev = k, k.Next = g), g = d.EdgeSide.esRight);c.BottomPt = null;f == e && (e.FirstLeft != c && (c.FirstLeft = e.FirstLeft), c.IsHole = e.IsHole);e.Pts = null;e.BottomPt = null;e.FirstLeft = c;f = a.OutIdx;h = b.OutIdx;a.OutIdx = -1;b.OutIdx = -1;for (l = this.m_ActiveEdges; null !== l;) {\n      if (l.OutIdx == h) {\n        l.OutIdx = f;l.Side = g;break;\n      }l = l.NextInAEL;\n    }e.Idx = c.Idx;\n  };d.Clipper.prototype.ReversePolyPtLinks = function (a) {\n    if (null !== a) {\n      var b, c;b = a;do {\n        c = b.Next, b.Next = b.Prev, b = b.Prev = c;\n      } while (b != a);\n    }\n  };d.Clipper.SwapSides = function (a, b) {\n    var c = a.Side;a.Side = b.Side;b.Side = c;\n  };d.Clipper.SwapPolyIndexes = function (a, b) {\n    var c = a.OutIdx;a.OutIdx = b.OutIdx;b.OutIdx = c;\n  };d.Clipper.prototype.IntersectEdges = function (a, b, c, e) {\n    var f = !e && null === a.NextInLML && a.Top.X == c.X && a.Top.Y == c.Y;e = !e && null === b.NextInLML && b.Top.X == c.X && b.Top.Y == c.Y;var g = 0 <= a.OutIdx,\n        h = 0 <= b.OutIdx;if (0 === a.WindDelta || 0 === b.WindDelta) 0 === a.WindDelta && 0 === b.WindDelta ? (f || e) && g && h && this.AddLocalMaxPoly(a, b, c) : a.PolyTyp == b.PolyTyp && a.WindDelta != b.WindDelta && this.m_ClipType == d.ClipType.ctUnion ? 0 === a.WindDelta ? h && (this.AddOutPt(a, c), g && (a.OutIdx = -1)) : g && (this.AddOutPt(b, c), h && (b.OutIdx = -1)) : a.PolyTyp != b.PolyTyp && (0 !== a.WindDelta || 1 != Math.abs(b.WindCnt) || this.m_ClipType == d.ClipType.ctUnion && 0 !== b.WindCnt2 ? 0 !== b.WindDelta || 1 != Math.abs(a.WindCnt) || this.m_ClipType == d.ClipType.ctUnion && 0 !== a.WindCnt2 || (this.AddOutPt(b, c), h && (b.OutIdx = -1)) : (this.AddOutPt(a, c), g && (a.OutIdx = -1))), f && (0 > a.OutIdx ? this.DeleteFromAEL(a) : d.Error("Error intersecting polylines")), e && (0 > b.OutIdx ? this.DeleteFromAEL(b) : d.Error("Error intersecting polylines"));else {\n      if (a.PolyTyp == b.PolyTyp) {\n        if (this.IsEvenOddFillType(a)) {\n          var l = a.WindCnt;a.WindCnt = b.WindCnt;b.WindCnt = l;\n        } else a.WindCnt = 0 === a.WindCnt + b.WindDelta ? -a.WindCnt : a.WindCnt + b.WindDelta, b.WindCnt = 0 === b.WindCnt - a.WindDelta ? -b.WindCnt : b.WindCnt - a.WindDelta;\n      } else this.IsEvenOddFillType(b) ? a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0 : a.WindCnt2 += b.WindDelta, this.IsEvenOddFillType(a) ? b.WindCnt2 = 0 === b.WindCnt2 ? 1 : 0 : b.WindCnt2 -= a.WindDelta;var k, n, m;a.PolyTyp == d.PolyType.ptSubject ? (k = this.m_SubjFillType, m = this.m_ClipFillType) : (k = this.m_ClipFillType, m = this.m_SubjFillType);b.PolyTyp == d.PolyType.ptSubject ? (n = this.m_SubjFillType, l = this.m_ClipFillType) : (n = this.m_ClipFillType, l = this.m_SubjFillType);switch (k) {case d.PolyFillType.pftPositive:\n          k = a.WindCnt;break;case d.PolyFillType.pftNegative:\n          k = -a.WindCnt;break;default:\n          k = Math.abs(a.WindCnt);}switch (n) {case d.PolyFillType.pftPositive:\n          n = b.WindCnt;break;case d.PolyFillType.pftNegative:\n          n = -b.WindCnt;break;default:\n          n = Math.abs(b.WindCnt);}if (g && h) f || e || 0 !== k && 1 != k || 0 !== n && 1 != n || a.PolyTyp != b.PolyTyp && this.m_ClipType != d.ClipType.ctXor ? this.AddLocalMaxPoly(a, b, c) : (this.AddOutPt(a, c), this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b));else if (g) {\n        if (0 === n || 1 == n) this.AddOutPt(a, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);\n      } else if (h) {\n        if (0 === k || 1 == k) this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);\n      } else if (!(0 !== k && 1 != k || 0 !== n && 1 != n || f || e)) {\n        switch (m) {case d.PolyFillType.pftPositive:\n            g = a.WindCnt2;break;case d.PolyFillType.pftNegative:\n            g = -a.WindCnt2;break;default:\n            g = Math.abs(a.WindCnt2);}switch (l) {case d.PolyFillType.pftPositive:\n            h = b.WindCnt2;break;case d.PolyFillType.pftNegative:\n            h = -b.WindCnt2;break;default:\n            h = Math.abs(b.WindCnt2);}if (a.PolyTyp != b.PolyTyp) this.AddLocalMinPoly(a, b, c);else if (1 == k && 1 == n) switch (this.m_ClipType) {case d.ClipType.ctIntersection:\n            0 < g && 0 < h && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctUnion:\n            0 >= g && 0 >= h && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctDifference:\n            (a.PolyTyp == d.PolyType.ptClip && 0 < g && 0 < h || a.PolyTyp == d.PolyType.ptSubject && 0 >= g && 0 >= h) && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctXor:\n            this.AddLocalMinPoly(a, b, c);} else d.Clipper.SwapSides(a, b);\n      }f != e && (f && 0 <= a.OutIdx || e && 0 <= b.OutIdx) && (d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b));f && this.DeleteFromAEL(a);e && this.DeleteFromAEL(b);\n    }\n  };d.Clipper.prototype.DeleteFromAEL = function (a) {\n    var b = a.PrevInAEL,\n        c = a.NextInAEL;if (null !== b || null !== c || a == this.m_ActiveEdges) null !== b ? b.NextInAEL = c : this.m_ActiveEdges = c, null !== c && (c.PrevInAEL = b), a.NextInAEL = null, a.PrevInAEL = null;\n  };d.Clipper.prototype.DeleteFromSEL = function (a) {\n    var b = a.PrevInSEL,\n        c = a.NextInSEL;if (null !== b || null !== c || a == this.m_SortedEdges) null !== b ? b.NextInSEL = c : this.m_SortedEdges = c, null !== c && (c.PrevInSEL = b), a.NextInSEL = null, a.PrevInSEL = null;\n  };d.Clipper.prototype.UpdateEdgeIntoAEL = function (a) {\n    null === a.NextInLML && d.Error("UpdateEdgeIntoAEL: invalid call");var b = a.PrevInAEL,\n        c = a.NextInAEL;a.NextInLML.OutIdx = a.OutIdx;null !== b ? b.NextInAEL = a.NextInLML : this.m_ActiveEdges = a.NextInLML;null !== c && (c.PrevInAEL = a.NextInLML);a.NextInLML.Side = a.Side;a.NextInLML.WindDelta = a.WindDelta;a.NextInLML.WindCnt = a.WindCnt;a.NextInLML.WindCnt2 = a.WindCnt2;a = a.NextInLML;\n    a.Curr.X = a.Bot.X;a.Curr.Y = a.Bot.Y;a.PrevInAEL = b;a.NextInAEL = c;d.ClipperBase.IsHorizontal(a) || this.InsertScanbeam(a.Top.Y);return a;\n  };d.Clipper.prototype.ProcessHorizontals = function (a) {\n    for (var b = this.m_SortedEdges; null !== b;) {\n      this.DeleteFromSEL(b), this.ProcessHorizontal(b, a), b = this.m_SortedEdges;\n    }\n  };d.Clipper.prototype.GetHorzDirection = function (a, b) {\n    a.Bot.X < a.Top.X ? (b.Left = a.Bot.X, b.Right = a.Top.X, b.Dir = d.Direction.dLeftToRight) : (b.Left = a.Top.X, b.Right = a.Bot.X, b.Dir = d.Direction.dRightToLeft);\n  };d.Clipper.prototype.PrepareHorzJoins = function (a, b) {\n    var c = this.m_PolyOuts[a.OutIdx].Pts;a.Side != d.EdgeSide.esLeft && (c = c.Prev);b && (d.IntPoint.op_Equality(c.Pt, a.Top) ? this.AddGhostJoin(c, a.Bot) : this.AddGhostJoin(c, a.Top));\n  };d.Clipper.prototype.ProcessHorizontal = function (a, b) {\n    var c = { Dir: null, Left: null, Right: null };this.GetHorzDirection(a, c);for (var e = c.Dir, f = c.Left, g = c.Right, h = a, l = null; null !== h.NextInLML && d.ClipperBase.IsHorizontal(h.NextInLML);) {\n      h = h.NextInLML;\n    }for (null === h.NextInLML && (l = this.GetMaximaPair(h));;) {\n      for (var k = a == h, n = this.GetNextInAEL(a, e); null !== n && !(n.Curr.X == a.Top.X && null !== a.NextInLML && n.Dx < a.NextInLML.Dx);) {\n        c = this.GetNextInAEL(n, e);if (e == d.Direction.dLeftToRight && n.Curr.X <= g || e == d.Direction.dRightToLeft && n.Curr.X >= f) {\n          0 <= a.OutIdx && 0 != a.WindDelta && this.PrepareHorzJoins(a, b);if (n == l && k) {\n            e == d.Direction.dLeftToRight ? this.IntersectEdges(a, n, n.Top, !1) : this.IntersectEdges(n, a, n.Top, !1);0 <= l.OutIdx && d.Error("ProcessHorizontal error");return;\n          }if (e == d.Direction.dLeftToRight) {\n            var m = new d.IntPoint(n.Curr.X, a.Curr.Y);this.IntersectEdges(a, n, m, !0);\n          } else m = new d.IntPoint(n.Curr.X, a.Curr.Y), this.IntersectEdges(n, a, m, !0);this.SwapPositionsInAEL(a, n);\n        } else if (e == d.Direction.dLeftToRight && n.Curr.X >= g || e == d.Direction.dRightToLeft && n.Curr.X <= f) break;n = c;\n      }0 <= a.OutIdx && 0 !== a.WindDelta && this.PrepareHorzJoins(a, b);if (null !== a.NextInLML && d.ClipperBase.IsHorizontal(a.NextInLML)) a = this.UpdateEdgeIntoAEL(a), 0 <= a.OutIdx && this.AddOutPt(a, a.Bot), c = { Dir: e, Left: f, Right: g }, this.GetHorzDirection(a, c), e = c.Dir, f = c.Left, g = c.Right;else break;\n    }null !== a.NextInLML ? 0 <= a.OutIdx ? (e = this.AddOutPt(a, a.Top), a = this.UpdateEdgeIntoAEL(a), 0 !== a.WindDelta && (f = a.PrevInAEL, c = a.NextInAEL, null !== f && f.Curr.X == a.Bot.X && f.Curr.Y == a.Bot.Y && 0 !== f.WindDelta && 0 <= f.OutIdx && f.Curr.Y > f.Top.Y && d.ClipperBase.SlopesEqual(a, f, this.m_UseFullRange) ? (c = this.AddOutPt(f, a.Bot), this.AddJoin(e, c, a.Top)) : null !== c && c.Curr.X == a.Bot.X && c.Curr.Y == a.Bot.Y && 0 !== c.WindDelta && 0 <= c.OutIdx && c.Curr.Y > c.Top.Y && d.ClipperBase.SlopesEqual(a, c, this.m_UseFullRange) && (c = this.AddOutPt(c, a.Bot), this.AddJoin(e, c, a.Top)))) : this.UpdateEdgeIntoAEL(a) : null !== l ? 0 <= l.OutIdx ? (e == d.Direction.dLeftToRight ? this.IntersectEdges(a, l, a.Top, !1) : this.IntersectEdges(l, a, a.Top, !1), 0 <= l.OutIdx && d.Error("ProcessHorizontal error")) : (this.DeleteFromAEL(a), this.DeleteFromAEL(l)) : (0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a));\n  };d.Clipper.prototype.GetNextInAEL = function (a, b) {\n    return b == d.Direction.dLeftToRight ? a.NextInAEL : a.PrevInAEL;\n  };d.Clipper.prototype.IsMinima = function (a) {\n    return null !== a && a.Prev.NextInLML != a && a.Next.NextInLML != a;\n  };d.Clipper.prototype.IsMaxima = function (a, b) {\n    return null !== a && a.Top.Y == b && null === a.NextInLML;\n  };d.Clipper.prototype.IsIntermediate = function (a, b) {\n    return a.Top.Y == b && null !== a.NextInLML;\n  };d.Clipper.prototype.GetMaximaPair = function (a) {\n    var b = null;d.IntPoint.op_Equality(a.Next.Top, a.Top) && null === a.Next.NextInLML ? b = a.Next : d.IntPoint.op_Equality(a.Prev.Top, a.Top) && null === a.Prev.NextInLML && (b = a.Prev);return null === b || -2 != b.OutIdx && (b.NextInAEL != b.PrevInAEL || d.ClipperBase.IsHorizontal(b)) ? b : null;\n  };d.Clipper.prototype.ProcessIntersections = function (a, b) {\n    if (null == this.m_ActiveEdges) return !0;try {\n      this.BuildIntersectList(a, b);if (0 == this.m_IntersectList.length) return !0;if (1 == this.m_IntersectList.length || this.FixupIntersectionOrder()) this.ProcessIntersectList();else return !1;\n    } catch (c) {\n      this.m_SortedEdges = null, this.m_IntersectList.length = 0, d.Error("ProcessIntersections error");\n    }this.m_SortedEdges = null;return !0;\n  };d.Clipper.prototype.BuildIntersectList = function (a, b) {\n    if (null !== this.m_ActiveEdges) {\n      var c = this.m_ActiveEdges;for (this.m_SortedEdges = c; null !== c;) {\n        c.PrevInSEL = c.PrevInAEL, c.NextInSEL = c.NextInAEL, c.Curr.X = d.Clipper.TopX(c, b), c = c.NextInAEL;\n      }for (var e = !0; e && null !== this.m_SortedEdges;) {\n        e = !1;for (c = this.m_SortedEdges; null !== c.NextInSEL;) {\n          var f = c.NextInSEL,\n              g = new d.IntPoint();c.Curr.X > f.Curr.X ? (!this.IntersectPoint(c, f, g) && c.Curr.X > f.Curr.X + 1 && d.Error("Intersection error"), g.Y > a && (g.Y = a, Math.abs(c.Dx) > Math.abs(f.Dx) ? g.X = d.Clipper.TopX(f, a) : g.X = d.Clipper.TopX(c, a)), e = new d.IntersectNode(), e.Edge1 = c, e.Edge2 = f, e.Pt.X = g.X, e.Pt.Y = g.Y, this.m_IntersectList.push(e), this.SwapPositionsInSEL(c, f), e = !0) : c = f;\n        }if (null !== c.PrevInSEL) c.PrevInSEL.NextInSEL = null;else break;\n      }this.m_SortedEdges = null;\n    }\n  };d.Clipper.prototype.EdgesAdjacent = function (a) {\n    return a.Edge1.NextInSEL == a.Edge2 || a.Edge1.PrevInSEL == a.Edge2;\n  };d.Clipper.IntersectNodeSort = function (a, b) {\n    return b.Pt.Y - a.Pt.Y;\n  };d.Clipper.prototype.FixupIntersectionOrder = function () {\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);this.CopyAELToSEL();for (var a = this.m_IntersectList.length, b = 0; b < a; b++) {\n      if (!this.EdgesAdjacent(this.m_IntersectList[b])) {\n        for (var c = b + 1; c < a && !this.EdgesAdjacent(this.m_IntersectList[c]);) {\n          c++;\n        }if (c == a) return !1;var e = this.m_IntersectList[b];this.m_IntersectList[b] = this.m_IntersectList[c];this.m_IntersectList[c] = e;\n      }this.SwapPositionsInSEL(this.m_IntersectList[b].Edge1, this.m_IntersectList[b].Edge2);\n    }return !0;\n  };d.Clipper.prototype.ProcessIntersectList = function () {\n    for (var a = 0, b = this.m_IntersectList.length; a < b; a++) {\n      var c = this.m_IntersectList[a];this.IntersectEdges(c.Edge1, c.Edge2, c.Pt, !0);this.SwapPositionsInAEL(c.Edge1, c.Edge2);\n    }this.m_IntersectList.length = 0;\n  };E = function E(a) {\n    return 0 > a ? Math.ceil(a - 0.5) : Math.round(a);\n  };F = function F(a) {\n    return 0 > a ? Math.ceil(a - 0.5) : Math.floor(a + 0.5);\n  };G = function G(a) {\n    return 0 > a ? -Math.round(Math.abs(a)) : Math.round(a);\n  };H = function H(a) {\n    if (0 > a) return a -= 0.5, -2147483648 > a ? Math.ceil(a) : a | 0;a += 0.5;return 2147483647 < a ? Math.floor(a) : a | 0;\n  };d.Clipper.Round = p ? E : D ? G : J ? H : F;d.Clipper.TopX = function (a, b) {\n    return b == a.Top.Y ? a.Top.X : a.Bot.X + d.Clipper.Round(a.Dx * (b - a.Bot.Y));\n  };d.Clipper.prototype.IntersectPoint = function (a, b, c) {\n    c.X = 0;c.Y = 0;var e, f;if (d.ClipperBase.SlopesEqual(a, b, this.m_UseFullRange) || a.Dx == b.Dx) return b.Bot.Y > a.Bot.Y ? (c.X = b.Bot.X, c.Y = b.Bot.Y) : (c.X = a.Bot.X, c.Y = a.Bot.Y), !1;if (0 === a.Delta.X) c.X = a.Bot.X, d.ClipperBase.IsHorizontal(b) ? c.Y = b.Bot.Y : (f = b.Bot.Y - b.Bot.X / b.Dx, c.Y = d.Clipper.Round(c.X / b.Dx + f));else if (0 === b.Delta.X) c.X = b.Bot.X, d.ClipperBase.IsHorizontal(a) ? c.Y = a.Bot.Y : (e = a.Bot.Y - a.Bot.X / a.Dx, c.Y = d.Clipper.Round(c.X / a.Dx + e));else {\n      e = a.Bot.X - a.Bot.Y * a.Dx;f = b.Bot.X - b.Bot.Y * b.Dx;var g = (f - e) / (a.Dx - b.Dx);c.Y = d.Clipper.Round(g);Math.abs(a.Dx) < Math.abs(b.Dx) ? c.X = d.Clipper.Round(a.Dx * g + e) : c.X = d.Clipper.Round(b.Dx * g + f);\n    }if (c.Y < a.Top.Y || c.Y < b.Top.Y) {\n      if (a.Top.Y > b.Top.Y) return c.Y = a.Top.Y, c.X = d.Clipper.TopX(b, a.Top.Y), c.X < a.Top.X;c.Y = b.Top.Y;Math.abs(a.Dx) < Math.abs(b.Dx) ? c.X = d.Clipper.TopX(a, c.Y) : c.X = d.Clipper.TopX(b, c.Y);\n    }return !0;\n  };d.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (a) {\n    for (var b = this.m_ActiveEdges; null !== b;) {\n      var c = this.IsMaxima(b, a);c && (c = this.GetMaximaPair(b), c = null === c || !d.ClipperBase.IsHorizontal(c));if (c) {\n        var e = b.PrevInAEL;this.DoMaxima(b);\n        b = null === e ? this.m_ActiveEdges : e.NextInAEL;\n      } else this.IsIntermediate(b, a) && d.ClipperBase.IsHorizontal(b.NextInLML) ? (b = this.UpdateEdgeIntoAEL(b), 0 <= b.OutIdx && this.AddOutPt(b, b.Bot), this.AddEdgeToSEL(b)) : (b.Curr.X = d.Clipper.TopX(b, a), b.Curr.Y = a), this.StrictlySimple && (e = b.PrevInAEL, 0 <= b.OutIdx && 0 !== b.WindDelta && null !== e && 0 <= e.OutIdx && e.Curr.X == b.Curr.X && 0 !== e.WindDelta && (c = this.AddOutPt(e, b.Curr), e = this.AddOutPt(b, b.Curr), this.AddJoin(c, e, b.Curr))), b = b.NextInAEL;\n    }this.ProcessHorizontals(!0);for (b = this.m_ActiveEdges; null !== b;) {\n      if (this.IsIntermediate(b, a)) {\n        c = null;0 <= b.OutIdx && (c = this.AddOutPt(b, b.Top));var b = this.UpdateEdgeIntoAEL(b),\n            e = b.PrevInAEL,\n            f = b.NextInAEL;null !== e && e.Curr.X == b.Bot.X && e.Curr.Y == b.Bot.Y && null !== c && 0 <= e.OutIdx && e.Curr.Y > e.Top.Y && d.ClipperBase.SlopesEqual(b, e, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== e.WindDelta ? (e = this.AddOutPt(e, b.Bot), this.AddJoin(c, e, b.Top)) : null !== f && f.Curr.X == b.Bot.X && f.Curr.Y == b.Bot.Y && null !== c && 0 <= f.OutIdx && f.Curr.Y > f.Top.Y && d.ClipperBase.SlopesEqual(b, f, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== f.WindDelta && (e = this.AddOutPt(f, b.Bot), this.AddJoin(c, e, b.Top));\n      }b = b.NextInAEL;\n    }\n  };d.Clipper.prototype.DoMaxima = function (a) {\n    var b = this.GetMaximaPair(a);if (null === b) 0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a);else {\n      for (var c = a.NextInAEL; null !== c && c != b;) {\n        this.IntersectEdges(a, c, a.Top, !0), this.SwapPositionsInAEL(a, c), c = a.NextInAEL;\n      }-1 == a.OutIdx && -1 == b.OutIdx ? (this.DeleteFromAEL(a), this.DeleteFromAEL(b)) : 0 <= a.OutIdx && 0 <= b.OutIdx ? this.IntersectEdges(a, b, a.Top, !1) : 0 === a.WindDelta ? (0 <= a.OutIdx && (this.AddOutPt(a, a.Top), a.OutIdx = -1), this.DeleteFromAEL(a), 0 <= b.OutIdx && (this.AddOutPt(b, a.Top), b.OutIdx = -1), this.DeleteFromAEL(b)) : d.Error("DoMaxima error");\n    }\n  };d.Clipper.ReversePaths = function (a) {\n    for (var b = 0, c = a.length; b < c; b++) {\n      a[b].reverse();\n    }\n  };d.Clipper.Orientation = function (a) {\n    return 0 <= d.Clipper.Area(a);\n  };d.Clipper.prototype.PointCount = function (a) {\n    if (null === a) return 0;var b = 0,\n        c = a;do {\n      b++, c = c.Next;\n    } while (c != a);return b;\n  };d.Clipper.prototype.BuildResult = function (a) {\n    d.Clear(a);for (var b = 0, c = this.m_PolyOuts.length; b < c; b++) {\n      var e = this.m_PolyOuts[b];if (null !== e.Pts) {\n        var e = e.Pts.Prev,\n            f = this.PointCount(e);if (!(2 > f)) {\n          for (var g = Array(f), h = 0; h < f; h++) {\n            g[h] = e.Pt, e = e.Prev;\n          }a.push(g);\n        }\n      }\n    }\n  };d.Clipper.prototype.BuildResult2 = function (a) {\n    a.Clear();for (var b = 0, c = this.m_PolyOuts.length; b < c; b++) {\n      var e = this.m_PolyOuts[b],\n          f = this.PointCount(e.Pts);if (!(e.IsOpen && 2 > f || !e.IsOpen && 3 > f)) {\n        this.FixHoleLinkage(e);var g = new d.PolyNode();a.m_AllPolys.push(g);e.PolyNode = g;g.m_polygon.length = f;for (var e = e.Pts.Prev, h = 0; h < f; h++) {\n          g.m_polygon[h] = e.Pt, e = e.Prev;\n        }\n      }\n    }b = 0;for (c = this.m_PolyOuts.length; b < c; b++) {\n      e = this.m_PolyOuts[b], null !== e.PolyNode && (e.IsOpen ? (e.PolyNode.IsOpen = !0, a.AddChild(e.PolyNode)) : null !== e.FirstLeft && null != e.FirstLeft.PolyNode ? e.FirstLeft.PolyNode.AddChild(e.PolyNode) : a.AddChild(e.PolyNode));\n    }\n  };d.Clipper.prototype.FixupOutPolygon = function (a) {\n    var b = null;a.BottomPt = null;for (var c = a.Pts;;) {\n      if (c.Prev == c || c.Prev == c.Next) {\n        this.DisposeOutPts(c);a.Pts = null;return;\n      }if (d.IntPoint.op_Equality(c.Pt, c.Next.Pt) || d.IntPoint.op_Equality(c.Pt, c.Prev.Pt) || d.ClipperBase.SlopesEqual(c.Prev.Pt, c.Pt, c.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(c.Prev.Pt, c.Pt, c.Next.Pt))) b = null, c.Prev.Next = c.Next, c = c.Next.Prev = c.Prev;else if (c == b) break;else null === b && (b = c), c = c.Next;\n    }a.Pts = c;\n  };d.Clipper.prototype.DupOutPt = function (a, b) {\n    var c = new d.OutPt();c.Pt.X = a.Pt.X;c.Pt.Y = a.Pt.Y;c.Idx = a.Idx;b ? (c.Next = a.Next, c.Prev = a, a.Next.Prev = c, a.Next = c) : (c.Prev = a.Prev, c.Next = a, a.Prev.Next = c, a.Prev = c);return c;\n  };d.Clipper.prototype.GetOverlap = function (a, b, c, e, d) {\n    a < b ? c < e ? (d.Left = Math.max(a, c), d.Right = Math.min(b, e)) : (d.Left = Math.max(a, e), d.Right = Math.min(b, c)) : c < e ? (d.Left = Math.max(b, c), d.Right = Math.min(a, e)) : (d.Left = Math.max(b, e), d.Right = Math.min(a, c));return d.Left < d.Right;\n  };d.Clipper.prototype.JoinHorz = function (a, b, c, e, f, g) {\n    var h = a.Pt.X > b.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;e = c.Pt.X > e.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;if (h == e) return !1;if (h == d.Direction.dLeftToRight) {\n      for (; a.Next.Pt.X <= f.X && a.Next.Pt.X >= a.Pt.X && a.Next.Pt.Y == f.Y;) {\n        a = a.Next;\n      }g && a.Pt.X != f.X && (a = a.Next);b = this.DupOutPt(a, !g);d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, b = this.DupOutPt(a, !g));\n    } else {\n      for (; a.Next.Pt.X >= f.X && a.Next.Pt.X <= a.Pt.X && a.Next.Pt.Y == f.Y;) {\n        a = a.Next;\n      }g || a.Pt.X == f.X || (a = a.Next);b = this.DupOutPt(a, g);d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, b = this.DupOutPt(a, g));\n    }if (e == d.Direction.dLeftToRight) {\n      for (; c.Next.Pt.X <= f.X && c.Next.Pt.X >= c.Pt.X && c.Next.Pt.Y == f.Y;) {\n        c = c.Next;\n      }g && c.Pt.X != f.X && (c = c.Next);\n      e = this.DupOutPt(c, !g);d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, e = this.DupOutPt(c, !g));\n    } else {\n      for (; c.Next.Pt.X >= f.X && c.Next.Pt.X <= c.Pt.X && c.Next.Pt.Y == f.Y;) {\n        c = c.Next;\n      }g || c.Pt.X == f.X || (c = c.Next);e = this.DupOutPt(c, g);d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, e = this.DupOutPt(c, g));\n    }h == d.Direction.dLeftToRight == g ? (a.Prev = c, c.Next = a, b.Next = e, e.Prev = b) : (a.Next = c, c.Prev = a, b.Prev = e, e.Next = b);return !0;\n  };d.Clipper.prototype.JoinPoints = function (a, b, c) {\n    var e = a.OutPt1,\n        f = new d.OutPt(),\n        g = a.OutPt2,\n        h = new d.OutPt();if ((h = a.OutPt1.Pt.Y == a.OffPt.Y) && d.IntPoint.op_Equality(a.OffPt, a.OutPt1.Pt) && d.IntPoint.op_Equality(a.OffPt, a.OutPt2.Pt)) {\n      for (f = a.OutPt1.Next; f != e && d.IntPoint.op_Equality(f.Pt, a.OffPt);) {\n        f = f.Next;\n      }f = f.Pt.Y > a.OffPt.Y;for (h = a.OutPt2.Next; h != g && d.IntPoint.op_Equality(h.Pt, a.OffPt);) {\n        h = h.Next;\n      }if (f == h.Pt.Y > a.OffPt.Y) return !1;f ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);a.OutPt1 = e;a.OutPt2 = f;return !0;\n    }if (h) {\n      for (f = e; e.Prev.Pt.Y == e.Pt.Y && e.Prev != f && e.Prev != g;) {\n        e = e.Prev;\n      }for (; f.Next.Pt.Y == f.Pt.Y && f.Next != e && f.Next != g;) {\n        f = f.Next;\n      }if (f.Next == e || f.Next == g) return !1;for (h = g; g.Prev.Pt.Y == g.Pt.Y && g.Prev != h && g.Prev != f;) {\n        g = g.Prev;\n      }for (; h.Next.Pt.Y == h.Pt.Y && h.Next != g && h.Next != e;) {\n        h = h.Next;\n      }if (h.Next == g || h.Next == e) return !1;c = { Left: null, Right: null };if (!this.GetOverlap(e.Pt.X, f.Pt.X, g.Pt.X, h.Pt.X, c)) return !1;b = c.Left;var l = c.Right;c = new d.IntPoint();e.Pt.X >= b && e.Pt.X <= l ? (c.X = e.Pt.X, c.Y = e.Pt.Y, b = e.Pt.X > f.Pt.X) : g.Pt.X >= b && g.Pt.X <= l ? (c.X = g.Pt.X, c.Y = g.Pt.Y, b = g.Pt.X > h.Pt.X) : f.Pt.X >= b && f.Pt.X <= l ? (c.X = f.Pt.X, c.Y = f.Pt.Y, b = f.Pt.X > e.Pt.X) : (c.X = h.Pt.X, c.Y = h.Pt.Y, b = h.Pt.X > g.Pt.X);a.OutPt1 = e;a.OutPt2 = g;return this.JoinHorz(e, f, g, h, c, b);\n    }for (f = e.Next; d.IntPoint.op_Equality(f.Pt, e.Pt) && f != e;) {\n      f = f.Next;\n    }if (l = f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) {\n      for (f = e.Prev; d.IntPoint.op_Equality(f.Pt, e.Pt) && f != e;) {\n        f = f.Prev;\n      }if (f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) return !1;\n    }for (h = g.Next; d.IntPoint.op_Equality(h.Pt, g.Pt) && h != g;) {\n      h = h.Next;\n    }var k = h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange);if (k) {\n      for (h = g.Prev; d.IntPoint.op_Equality(h.Pt, g.Pt) && h != g;) {\n        h = h.Prev;\n      }if (h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange)) return !1;\n    }if (f == e || h == g || f == h || b == c && l == k) return !1;l ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);a.OutPt1 = e;a.OutPt2 = f;return !0;\n  };d.Clipper.GetBounds = function (a) {\n    for (var b = 0, c = a.length; b < c && 0 == a[b].length;) {\n      b++;\n    }if (b == c) return new d.IntRect(0, 0, 0, 0);var e = new d.IntRect();e.left = a[b][0].X;e.right = e.left;e.top = a[b][0].Y;for (e.bottom = e.top; b < c; b++) {\n      for (var f = 0, g = a[b].length; f < g; f++) {\n        a[b][f].X < e.left ? e.left = a[b][f].X : a[b][f].X > e.right && (e.right = a[b][f].X), a[b][f].Y < e.top ? e.top = a[b][f].Y : a[b][f].Y > e.bottom && (e.bottom = a[b][f].Y);\n      }\n    }return e;\n  };d.Clipper.prototype.GetBounds2 = function (a) {\n    var b = a,\n        c = new d.IntRect();c.left = a.Pt.X;c.right = a.Pt.X;c.top = a.Pt.Y;c.bottom = a.Pt.Y;for (a = a.Next; a != b;) {\n      a.Pt.X < c.left && (c.left = a.Pt.X), a.Pt.X > c.right && (c.right = a.Pt.X), a.Pt.Y < c.top && (c.top = a.Pt.Y), a.Pt.Y > c.bottom && (c.bottom = a.Pt.Y), a = a.Next;\n    }return c;\n  };d.Clipper.PointInPolygon = function (a, b) {\n    var c = 0,\n        e = b.length;if (3 > e) return 0;for (var d = b[0], g = 1; g <= e; ++g) {\n      var h = g == e ? b[0] : b[g];if (h.Y == a.Y && (h.X == a.X || d.Y == a.Y && h.X > a.X == d.X < a.X)) return -1;if (d.Y < a.Y != h.Y < a.Y) if (d.X >= a.X) {\n        if (h.X > a.X) c = 1 - c;else {\n          var l = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);if (0 == l) return -1;0 < l == h.Y > d.Y && (c = 1 - c);\n        }\n      } else if (h.X > a.X) {\n        l = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);if (0 == l) return -1;0 < l == h.Y > d.Y && (c = 1 - c);\n      }d = h;\n    }return c;\n  };d.Clipper.prototype.PointInPolygon = function (a, b) {\n    for (var c = 0, e = b;;) {\n      var d = b.Pt.X,\n          g = b.Pt.Y,\n          h = b.Next.Pt.X,\n          l = b.Next.Pt.Y;if (l == a.Y && (h == a.X || g == a.Y && h > a.X == d < a.X)) return -1;if (g < a.Y != l < a.Y) if (d >= a.X) {\n        if (h > a.X) c = 1 - c;else {\n          d = (d - a.X) * (l - a.Y) - (h - a.X) * (g - a.Y);if (0 == d) return -1;0 < d == l > g && (c = 1 - c);\n        }\n      } else if (h > a.X) {\n        d = (d - a.X) * (l - a.Y) - (h - a.X) * (g - a.Y);if (0 == d) return -1;0 < d == l > g && (c = 1 - c);\n      }b = b.Next;if (e == b) break;\n    }return c;\n  };d.Clipper.prototype.Poly2ContainsPoly1 = function (a, b) {\n    var c = a;do {\n      var e = this.PointInPolygon(c.Pt, b);if (0 <= e) return 0 != e;c = c.Next;\n    } while (c != a);return !0;\n  };d.Clipper.prototype.FixupFirstLefts1 = function (a, b) {\n    for (var c = 0, e = this.m_PolyOuts.length; c < e; c++) {\n      var d = this.m_PolyOuts[c];null !== d.Pts && d.FirstLeft == a && this.Poly2ContainsPoly1(d.Pts, b.Pts) && (d.FirstLeft = b);\n    }\n  };d.Clipper.prototype.FixupFirstLefts2 = function (a, b) {\n    for (var c = 0, e = this.m_PolyOuts, d = e.length, g = e[c]; c < d; c++, g = e[c]) {\n      g.FirstLeft == a && (g.FirstLeft = b);\n    }\n  };d.Clipper.ParseFirstLeft = function (a) {\n    for (; null != a && null == a.Pts;) {\n      a = a.FirstLeft;\n    }return a;\n  };d.Clipper.prototype.JoinCommonEdges = function () {\n    for (var a = 0, b = this.m_Joins.length; a < b; a++) {\n      var c = this.m_Joins[a],\n          e = this.GetOutRec(c.OutPt1.Idx),\n          f = this.GetOutRec(c.OutPt2.Idx);if (null != e.Pts && null != f.Pts) {\n        var g;g = e == f ? e : this.Param1RightOfParam2(e, f) ? f : this.Param1RightOfParam2(f, e) ? e : this.GetLowermostRec(e, f);if (this.JoinPoints(c, e, f)) if (e == f) {\n          e.Pts = c.OutPt1;e.BottomPt = null;f = this.CreateOutRec();f.Pts = c.OutPt2;this.UpdateOutPtIdxs(f);if (this.m_UsingPolyTree) {\n            g = 0;for (var h = this.m_PolyOuts.length; g < h - 1; g++) {\n              var l = this.m_PolyOuts[g];null != l.Pts && d.Clipper.ParseFirstLeft(l.FirstLeft) == e && l.IsHole != e.IsHole && this.Poly2ContainsPoly1(l.Pts, c.OutPt2) && (l.FirstLeft = f);\n            }\n          }this.Poly2ContainsPoly1(f.Pts, e.Pts) ? (f.IsHole = !e.IsHole, f.FirstLeft = e, this.m_UsingPolyTree && this.FixupFirstLefts2(f, e), (f.IsHole ^ this.ReverseSolution) == 0 < this.Area(f) && this.ReversePolyPtLinks(f.Pts)) : this.Poly2ContainsPoly1(e.Pts, f.Pts) ? (f.IsHole = e.IsHole, e.IsHole = !f.IsHole, f.FirstLeft = e.FirstLeft, e.FirstLeft = f, this.m_UsingPolyTree && this.FixupFirstLefts2(e, f), (e.IsHole ^ this.ReverseSolution) == 0 < this.Area(e) && this.ReversePolyPtLinks(e.Pts)) : (f.IsHole = e.IsHole, f.FirstLeft = e.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(e, f));\n        } else f.Pts = null, f.BottomPt = null, f.Idx = e.Idx, e.IsHole = g.IsHole, g == f && (e.FirstLeft = f.FirstLeft), f.FirstLeft = e, this.m_UsingPolyTree && this.FixupFirstLefts2(f, e);\n      }\n    }\n  };d.Clipper.prototype.UpdateOutPtIdxs = function (a) {\n    var b = a.Pts;do {\n      b.Idx = a.Idx, b = b.Prev;\n    } while (b != a.Pts);\n  };d.Clipper.prototype.DoSimplePolygons = function () {\n    for (var a = 0; a < this.m_PolyOuts.length;) {\n      var b = this.m_PolyOuts[a++],\n          c = b.Pts;if (null !== c) {\n        do {\n          for (var e = c.Next; e != b.Pts;) {\n            if (d.IntPoint.op_Equality(c.Pt, e.Pt) && e.Next != c && e.Prev != c) {\n              var f = c.Prev,\n                  g = e.Prev;c.Prev = g;g.Next = c;e.Prev = f;f.Next = e;b.Pts = c;f = this.CreateOutRec();f.Pts = e;this.UpdateOutPtIdxs(f);this.Poly2ContainsPoly1(f.Pts, b.Pts) ? (f.IsHole = !b.IsHole, f.FirstLeft = b) : this.Poly2ContainsPoly1(b.Pts, f.Pts) ? (f.IsHole = b.IsHole, b.IsHole = !f.IsHole, f.FirstLeft = b.FirstLeft, b.FirstLeft = f) : (f.IsHole = b.IsHole, f.FirstLeft = b.FirstLeft);e = c;\n            }e = e.Next;\n          }c = c.Next;\n        } while (c != b.Pts);\n      }\n    }\n  };d.Clipper.Area = function (a) {\n    var b = a.length;if (3 > b) return 0;for (var c = 0, e = 0, d = b - 1; e < b; ++e) {\n      c += (a[d].X + a[e].X) * (a[d].Y - a[e].Y), d = e;\n    }return 0.5 * -c;\n  };d.Clipper.prototype.Area = function (a) {\n    var b = a.Pts;if (null == b) return 0;var c = 0;do {\n      c += (b.Prev.Pt.X + b.Pt.X) * (b.Prev.Pt.Y - b.Pt.Y), b = b.Next;\n    } while (b != a.Pts);\n    return 0.5 * c;\n  };d.Clipper.SimplifyPolygon = function (a, b) {\n    var c = [],\n        e = new d.Clipper(0);e.StrictlySimple = !0;e.AddPath(a, d.PolyType.ptSubject, !0);e.Execute(d.ClipType.ctUnion, c, b, b);return c;\n  };d.Clipper.SimplifyPolygons = function (a, b) {\n    "undefined" == typeof b && (b = d.PolyFillType.pftEvenOdd);var c = [],\n        e = new d.Clipper(0);e.StrictlySimple = !0;e.AddPaths(a, d.PolyType.ptSubject, !0);e.Execute(d.ClipType.ctUnion, c, b, b);return c;\n  };d.Clipper.DistanceSqrd = function (a, b) {\n    var c = a.X - b.X,\n        e = a.Y - b.Y;return c * c + e * e;\n  };d.Clipper.DistanceFromLineSqrd = function (a, b, c) {\n    var e = b.Y - c.Y;c = c.X - b.X;b = e * b.X + c * b.Y;b = e * a.X + c * a.Y - b;return b * b / (e * e + c * c);\n  };d.Clipper.SlopesNearCollinear = function (a, b, c, e) {\n    return d.Clipper.DistanceFromLineSqrd(b, a, c) < e;\n  };d.Clipper.PointsAreClose = function (a, b, c) {\n    var e = a.X - b.X;a = a.Y - b.Y;return e * e + a * a <= c;\n  };d.Clipper.ExcludeOp = function (a) {\n    var b = a.Prev;b.Next = a.Next;a.Next.Prev = b;b.Idx = 0;return b;\n  };d.Clipper.CleanPolygon = function (a, b) {\n    "undefined" == typeof b && (b = 1.415);var c = a.length;if (0 == c) return [];for (var e = Array(c), f = 0; f < c; ++f) {\n      e[f] = new d.OutPt();\n    }for (f = 0; f < c; ++f) {\n      e[f].Pt = a[f], e[f].Next = e[(f + 1) % c], e[f].Next.Prev = e[f], e[f].Idx = 0;\n    }f = b * b;for (e = e[0]; 0 == e.Idx && e.Next != e.Prev;) {\n      d.Clipper.PointsAreClose(e.Pt, e.Prev.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : d.Clipper.PointsAreClose(e.Prev.Pt, e.Next.Pt, f) ? (d.Clipper.ExcludeOp(e.Next), e = d.Clipper.ExcludeOp(e), c -= 2) : d.Clipper.SlopesNearCollinear(e.Prev.Pt, e.Pt, e.Next.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : (e.Idx = 1, e = e.Next);\n    }3 > c && (c = 0);for (var g = Array(c), f = 0; f < c; ++f) {\n      g[f] = new d.IntPoint(e.Pt), e = e.Next;\n    }return g;\n  };d.Clipper.CleanPolygons = function (a, b) {\n    for (var c = Array(a.length), e = 0, f = a.length; e < f; e++) {\n      c[e] = d.Clipper.CleanPolygon(a[e], b);\n    }return c;\n  };d.Clipper.Minkowski = function (a, b, c, e) {\n    var f = e ? 1 : 0,\n        g = a.length,\n        h = b.length;e = [];if (c) for (c = 0; c < h; c++) {\n      for (var l = Array(g), k = 0, n = a.length, m = a[k]; k < n; k++, m = a[k]) {\n        l[k] = new d.IntPoint(b[c].X + m.X, b[c].Y + m.Y);\n      }e.push(l);\n    } else for (c = 0; c < h; c++) {\n      l = Array(g);k = 0;n = a.length;for (m = a[k]; k < n; k++, m = a[k]) {\n        l[k] = new d.IntPoint(b[c].X - m.X, b[c].Y - m.Y);\n      }e.push(l);\n    }a = [];for (c = 0; c < h - 1 + f; c++) {\n      for (k = 0; k < g; k++) {\n        b = [], b.push(e[c % h][k % g]), b.push(e[(c + 1) % h][k % g]), b.push(e[(c + 1) % h][(k + 1) % g]), b.push(e[c % h][(k + 1) % g]), d.Clipper.Orientation(b) || b.reverse(), a.push(b);\n      }\n    }f = new d.Clipper(0);f.AddPaths(a, d.PolyType.ptSubject, !0);f.Execute(d.ClipType.ctUnion, e, d.PolyFillType.pftNonZero, d.PolyFillType.pftNonZero);return e;\n  };d.Clipper.MinkowskiSum = function () {\n    var a = arguments,\n        b = a.length;if (3 == b) {\n      var c = a[0],\n          e = a[2];return d.Clipper.Minkowski(c, a[1], !0, e);\n    }if (4 == b) {\n      for (var c = a[0], f = a[1], b = a[2], e = a[3], a = new d.Clipper(), g, h = 0, l = f.length; h < l; ++h) {\n        g = d.Clipper.Minkowski(c, f[h], !0, e), a.AddPaths(g, d.PolyType.ptSubject, !0);\n      }e && a.AddPaths(f, d.PolyType.ptClip, !0);c = new d.Paths();a.Execute(d.ClipType.ctUnion, c, b, b);return c;\n    }\n  };d.Clipper.MinkowskiDiff = function (a, b, c) {\n    return d.Clipper.Minkowski(a, b, !1, c);\n  };d.Clipper.PolyTreeToPaths = function (a) {\n    var b = [];d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntAny, b);return b;\n  };d.Clipper.AddPolyNodeToPaths = function (a, b, c) {\n    var e = !0;switch (b) {case d.Clipper.NodeType.ntOpen:\n        return;case d.Clipper.NodeType.ntClosed:\n        e = !a.IsOpen;}0 < a.m_polygon.length && e && c.push(a.m_polygon);e = 0;a = a.Childs();for (var f = a.length, g = a[e]; e < f; e++, g = a[e]) {\n      d.Clipper.AddPolyNodeToPaths(g, b, c);\n    }\n  };d.Clipper.OpenPathsFromPolyTree = function (a) {\n    for (var b = new d.Paths(), c = 0, e = a.ChildCount(); c < e; c++) {\n      a.Childs()[c].IsOpen && b.push(a.Childs()[c].m_polygon);\n    }return b;\n  };d.Clipper.ClosedPathsFromPolyTree = function (a) {\n    var b = new d.Paths();d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntClosed, b);return b;\n  };K(d.Clipper, d.ClipperBase);d.Clipper.NodeType = { ntAny: 0, ntOpen: 1,\n    ntClosed: 2 };d.ClipperOffset = function (a, b) {\n    "undefined" == typeof a && (a = 2);"undefined" == typeof b && (b = d.ClipperOffset.def_arc_tolerance);this.m_destPolys = new d.Paths();this.m_srcPoly = new d.Path();this.m_destPoly = new d.Path();this.m_normals = [];this.m_StepsPerRad = this.m_miterLim = this.m_cos = this.m_sin = this.m_sinA = this.m_delta = 0;this.m_lowest = new d.IntPoint();this.m_polyNodes = new d.PolyNode();this.MiterLimit = a;this.ArcTolerance = b;this.m_lowest.X = -1;\n  };d.ClipperOffset.two_pi = 6.28318530717959;d.ClipperOffset.def_arc_tolerance = 0.25;d.ClipperOffset.prototype.Clear = function () {\n    d.Clear(this.m_polyNodes.Childs());this.m_lowest.X = -1;\n  };d.ClipperOffset.Round = d.Clipper.Round;d.ClipperOffset.prototype.AddPath = function (a, b, c) {\n    var e = a.length - 1;if (!(0 > e)) {\n      var f = new d.PolyNode();f.m_jointype = b;f.m_endtype = c;if (c == d.EndType.etClosedLine || c == d.EndType.etClosedPolygon) for (; 0 < e && d.IntPoint.op_Equality(a[0], a[e]);) {\n        e--;\n      }f.m_polygon.push(a[0]);var g = 0;b = 0;for (var h = 1; h <= e; h++) {\n        d.IntPoint.op_Inequality(f.m_polygon[g], a[h]) && (g++, f.m_polygon.push(a[h]), a[h].Y > f.m_polygon[b].Y || a[h].Y == f.m_polygon[b].Y && a[h].X < f.m_polygon[b].X) && (b = g);\n      }if (!(c == d.EndType.etClosedPolygon && 2 > g || c != d.EndType.etClosedPolygon && 0 > g) && (this.m_polyNodes.AddChild(f), c == d.EndType.etClosedPolygon)) if (0 > this.m_lowest.X) this.m_lowest = new d.IntPoint(0, b);else if (a = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y], f.m_polygon[b].Y > a.Y || f.m_polygon[b].Y == a.Y && f.m_polygon[b].X < a.X) this.m_lowest = new d.IntPoint(this.m_polyNodes.ChildCount() - 1, b);\n    }\n  };d.ClipperOffset.prototype.AddPaths = function (a, b, c) {\n    for (var e = 0, d = a.length; e < d; e++) {\n      this.AddPath(a[e], b, c);\n    }\n  };d.ClipperOffset.prototype.FixOrientations = function () {\n    if (0 <= this.m_lowest.X && !d.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for (var a = 0; a < this.m_polyNodes.ChildCount(); a++) {\n      var b = this.m_polyNodes.Childs()[a];(b.m_endtype == d.EndType.etClosedPolygon || b.m_endtype == d.EndType.etClosedLine && d.Clipper.Orientation(b.m_polygon)) && b.m_polygon.reverse();\n    } else for (a = 0; a < this.m_polyNodes.ChildCount(); a++) {\n      b = this.m_polyNodes.Childs()[a], b.m_endtype != d.EndType.etClosedLine || d.Clipper.Orientation(b.m_polygon) || b.m_polygon.reverse();\n    }\n  };d.ClipperOffset.GetUnitNormal = function (a, b) {\n    var c = b.X - a.X,\n        e = b.Y - a.Y;if (0 == c && 0 == e) return new d.DoublePoint(0, 0);var f = 1 / Math.sqrt(c * c + e * e);return new d.DoublePoint(e * f, -(c * f));\n  };d.ClipperOffset.prototype.DoOffset = function (a) {\n    this.m_destPolys = [];this.m_delta = a;if (d.ClipperBase.near_zero(a)) for (var b = 0; b < this.m_polyNodes.ChildCount(); b++) {\n      var c = this.m_polyNodes.Childs()[b];c.m_endtype == d.EndType.etClosedPolygon && this.m_destPolys.push(c.m_polygon);\n    } else {\n      this.m_miterLim = 2 < this.MiterLimit ? 2 / (this.MiterLimit * this.MiterLimit) : 0.5;var b = 0 >= this.ArcTolerance ? d.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(a) * d.ClipperOffset.def_arc_tolerance ? Math.abs(a) * d.ClipperOffset.def_arc_tolerance : this.ArcTolerance,\n          e = 3.14159265358979 / Math.acos(1 - b / Math.abs(a));this.m_sin = Math.sin(d.ClipperOffset.two_pi / e);this.m_cos = Math.cos(d.ClipperOffset.two_pi / e);this.m_StepsPerRad = e / d.ClipperOffset.two_pi;0 > a && (this.m_sin = -this.m_sin);for (b = 0; b < this.m_polyNodes.ChildCount(); b++) {\n        c = this.m_polyNodes.Childs()[b];this.m_srcPoly = c.m_polygon;var f = this.m_srcPoly.length;if (!(0 == f || 0 >= a && (3 > f || c.m_endtype != d.EndType.etClosedPolygon))) {\n          this.m_destPoly = [];if (1 == f) {\n            if (c.m_jointype == d.JoinType.jtRound) for (var c = 1, f = 0, g = 1; g <= e; g++) {\n              this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + c * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + f * a)));var h = c,\n                  c = c * this.m_cos - this.m_sin * f,\n                  f = h * this.m_sin + f * this.m_cos;\n            } else for (f = c = -1, g = 0; 4 > g; ++g) {\n              this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + c * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + f * a))), 0 > c ? c = 1 : 0 > f ? f = 1 : c = -1;\n            }\n          } else {\n            for (g = this.m_normals.length = 0; g < f - 1; g++) {\n              this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[g], this.m_srcPoly[g + 1]));\n            }c.m_endtype == d.EndType.etClosedLine || c.m_endtype == d.EndType.etClosedPolygon ? this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[f - 1], this.m_srcPoly[0])) : this.m_normals.push(new d.DoublePoint(this.m_normals[f - 2]));if (c.m_endtype == d.EndType.etClosedPolygon) for (h = f - 1, g = 0; g < f; g++) {\n              h = this.OffsetPoint(g, h, c.m_jointype);\n            } else if (c.m_endtype == d.EndType.etClosedLine) {\n              h = f - 1;for (g = 0; g < f; g++) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }this.m_destPolys.push(this.m_destPoly);this.m_destPoly = [];h = this.m_normals[f - 1];for (g = f - 1; 0 < g; g--) {\n                this.m_normals[g] = new d.DoublePoint(-this.m_normals[g - 1].X, -this.m_normals[g - 1].Y);\n              }this.m_normals[0] = new d.DoublePoint(-h.X, -h.Y);h = 0;for (g = f - 1; 0 <= g; g--) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }\n            } else {\n              h = 0;for (g = 1; g < f - 1; ++g) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }c.m_endtype == d.EndType.etOpenButt ? (g = f - 1, h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X + this.m_normals[g].X * a), d.ClipperOffset.Round(this.m_srcPoly[g].Y + this.m_normals[g].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X - this.m_normals[g].X * a), d.ClipperOffset.Round(this.m_srcPoly[g].Y - this.m_normals[g].Y * a)), this.m_destPoly.push(h)) : (g = f - 1, h = f - 2, this.m_sinA = 0, this.m_normals[g] = new d.DoublePoint(-this.m_normals[g].X, -this.m_normals[g].Y), c.m_endtype == d.EndType.etOpenSquare ? this.DoSquare(g, h) : this.DoRound(g, h));for (g = f - 1; 0 < g; g--) {\n                this.m_normals[g] = new d.DoublePoint(-this.m_normals[g - 1].X, -this.m_normals[g - 1].Y);\n              }this.m_normals[0] = new d.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);h = f - 1;for (g = h - 1; 0 < g; --g) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }c.m_endtype == d.EndType.etOpenButt ? (h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * a)), this.m_destPoly.push(h)) : (this.m_sinA = 0, c.m_endtype == d.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1));\n            }\n          }this.m_destPolys.push(this.m_destPoly);\n        }\n      }\n    }\n  };d.ClipperOffset.prototype.Execute = function () {\n    var a = arguments;if (a[0] instanceof d.PolyTree) {\n      if (b = a[0], c = a[1], b.Clear(), this.FixOrientations(), this.DoOffset(c), a = new d.Clipper(0), a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0), 0 < c) a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive);else if (c = d.Clipper.GetBounds(this.m_destPolys), e = new d.Path(), e.push(new d.IntPoint(c.left - 10, c.bottom + 10)), e.push(new d.IntPoint(c.right + 10, c.bottom + 10)), e.push(new d.IntPoint(c.right + 10, c.top - 10)), e.push(new d.IntPoint(c.left - 10, c.top - 10)), a.AddPath(e, d.PolyType.ptSubject, !0), a.ReverseSolution = !0, a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative), 1 == b.ChildCount() && 0 < b.Childs()[0].ChildCount()) for (a = b.Childs()[0], b.Childs()[0] = a.Childs()[0], c = 1; c < a.ChildCount(); c++) {\n        b.AddChild(a.Childs()[c]);\n      } else b.Clear();\n    } else {\n      var b = a[0],\n          c = a[1];d.Clear(b);this.FixOrientations();this.DoOffset(c);a = new d.Clipper(0);a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0);if (0 < c) a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive);else {\n        var c = d.Clipper.GetBounds(this.m_destPolys),\n            e = new d.Path();e.push(new d.IntPoint(c.left - 10, c.bottom + 10));e.push(new d.IntPoint(c.right + 10, c.bottom + 10));e.push(new d.IntPoint(c.right + 10, c.top - 10));e.push(new d.IntPoint(c.left - 10, c.top - 10));a.AddPath(e, d.PolyType.ptSubject, !0);a.ReverseSolution = !0;a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative);0 < b.length && b.splice(0, 1);\n      }\n    }\n  };d.ClipperOffset.prototype.OffsetPoint = function (a, b, c) {\n    this.m_sinA = this.m_normals[b].X * this.m_normals[a].Y - this.m_normals[a].X * this.m_normals[b].Y;if (5E-5 > this.m_sinA && -5E-5 < this.m_sinA) return b;\n    1 < this.m_sinA ? this.m_sinA = 1 : -1 > this.m_sinA && (this.m_sinA = -1);if (0 > this.m_sinA * this.m_delta) this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[b].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[b].Y * this.m_delta))), this.m_destPoly.push(new d.IntPoint(this.m_srcPoly[a])), this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));else switch (c) {case d.JoinType.jtMiter:\n        c = 1 + (this.m_normals[a].X * this.m_normals[b].X + this.m_normals[a].Y * this.m_normals[b].Y);c >= this.m_miterLim ? this.DoMiter(a, b, c) : this.DoSquare(a, b);break;case d.JoinType.jtSquare:\n        this.DoSquare(a, b);break;case d.JoinType.jtRound:\n        this.DoRound(a, b);}return a;\n  };d.ClipperOffset.prototype.DoSquare = function (a, b) {\n    var c = Math.tan(Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y) / 4);this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[b].X - this.m_normals[b].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[b].Y + this.m_normals[b].X * c))));this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[a].X + this.m_normals[a].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[a].Y - this.m_normals[a].X * c))));\n  };d.ClipperOffset.prototype.DoMiter = function (a, b, c) {\n    c = this.m_delta / c;this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + (this.m_normals[b].X + this.m_normals[a].X) * c), d.ClipperOffset.Round(this.m_srcPoly[a].Y + (this.m_normals[b].Y + this.m_normals[a].Y) * c)));\n  };d.ClipperOffset.prototype.DoRound = function (a, b) {\n    for (var c = Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y), c = d.Cast_Int32(d.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(c))), e = this.m_normals[b].X, f = this.m_normals[b].Y, g, h = 0; h < c; ++h) {\n      this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + e * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + f * this.m_delta))), g = e, e = e * this.m_cos - this.m_sin * f, f = g * this.m_sin + f * this.m_cos;\n    }this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));\n  };d.Error = function (a) {\n    try {\n      throw Error(a);\n    } catch (b) {\n      alert(b.message);\n    }\n  };d.JS = {};d.JS.AreaOfPolygon = function (a, b) {\n    b || (b = 1);return d.Clipper.Area(a) / (b * b);\n  };d.JS.AreaOfPolygons = function (a, b) {\n    b || (b = 1);for (var c = 0, e = 0; e < a.length; e++) {\n      c += d.Clipper.Area(a[e]);\n    }return c / (b * b);\n  };d.JS.BoundsOfPath = function (a, b) {\n    return d.JS.BoundsOfPaths([a], b);\n  };d.JS.BoundsOfPaths = function (a, b) {\n    b || (b = 1);var c = d.Clipper.GetBounds(a);c.left /= b;c.bottom /= b;c.right /= b;c.top /= b;return c;\n  };d.JS.Clean = function (a, b) {\n    if (!(a instanceof Array)) return [];var c = a[0] instanceof Array;a = d.JS.Clone(a);if ("number" != typeof b || null === b) return d.Error("Delta is not a number in Clean()."), a;if (0 === a.length || 1 == a.length && 0 === a[0].length || 0 > b) return a;c || (a = [a]);for (var e = a.length, f, g, h, l, k, n, m, p = [], q = 0; q < e; q++) {\n      if (g = a[q], f = g.length, 0 !== f) if (3 > f) h = g, p.push(h);else {\n        h = g;l = b * b;k = g[0];for (m = n = 1; m < f; m++) {\n          (g[m].X - k.X) * (g[m].X - k.X) + (g[m].Y - k.Y) * (g[m].Y - k.Y) <= l || (h[n] = g[m], k = g[m], n++);\n        }k = g[n - 1];(g[0].X - k.X) * (g[0].X - k.X) + (g[0].Y - k.Y) * (g[0].Y - k.Y) <= l && n--;n < f && h.splice(n, f - n);h.length && p.push(h);\n      }\n    }!c && p.length ? p = p[0] : c || 0 !== p.length ? c && 0 === p.length && (p = [[]]) : p = [];return p;\n  };d.JS.Clone = function (a) {\n    if (!(a instanceof Array) || 0 === a.length) return [];if (1 == a.length && 0 === a[0].length) return [[]];var b = a[0] instanceof Array;b || (a = [a]);var c = a.length,\n        e,\n        d,\n        g,\n        h,\n        l = Array(c);for (d = 0; d < c; d++) {\n      e = a[d].length;h = Array(e);for (g = 0; g < e; g++) {\n        h[g] = { X: a[d][g].X, Y: a[d][g].Y };\n      }l[d] = h;\n    }b || (l = l[0]);return l;\n  };d.JS.Lighten = function (a, b) {\n    if (!(a instanceof Array)) return [];if ("number" != typeof b || null === b) return d.Error("Tolerance is not a number in Lighten()."), d.JS.Clone(a);if (0 === a.length || 1 == a.length && 0 === a[0].length || 0 > b) return d.JS.Clone(a);a[0] instanceof Array || (a = [a]);var c,\n        e,\n        f,\n        g,\n        h,\n        l,\n        k,\n        m,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u,\n        v,\n        x = a.length,\n        y = b * b,\n        w = [];for (c = 0; c < x; c++) {\n      if (f = a[c], l = f.length, 0 != l) {\n        for (g = 0; 1E6 > g; g++) {\n          h = [];l = f.length;f[l - 1].X != f[0].X || f[l - 1].Y != f[0].Y ? (r = 1, f.push({ X: f[0].X, Y: f[0].Y }), l = f.length) : r = 0;q = [];for (e = 0; e < l - 2; e++) {\n            k = f[e];p = f[e + 1];m = f[e + 2];u = k.X;v = k.Y;k = m.X - u;s = m.Y - v;if (0 !== k || 0 !== s) t = ((p.X - u) * k + (p.Y - v) * s) / (k * k + s * s), 1 < t ? (u = m.X, v = m.Y) : 0 < t && (u += k * t, v += s * t);k = p.X - u;s = p.Y - v;m = k * k + s * s;m <= y && (q[e + 1] = 1, e++);\n          }h.push({ X: f[0].X, Y: f[0].Y });for (e = 1; e < l - 1; e++) {\n            q[e] || h.push({ X: f[e].X, Y: f[e].Y });\n          }h.push({ X: f[l - 1].X, Y: f[l - 1].Y });r && f.pop();if (q.length) f = h;else break;\n        }l = h.length;h[l - 1].X == h[0].X && h[l - 1].Y == h[0].Y && h.pop();2 < h.length && w.push(h);\n      }\n    }!a[0] instanceof Array && (w = w[0]);"undefined" == typeof w && (w = [[]]);return w;\n  };d.JS.PerimeterOfPath = function (a, b, c) {\n    if ("undefined" == typeof a) return 0;var e = Math.sqrt,\n        d = 0,\n        g,\n        h,\n        k = 0,\n        m = g = 0;h = 0;var n = a.length;if (2 > n) return 0;b && (a[n] = a[0], n++);for (; --n;) {\n      g = a[n], k = g.X, g = g.Y, h = a[n - 1], m = h.X, h = h.Y, d += e((k - m) * (k - m) + (g - h) * (g - h));\n    }b && a.pop();return d / c;\n  };d.JS.PerimeterOfPaths = function (a, b, c) {\n    c || (c = 1);for (var e = 0, f = 0; f < a.length; f++) {\n      e += d.JS.PerimeterOfPath(a[f], b, c);\n    }return e;\n  };d.JS.ScaleDownPath = function (a, b) {\n    var c, d;b || (b = 1);for (c = a.length; c--;) {\n      d = a[c], d.X /= b, d.Y /= b;\n    }\n  };d.JS.ScaleDownPaths = function (a, b) {\n    var c, d, f;b || (b = 1);for (c = a.length; c--;) {\n      for (d = a[c].length; d--;) {\n        f = a[c][d], f.X /= b, f.Y /= b;\n      }\n    }\n  };d.JS.ScaleUpPath = function (a, b) {\n    var c,\n        d,\n        f = Math.round;b || (b = 1);for (c = a.length; c--;) {\n      d = a[c], d.X = f(d.X * b), d.Y = f(d.Y * b);\n    }\n  };d.JS.ScaleUpPaths = function (a, b) {\n    var c,\n        d,\n        f,\n        g = Math.round;b || (b = 1);for (c = a.length; c--;) {\n      for (d = a[c].length; d--;) {\n        f = a[c][d], f.X = g(f.X * b), f.Y = g(f.Y * b);\n      }\n    }\n  };d.ExPolygons = function () {\n    return [];\n  };d.ExPolygon = function () {\n    this.holes = this.outer = null;\n  };d.JS.AddOuterPolyNodeToExPolygons = function (a, b) {\n    var c = new d.ExPolygon();c.outer = a.Contour();var e = a.Childs(),\n        f = e.length;c.holes = Array(f);var g, h, k, m, n;for (h = 0; h < f; h++) {\n      for (g = e[h], c.holes[h] = g.Contour(), k = 0, m = g.Childs(), n = m.length; k < n; k++) {\n        g = m[k], d.JS.AddOuterPolyNodeToExPolygons(g, b);\n      }\n    }b.push(c);\n  };d.JS.ExPolygonsToPaths = function (a) {\n    var b,\n        c,\n        e,\n        f,\n        g = new d.Paths();b = 0;for (e = a.length; b < e; b++) {\n      for (g.push(a[b].outer), c = 0, f = a[b].holes.length; c < f; c++) {\n        g.push(a[b].holes[c]);\n      }\n    }return g;\n  };d.JS.PolyTreeToExPolygons = function (a) {\n    var b = new d.ExPolygons(),\n        c,\n        e,\n        f;c = 0;e = a.Childs();for (f = e.length; c < f; c++) {\n      a = e[c], d.JS.AddOuterPolyNodeToExPolygons(a, b);\n    }return b;\n  };\n})();'},697:function(t,n){t.exports="'use strict';\n\n/*!\n * General purpose geometry functions for polygon/Bezier calculations\n * Copyright 2015 Jack Qiao\n * Licensed under the MIT license\n */\n\n(function (root) {\n\t'use strict';\n\n\t// private shared variables/methods\n\n\t// floating point comparison tolerance\n\n\tvar TOL = Math.pow(10, -9); // Floating point error is likely to be above 1 epsilon\n\n\tfunction _almostEqual(a, b, tolerance) {\n\t\tif (!tolerance) {\n\t\t\ttolerance = TOL;\n\t\t}\n\t\treturn Math.abs(a - b) < tolerance;\n\t}\n\n\t// returns true if points are within the given distance\n\tfunction _withinDistance(p1, p2, distance) {\n\t\tvar dx = p1.x - p2.x;\n\t\tvar dy = p1.y - p2.y;\n\t\treturn dx * dx + dy * dy < distance * distance;\n\t}\n\n\tfunction _degreesToRadians(angle) {\n\t\treturn angle * (Math.PI / 180);\n\t}\n\n\tfunction _radiansToDegrees(angle) {\n\t\treturn angle * (180 / Math.PI);\n\t}\n\n\t// normalize vector into a unit vector\n\tfunction _normalizeVector(v) {\n\t\tif (_almostEqual(v.x * v.x + v.y * v.y, 1)) {\n\t\t\treturn v; // given vector was already a unit vector\n\t\t}\n\t\tvar len = Math.sqrt(v.x * v.x + v.y * v.y);\n\t\tvar inverse = 1 / len;\n\n\t\treturn {\n\t\t\tx: v.x * inverse,\n\t\t\ty: v.y * inverse\n\t\t};\n\t}\n\n\t// returns true if p lies on the line segment defined by AB, but not at any endpoints\n\t// may need work!\n\tfunction _onSegment(A, B, p) {\n\n\t\t// vertical line\n\t\tif (_almostEqual(A.x, B.x) && _almostEqual(p.x, A.x)) {\n\t\t\tif (!_almostEqual(p.y, B.y) && !_almostEqual(p.y, A.y) && p.y < Math.max(B.y, A.y) && p.y > Math.min(B.y, A.y)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// horizontal line\n\t\tif (_almostEqual(A.y, B.y) && _almostEqual(p.y, A.y)) {\n\t\t\tif (!_almostEqual(p.x, B.x) && !_almostEqual(p.x, A.x) && p.x < Math.max(B.x, A.x) && p.x > Math.min(B.x, A.x)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t//range check\n\t\tif (p.x < A.x && p.x < B.x || p.x > A.x && p.x > B.x || p.y < A.y && p.y < B.y || p.y > A.y && p.y > B.y) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// exclude end points\n\t\tif (_almostEqual(p.x, A.x) && _almostEqual(p.y, A.y) || _almostEqual(p.x, B.x) && _almostEqual(p.y, B.y)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar cross = (p.y - A.y) * (B.x - A.x) - (p.x - A.x) * (B.y - A.y);\n\n\t\tif (Math.abs(cross) > TOL) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar dot = (p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y);\n\n\t\tif (dot < 0 || _almostEqual(dot, 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\n\t\tif (dot > len2 || _almostEqual(dot, len2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// returns the intersection of AB and EF\n\t// or null if there are no intersections or other numerical error\n\t// if the infinite flag is set, AE and EF describe infinite lines without endpoints, they are finite line segments otherwise\n\tfunction _lineIntersect(A, B, E, F, infinite) {\n\t\tvar a1, a2, b1, b2, c1, c2, x, y;\n\n\t\ta1 = B.y - A.y;\n\t\tb1 = A.x - B.x;\n\t\tc1 = B.x * A.y - A.x * B.y;\n\t\ta2 = F.y - E.y;\n\t\tb2 = E.x - F.x;\n\t\tc2 = F.x * E.y - E.x * F.y;\n\n\t\tvar denom = a1 * b2 - a2 * b1;\n\n\t\tx = (b1 * c2 - b2 * c1) / denom, y = (a2 * c1 - a1 * c2) / denom;\n\n\t\tif (!isFinite(x) || !isFinite(y)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// lines are colinear\n\t\t/*var crossABE = (E.y - A.y) * (B.x - A.x) - (E.x - A.x) * (B.y - A.y);\n  var crossABF = (F.y - A.y) * (B.x - A.x) - (F.x - A.x) * (B.y - A.y);\n  if(_almostEqual(crossABE,0) && _almostEqual(crossABF,0)){\n  \treturn null;\n  }*/\n\n\t\tif (!infinite) {\n\t\t\t// coincident points do not count as intersecting\n\t\t\tif (Math.abs(A.x - B.x) > TOL && (A.x < B.x ? x < A.x || x > B.x : x > A.x || x < B.x)) return null;\n\t\t\tif (Math.abs(A.y - B.y) > TOL && (A.y < B.y ? y < A.y || y > B.y : y > A.y || y < B.y)) return null;\n\n\t\t\tif (Math.abs(E.x - F.x) > TOL && (E.x < F.x ? x < E.x || x > F.x : x > E.x || x < F.x)) return null;\n\t\t\tif (Math.abs(E.y - F.y) > TOL && (E.y < F.y ? y < E.y || y > F.y : y > E.y || y < F.y)) return null;\n\t\t}\n\n\t\treturn { x: x, y: y };\n\t}\n\n\t// public methods\n\troot.GeometryUtil = {\n\n\t\twithinDistance: _withinDistance,\n\n\t\tlineIntersect: _lineIntersect,\n\n\t\talmostEqual: _almostEqual,\n\n\t\t// Bezier algos from http://algorithmist.net/docs/subdivision.pdf\n\t\tQuadraticBezier: {\n\n\t\t\t// Roger Willcocks bezier flatness criterion\n\t\t\tisFlat: function isFlat(p1, p2, c1, tol) {\n\t\t\t\ttol = 4 * tol * tol;\n\n\t\t\t\tvar ux = 2 * c1.x - p1.x - p2.x;\n\t\t\t\tux *= ux;\n\n\t\t\t\tvar uy = 2 * c1.y - p1.y - p2.y;\n\t\t\t\tuy *= uy;\n\n\t\t\t\treturn ux + uy <= tol;\n\t\t\t},\n\n\t\t\t// turn Bezier into line segments via de Casteljau, returns an array of points\n\t\t\tlinearize: function linearize(p1, p2, c1, tol) {\n\t\t\t\tvar finished = [p1]; // list of points to return\n\t\t\t\tvar todo = [{ p1: p1, p2: p2, c1: c1 }]; // list of Beziers to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tvar segment = todo[0];\n\n\t\t\t\t\tif (this.isFlat(segment.p1, segment.p2, segment.c1, tol)) {\n\t\t\t\t\t\t// reached subdivision limit\n\t\t\t\t\t\tfinished.push({ x: segment.p2.x, y: segment.p2.y });\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar divided = this.subdivide(segment.p1, segment.p2, segment.c1, 0.5);\n\t\t\t\t\t\ttodo.splice(0, 1, divided[0], divided[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\t// subdivide a single Bezier\n\t\t\t// t is the percent along the Bezier to divide at. eg. 0.5\n\t\t\tsubdivide: function subdivide(p1, p2, c1, t) {\n\t\t\t\tvar mid1 = {\n\t\t\t\t\tx: p1.x + (c1.x - p1.x) * t,\n\t\t\t\t\ty: p1.y + (c1.y - p1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid2 = {\n\t\t\t\t\tx: c1.x + (p2.x - c1.x) * t,\n\t\t\t\t\ty: c1.y + (p2.y - c1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid3 = {\n\t\t\t\t\tx: mid1.x + (mid2.x - mid1.x) * t,\n\t\t\t\t\ty: mid1.y + (mid2.y - mid1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar seg1 = { p1: p1, p2: mid3, c1: mid1 };\n\t\t\t\tvar seg2 = { p1: mid3, p2: p2, c1: mid2 };\n\n\t\t\t\treturn [seg1, seg2];\n\t\t\t}\n\t\t},\n\n\t\tCubicBezier: {\n\t\t\tisFlat: function isFlat(p1, p2, c1, c2, tol) {\n\t\t\t\ttol = 16 * tol * tol;\n\n\t\t\t\tvar ux = 3 * c1.x - 2 * p1.x - p2.x;\n\t\t\t\tux *= ux;\n\n\t\t\t\tvar uy = 3 * c1.y - 2 * p1.y - p2.y;\n\t\t\t\tuy *= uy;\n\n\t\t\t\tvar vx = 3 * c2.x - 2 * p2.x - p1.x;\n\t\t\t\tvx *= vx;\n\n\t\t\t\tvar vy = 3 * c2.y - 2 * p2.y - p1.y;\n\t\t\t\tvy *= vy;\n\n\t\t\t\tif (ux < vx) {\n\t\t\t\t\tux = vx;\n\t\t\t\t}\n\t\t\t\tif (uy < vy) {\n\t\t\t\t\tuy = vy;\n\t\t\t\t}\n\n\t\t\t\treturn ux + uy <= tol;\n\t\t\t},\n\n\t\t\tlinearize: function linearize(p1, p2, c1, c2, tol) {\n\t\t\t\tvar finished = [p1]; // list of points to return\n\t\t\t\tvar todo = [{ p1: p1, p2: p2, c1: c1, c2: c2 }]; // list of Beziers to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tvar segment = todo[0];\n\n\t\t\t\t\tif (this.isFlat(segment.p1, segment.p2, segment.c1, segment.c2, tol)) {\n\t\t\t\t\t\t// reached subdivision limit\n\t\t\t\t\t\tfinished.push({ x: segment.p2.x, y: segment.p2.y });\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar divided = this.subdivide(segment.p1, segment.p2, segment.c1, segment.c2, 0.5);\n\t\t\t\t\t\ttodo.splice(0, 1, divided[0], divided[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\tsubdivide: function subdivide(p1, p2, c1, c2, t) {\n\t\t\t\tvar mid1 = {\n\t\t\t\t\tx: p1.x + (c1.x - p1.x) * t,\n\t\t\t\t\ty: p1.y + (c1.y - p1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid2 = {\n\t\t\t\t\tx: c2.x + (p2.x - c2.x) * t,\n\t\t\t\t\ty: c2.y + (p2.y - c2.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid3 = {\n\t\t\t\t\tx: c1.x + (c2.x - c1.x) * t,\n\t\t\t\t\ty: c1.y + (c2.y - c1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mida = {\n\t\t\t\t\tx: mid1.x + (mid3.x - mid1.x) * t,\n\t\t\t\t\ty: mid1.y + (mid3.y - mid1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar midb = {\n\t\t\t\t\tx: mid3.x + (mid2.x - mid3.x) * t,\n\t\t\t\t\ty: mid3.y + (mid2.y - mid3.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar midx = {\n\t\t\t\t\tx: mida.x + (midb.x - mida.x) * t,\n\t\t\t\t\ty: mida.y + (midb.y - mida.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar seg1 = { p1: p1, p2: midx, c1: mid1, c2: mida };\n\t\t\t\tvar seg2 = { p1: midx, p2: p2, c1: midb, c2: mid2 };\n\n\t\t\t\treturn [seg1, seg2];\n\t\t\t}\n\t\t},\n\n\t\tArc: {\n\n\t\t\tlinearize: function linearize(p1, p2, rx, ry, angle, largearc, sweep, tol) {\n\n\t\t\t\tvar finished = [p2]; // list of points to return\n\n\t\t\t\tvar arc = this.svgToCenter(p1, p2, rx, ry, angle, largearc, sweep);\n\t\t\t\tvar todo = [arc]; // list of arcs to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tarc = todo[0];\n\n\t\t\t\t\tvar fullarc = this.centerToSvg(arc.center, arc.rx, arc.ry, arc.theta, arc.extent, arc.angle);\n\t\t\t\t\tvar subarc = this.centerToSvg(arc.center, arc.rx, arc.ry, arc.theta, 0.5 * arc.extent, arc.angle);\n\t\t\t\t\tvar arcmid = subarc.p2;\n\n\t\t\t\t\tvar mid = {\n\t\t\t\t\t\tx: 0.5 * (fullarc.p1.x + fullarc.p2.x),\n\t\t\t\t\t\ty: 0.5 * (fullarc.p1.y + fullarc.p2.y)\n\n\t\t\t\t\t\t// compare midpoint of line with midpoint of arc\n\t\t\t\t\t\t// this is not 100% accurate, but should be a good heuristic for flatness in most cases\n\t\t\t\t\t};if (_withinDistance(mid, arcmid, tol)) {\n\t\t\t\t\t\tfinished.unshift(fullarc.p2);\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar arc1 = {\n\t\t\t\t\t\t\tcenter: arc.center,\n\t\t\t\t\t\t\trx: arc.rx,\n\t\t\t\t\t\t\try: arc.ry,\n\t\t\t\t\t\t\ttheta: arc.theta,\n\t\t\t\t\t\t\textent: 0.5 * arc.extent,\n\t\t\t\t\t\t\tangle: arc.angle\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar arc2 = {\n\t\t\t\t\t\t\tcenter: arc.center,\n\t\t\t\t\t\t\trx: arc.rx,\n\t\t\t\t\t\t\try: arc.ry,\n\t\t\t\t\t\t\ttheta: arc.theta + 0.5 * arc.extent,\n\t\t\t\t\t\t\textent: 0.5 * arc.extent,\n\t\t\t\t\t\t\tangle: arc.angle\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttodo.splice(0, 1, arc1, arc2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\t// convert from center point/angle sweep definition to SVG point and flag definition of arcs\n\t\t\t// ported from http://commons.oreilly.com/wiki/index.php/SVG_Essentials/Paths\n\t\t\tcenterToSvg: function centerToSvg(center, rx, ry, theta1, extent, angleDegrees) {\n\n\t\t\t\tvar theta2 = theta1 + extent;\n\n\t\t\t\ttheta1 = _degreesToRadians(theta1);\n\t\t\t\ttheta2 = _degreesToRadians(theta2);\n\t\t\t\tvar angle = _degreesToRadians(angleDegrees);\n\n\t\t\t\tvar cos = Math.cos(angle);\n\t\t\t\tvar sin = Math.sin(angle);\n\n\t\t\t\tvar t1cos = Math.cos(theta1);\n\t\t\t\tvar t1sin = Math.sin(theta1);\n\n\t\t\t\tvar t2cos = Math.cos(theta2);\n\t\t\t\tvar t2sin = Math.sin(theta2);\n\n\t\t\t\tvar x0 = center.x + cos * rx * t1cos + -sin * ry * t1sin;\n\t\t\t\tvar y0 = center.y + sin * rx * t1cos + cos * ry * t1sin;\n\n\t\t\t\tvar x1 = center.x + cos * rx * t2cos + -sin * ry * t2sin;\n\t\t\t\tvar y1 = center.y + sin * rx * t2cos + cos * ry * t2sin;\n\n\t\t\t\tvar largearc = extent > 180 ? 1 : 0;\n\t\t\t\tvar sweep = extent > 0 ? 1 : 0;\n\n\t\t\t\treturn {\n\t\t\t\t\tp1: { x: x0, y: y0 },\n\t\t\t\t\tp2: { x: x1, y: y1 },\n\t\t\t\t\trx: rx,\n\t\t\t\t\try: ry,\n\t\t\t\t\tangle: angle,\n\t\t\t\t\tlargearc: largearc,\n\t\t\t\t\tsweep: sweep\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t// convert from SVG format arc to center point arc\n\t\t\tsvgToCenter: function svgToCenter(p1, p2, rx, ry, angleDegrees, largearc, sweep) {\n\n\t\t\t\tvar mid = {\n\t\t\t\t\tx: 0.5 * (p1.x + p2.x),\n\t\t\t\t\ty: 0.5 * (p1.y + p2.y)\n\t\t\t\t};\n\n\t\t\t\tvar diff = {\n\t\t\t\t\tx: 0.5 * (p2.x - p1.x),\n\t\t\t\t\ty: 0.5 * (p2.y - p1.y)\n\t\t\t\t};\n\n\t\t\t\tvar angle = _degreesToRadians(angleDegrees % 360);\n\n\t\t\t\tvar cos = Math.cos(angle);\n\t\t\t\tvar sin = Math.sin(angle);\n\n\t\t\t\tvar x1 = cos * diff.x + sin * diff.y;\n\t\t\t\tvar y1 = -sin * diff.x + cos * diff.y;\n\n\t\t\t\trx = Math.abs(rx);\n\t\t\t\try = Math.abs(ry);\n\t\t\t\tvar Prx = rx * rx;\n\t\t\t\tvar Pry = ry * ry;\n\t\t\t\tvar Px1 = x1 * x1;\n\t\t\t\tvar Py1 = y1 * y1;\n\n\t\t\t\tvar radiiCheck = Px1 / Prx + Py1 / Pry;\n\t\t\t\tvar radiiSqrt = Math.sqrt(radiiCheck);\n\t\t\t\tif (radiiCheck > 1) {\n\t\t\t\t\trx = radiiSqrt * rx;\n\t\t\t\t\try = radiiSqrt * ry;\n\t\t\t\t\tPrx = rx * rx;\n\t\t\t\t\tPry = ry * ry;\n\t\t\t\t}\n\n\t\t\t\tvar sign = largearc != sweep ? -1 : 1;\n\t\t\t\tvar sq = (Prx * Pry - Prx * Py1 - Pry * Px1) / (Prx * Py1 + Pry * Px1);\n\n\t\t\t\tsq = sq < 0 ? 0 : sq;\n\n\t\t\t\tvar coef = sign * Math.sqrt(sq);\n\t\t\t\tvar cx1 = coef * (rx * y1 / ry);\n\t\t\t\tvar cy1 = coef * -(ry * x1 / rx);\n\n\t\t\t\tvar cx = mid.x + (cos * cx1 - sin * cy1);\n\t\t\t\tvar cy = mid.y + (sin * cx1 + cos * cy1);\n\n\t\t\t\tvar ux = (x1 - cx1) / rx;\n\t\t\t\tvar uy = (y1 - cy1) / ry;\n\t\t\t\tvar vx = (-x1 - cx1) / rx;\n\t\t\t\tvar vy = (-y1 - cy1) / ry;\n\t\t\t\tvar n = Math.sqrt(ux * ux + uy * uy);\n\t\t\t\tvar p = ux;\n\t\t\t\tsign = uy < 0 ? -1 : 1;\n\n\t\t\t\tvar theta = sign * Math.acos(p / n);\n\t\t\t\ttheta = _radiansToDegrees(theta);\n\n\t\t\t\tn = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\n\t\t\t\tp = ux * vx + uy * vy;\n\t\t\t\tsign = ux * vy - uy * vx < 0 ? -1 : 1;\n\t\t\t\tvar delta = sign * Math.acos(p / n);\n\t\t\t\tdelta = _radiansToDegrees(delta);\n\n\t\t\t\tif (sweep == 1 && delta > 0) {\n\t\t\t\t\tdelta -= 360;\n\t\t\t\t} else if (sweep == 0 && delta < 0) {\n\t\t\t\t\tdelta += 360;\n\t\t\t\t}\n\n\t\t\t\tdelta %= 360;\n\t\t\t\ttheta %= 360;\n\n\t\t\t\treturn {\n\t\t\t\t\tcenter: { x: cx, y: cy },\n\t\t\t\t\trx: rx,\n\t\t\t\t\try: ry,\n\t\t\t\t\ttheta: theta,\n\t\t\t\t\textent: delta,\n\t\t\t\t\tangle: angleDegrees\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\n\t\t// returns the rectangular bounding box of the given polygon\n\t\tgetPolygonBounds: function getPolygonBounds(polygon) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar xmin = polygon[0].x;\n\t\t\tvar xmax = polygon[0].x;\n\t\t\tvar ymin = polygon[0].y;\n\t\t\tvar ymax = polygon[0].y;\n\n\t\t\tfor (var i = 1; i < polygon.length; i++) {\n\t\t\t\tif (polygon[i].x > xmax) {\n\t\t\t\t\txmax = polygon[i].x;\n\t\t\t\t} else if (polygon[i].x < xmin) {\n\t\t\t\t\txmin = polygon[i].x;\n\t\t\t\t}\n\n\t\t\t\tif (polygon[i].y > ymax) {\n\t\t\t\t\tymax = polygon[i].y;\n\t\t\t\t} else if (polygon[i].y < ymin) {\n\t\t\t\t\tymin = polygon[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: xmin,\n\t\t\t\ty: ymin,\n\t\t\t\twidth: xmax - xmin,\n\t\t\t\theight: ymax - ymin\n\t\t\t};\n\t\t},\n\n\t\t// return true if point is in the polygon, false if outside, and null if exactly on a point or edge\n\t\tpointInPolygon: function pointInPolygon(point, polygon) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar inside = false;\n\t\t\tvar offsetx = polygon.offsetx || 0;\n\t\t\tvar offsety = polygon.offsety || 0;\n\n\t\t\tfor (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n\t\t\t\tvar xi = polygon[i].x + offsetx;\n\t\t\t\tvar yi = polygon[i].y + offsety;\n\t\t\t\tvar xj = polygon[j].x + offsetx;\n\t\t\t\tvar yj = polygon[j].y + offsety;\n\n\t\t\t\tif (_almostEqual(xi, point.x) && _almostEqual(yi, point.y)) {\n\t\t\t\t\treturn null; // no result\n\t\t\t\t}\n\n\t\t\t\tif (_onSegment({ x: xi, y: yi }, { x: xj, y: yj }, point)) {\n\t\t\t\t\treturn null; // exactly on the segment\n\t\t\t\t}\n\n\t\t\t\tif (_almostEqual(xi, xj) && _almostEqual(yi, yj)) {\n\t\t\t\t\t// ignore very small lines\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;\n\t\t\t\tif (intersect) inside = !inside;\n\t\t\t}\n\n\t\t\treturn inside;\n\t\t},\n\n\t\t// returns the area of the polygon, assuming no self-intersections\n\t\t// a negative area indicates counter-clockwise winding direction\n\t\tpolygonArea: function polygonArea(polygon) {\n\t\t\tvar area = 0;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n\t\t\t\tarea += (polygon[j].x + polygon[i].x) * (polygon[j].y - polygon[i].y);\n\t\t\t}\n\t\t\treturn 0.5 * area;\n\t\t},\n\n\t\t// todo: swap this for a more efficient sweep-line implementation\n\t\t// returnEdges: if set, return all edges on A that have intersections\n\n\t\tintersect: function intersect(A, B) {\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\tfor (var i = 0; i < A.length - 1; i++) {\n\t\t\t\tfor (var j = 0; j < B.length - 1; j++) {\n\t\t\t\t\tvar a1 = { x: A[i].x + Aoffsetx, y: A[i].y + Aoffsety };\n\t\t\t\t\tvar a2 = { x: A[i + 1].x + Aoffsetx, y: A[i + 1].y + Aoffsety };\n\t\t\t\t\tvar b1 = { x: B[j].x + Boffsetx, y: B[j].y + Boffsety };\n\t\t\t\t\tvar b2 = { x: B[j + 1].x + Boffsetx, y: B[j + 1].y + Boffsety };\n\n\t\t\t\t\tvar prevbindex = j == 0 ? B.length - 1 : j - 1;\n\t\t\t\t\tvar prevaindex = i == 0 ? A.length - 1 : i - 1;\n\t\t\t\t\tvar nextbindex = j + 1 == B.length - 1 ? 0 : j + 2;\n\t\t\t\t\tvar nextaindex = i + 1 == A.length - 1 ? 0 : i + 2;\n\n\t\t\t\t\t// go even further back if we happen to hit on a loop end point\n\t\t\t\t\tif (B[prevbindex] == B[j] || _almostEqual(B[prevbindex].x, B[j].x) && _almostEqual(B[prevbindex].y, B[j].y)) {\n\t\t\t\t\t\tprevbindex = prevbindex == 0 ? B.length - 1 : prevbindex - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (A[prevaindex] == A[i] || _almostEqual(A[prevaindex].x, A[i].x) && _almostEqual(A[prevaindex].y, A[i].y)) {\n\t\t\t\t\t\tprevaindex = prevaindex == 0 ? A.length - 1 : prevaindex - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// go even further forward if we happen to hit on a loop end point\n\t\t\t\t\tif (B[nextbindex] == B[j + 1] || _almostEqual(B[nextbindex].x, B[j + 1].x) && _almostEqual(B[nextbindex].y, B[j + 1].y)) {\n\t\t\t\t\t\tnextbindex = nextbindex == B.length - 1 ? 0 : nextbindex + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (A[nextaindex] == A[i + 1] || _almostEqual(A[nextaindex].x, A[i + 1].x) && _almostEqual(A[nextaindex].y, A[i + 1].y)) {\n\t\t\t\t\t\tnextaindex = nextaindex == A.length - 1 ? 0 : nextaindex + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar a0 = { x: A[prevaindex].x + Aoffsetx, y: A[prevaindex].y + Aoffsety };\n\t\t\t\t\tvar b0 = { x: B[prevbindex].x + Boffsetx, y: B[prevbindex].y + Boffsety };\n\n\t\t\t\t\tvar a3 = { x: A[nextaindex].x + Aoffsetx, y: A[nextaindex].y + Aoffsety };\n\t\t\t\t\tvar b3 = { x: B[nextbindex].x + Boffsetx, y: B[nextbindex].y + Boffsety };\n\n\t\t\t\t\tif (_onSegment(a1, a2, b1) || _almostEqual(a1.x, b1.x) && _almostEqual(a1.y, b1.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar b0in = this.pointInPolygon(b0, A);\n\t\t\t\t\t\tvar b2in = this.pointInPolygon(b2, A);\n\t\t\t\t\t\tif (b0in === true && b2in === false || b0in === false && b2in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(a1, a2, b2) || _almostEqual(a2.x, b2.x) && _almostEqual(a2.y, b2.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar b1in = this.pointInPolygon(b1, A);\n\t\t\t\t\t\tvar b3in = this.pointInPolygon(b3, A);\n\n\t\t\t\t\t\tif (b1in === true && b3in === false || b1in === false && b3in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(b1, b2, a1) || _almostEqual(a1.x, b2.x) && _almostEqual(a1.y, b2.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar a0in = this.pointInPolygon(a0, B);\n\t\t\t\t\t\tvar a2in = this.pointInPolygon(a2, B);\n\n\t\t\t\t\t\tif (a0in === true && a2in === false || a0in === false && a2in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(b1, b2, a2) || _almostEqual(a2.x, b1.x) && _almostEqual(a2.y, b1.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar a1in = this.pointInPolygon(a1, B);\n\t\t\t\t\t\tvar a3in = this.pointInPolygon(a3, B);\n\n\t\t\t\t\t\tif (a1in === true && a3in === false || a1in === false && a3in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar p = _lineIntersect(b1, b2, a1, a2);\n\n\t\t\t\t\tif (p !== null) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// placement algos as outlined in [1] http://www.cs.stir.ac.uk/~goc/papers/EffectiveHueristic2DAOR2013.pdf\n\n\t\t// returns a continuous polyline representing the normal-most edge of the given polygon\n\t\t// eg. a normal vector of [-1, 0] will return the left-most edge of the polygon\n\t\t// this is essentially algo 8 in [1], generalized for any vector direction\n\t\tpolygonEdge: function polygonEdge(polygon, normal) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar direction = {\n\t\t\t\tx: -normal.y,\n\t\t\t\ty: normal.x\n\t\t\t};\n\n\t\t\t// find the max and min points, they will be the endpoints of our edge\n\t\t\tvar min = null;\n\t\t\tvar max = null;\n\n\t\t\tvar dotproduct = [];\n\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tvar dot = polygon[i].x * direction.x + polygon[i].y * direction.y;\n\t\t\t\tdotproduct.push(dot);\n\t\t\t\tif (min === null || dot < min) {\n\t\t\t\t\tmin = dot;\n\t\t\t\t}\n\t\t\t\tif (max === null || dot > max) {\n\t\t\t\t\tmax = dot;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// there may be multiple vertices with min/max values. In which case we choose the one that is normal-most (eg. left most)\n\t\t\tvar indexmin = 0;\n\t\t\tvar indexmax = 0;\n\n\t\t\tvar normalmin = null;\n\t\t\tvar normalmax = null;\n\n\t\t\tfor (i = 0; i < polygon.length; i++) {\n\t\t\t\tif (_almostEqual(dotproduct[i], min)) {\n\t\t\t\t\tvar dot = polygon[i].x * normal.x + polygon[i].y * normal.y;\n\t\t\t\t\tif (normalmin === null || dot > normalmin) {\n\t\t\t\t\t\tnormalmin = dot;\n\t\t\t\t\t\tindexmin = i;\n\t\t\t\t\t}\n\t\t\t\t} else if (_almostEqual(dotproduct[i], max)) {\n\t\t\t\t\tvar dot = polygon[i].x * normal.x + polygon[i].y * normal.y;\n\t\t\t\t\tif (normalmax === null || dot > normalmax) {\n\t\t\t\t\t\tnormalmax = dot;\n\t\t\t\t\t\tindexmax = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we have two edges bound by min and max points, figure out which edge faces our direction vector\n\n\t\t\tvar indexleft = indexmin - 1;\n\t\t\tvar indexright = indexmin + 1;\n\n\t\t\tif (indexleft < 0) {\n\t\t\t\tindexleft = polygon.length - 1;\n\t\t\t}\n\t\t\tif (indexright >= polygon.length) {\n\t\t\t\tindexright = 0;\n\t\t\t}\n\n\t\t\tvar minvertex = polygon[indexmin];\n\t\t\tvar left = polygon[indexleft];\n\t\t\tvar right = polygon[indexright];\n\n\t\t\tvar leftvector = {\n\t\t\t\tx: left.x - minvertex.x,\n\t\t\t\ty: left.y - minvertex.y\n\t\t\t};\n\n\t\t\tvar rightvector = {\n\t\t\t\tx: right.x - minvertex.x,\n\t\t\t\ty: right.y - minvertex.y\n\t\t\t};\n\n\t\t\tvar dotleft = leftvector.x * direction.x + leftvector.y * direction.y;\n\t\t\tvar dotright = rightvector.x * direction.x + rightvector.y * direction.y;\n\n\t\t\t// -1 = left, 1 = right\n\t\t\tvar scandirection = -1;\n\n\t\t\tif (_almostEqual(dotleft, 0)) {\n\t\t\t\tscandirection = 1;\n\t\t\t} else if (_almostEqual(dotright, 0)) {\n\t\t\t\tscandirection = -1;\n\t\t\t} else {\n\t\t\t\tvar normaldotleft;\n\t\t\t\tvar normaldotright;\n\n\t\t\t\tif (_almostEqual(dotleft, dotright)) {\n\t\t\t\t\t// the points line up exactly along the normal vector\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y;\n\t\t\t\t\tnormaldotright = rightvector.x * normal.x + rightvector.y * normal.y;\n\t\t\t\t} else if (dotleft < dotright) {\n\t\t\t\t\t// normalize right vertex so normal projection can be directly compared\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y;\n\t\t\t\t\tnormaldotright = (rightvector.x * normal.x + rightvector.y * normal.y) * (dotleft / dotright);\n\t\t\t\t} else {\n\t\t\t\t\t// normalize left vertex so normal projection can be directly compared\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y * (dotright / dotleft);\n\t\t\t\t\tnormaldotright = rightvector.x * normal.x + rightvector.y * normal.y;\n\t\t\t\t}\n\n\t\t\t\tif (normaldotleft > normaldotright) {\n\t\t\t\t\tscandirection = -1;\n\t\t\t\t} else {\n\t\t\t\t\t// technically they could be equal, (ie. the segments bound by left and right points are incident)\n\t\t\t\t\t// in which case we'll have to climb up the chain until lines are no longer incident\n\t\t\t\t\t// for now we'll just not handle it and assume people aren't giving us garbage input..\n\t\t\t\t\tscandirection = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// connect all points between indexmin and indexmax along the scan direction\n\t\t\tvar edge = [];\n\t\t\tvar count = 0;\n\t\t\ti = indexmin;\n\t\t\twhile (count < polygon.length) {\n\t\t\t\tif (i >= polygon.length) {\n\t\t\t\t\ti = 0;\n\t\t\t\t} else if (i < 0) {\n\t\t\t\t\ti = polygon.length - 1;\n\t\t\t\t}\n\n\t\t\t\tedge.push(polygon[i]);\n\n\t\t\t\tif (i == indexmax) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += scandirection;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\treturn edge;\n\t\t},\n\n\t\t// returns the normal distance from p to a line segment defined by s1 s2\n\t\t// this is basically algo 9 in [1], generalized for any vector direction\n\t\t// eg. normal of [-1, 0] returns the horizontal distance between the point and the line segment\n\t\t// sxinclusive: if true, include endpoints instead of excluding them\n\n\t\tpointLineDistance: function pointLineDistance(p, s1, s2, normal, s1inclusive, s2inclusive) {\n\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar dir = {\n\t\t\t\tx: normal.y,\n\t\t\t\ty: -normal.x\n\t\t\t};\n\n\t\t\tvar pdot = p.x * dir.x + p.y * dir.y;\n\t\t\tvar s1dot = s1.x * dir.x + s1.y * dir.y;\n\t\t\tvar s2dot = s2.x * dir.x + s2.y * dir.y;\n\n\t\t\tvar pdotnorm = p.x * normal.x + p.y * normal.y;\n\t\t\tvar s1dotnorm = s1.x * normal.x + s1.y * normal.y;\n\t\t\tvar s2dotnorm = s2.x * normal.x + s2.y * normal.y;\n\n\t\t\t// point is exactly along the edge in the normal direction\n\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot)) {\n\t\t\t\t// point lies on an endpoint\n\t\t\t\tif (_almostEqual(pdotnorm, s1dotnorm)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (_almostEqual(pdotnorm, s2dotnorm)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// point is outside both endpoints\n\t\t\t\tif (pdotnorm > s1dotnorm && pdotnorm > s2dotnorm) {\n\t\t\t\t\treturn Math.min(pdotnorm - s1dotnorm, pdotnorm - s2dotnorm);\n\t\t\t\t}\n\t\t\t\tif (pdotnorm < s1dotnorm && pdotnorm < s2dotnorm) {\n\t\t\t\t\treturn -Math.min(s1dotnorm - pdotnorm, s2dotnorm - pdotnorm);\n\t\t\t\t}\n\n\t\t\t\t// point lies between endpoints\n\t\t\t\tvar diff1 = pdotnorm - s1dotnorm;\n\t\t\t\tvar diff2 = pdotnorm - s2dotnorm;\n\t\t\t\tif (diff1 > 0) {\n\t\t\t\t\treturn diff1;\n\t\t\t\t} else {\n\t\t\t\t\treturn diff2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// point \n\t\t\telse if (_almostEqual(pdot, s1dot)) {\n\t\t\t\t\tif (s1inclusive) {\n\t\t\t\t\t\treturn pdotnorm - s1dotnorm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (_almostEqual(pdot, s2dot)) {\n\t\t\t\t\tif (s2inclusive) {\n\t\t\t\t\t\treturn pdotnorm - s2dotnorm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (pdot < s1dot && pdot < s2dot || pdot > s1dot && pdot > s2dot) {\n\t\t\t\t\treturn null; // point doesn't collide with segment\n\t\t\t\t}\n\n\t\t\treturn pdotnorm - s1dotnorm + (s1dotnorm - s2dotnorm) * (s1dot - pdot) / (s1dot - s2dot);\n\t\t},\n\n\t\tpointDistance: function pointDistance(p, s1, s2, normal, infinite) {\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar dir = {\n\t\t\t\tx: normal.y,\n\t\t\t\ty: -normal.x\n\t\t\t};\n\n\t\t\tvar pdot = p.x * dir.x + p.y * dir.y;\n\t\t\tvar s1dot = s1.x * dir.x + s1.y * dir.y;\n\t\t\tvar s2dot = s2.x * dir.x + s2.y * dir.y;\n\n\t\t\tvar pdotnorm = p.x * normal.x + p.y * normal.y;\n\t\t\tvar s1dotnorm = s1.x * normal.x + s1.y * normal.y;\n\t\t\tvar s2dotnorm = s2.x * normal.x + s2.y * normal.y;\n\n\t\t\tif (!infinite) {\n\t\t\t\tif ((pdot < s1dot || _almostEqual(pdot, s1dot)) && (pdot < s2dot || _almostEqual(pdot, s2dot)) || (pdot > s1dot || _almostEqual(pdot, s1dot)) && (pdot > s2dot || _almostEqual(pdot, s2dot))) {\n\t\t\t\t\treturn null; // dot doesn't collide with segment, or lies directly on the vertex\n\t\t\t\t}\n\t\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot) && pdotnorm > s1dotnorm && pdotnorm > s2dotnorm) {\n\t\t\t\t\treturn Math.min(pdotnorm - s1dotnorm, pdotnorm - s2dotnorm);\n\t\t\t\t}\n\t\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot) && pdotnorm < s1dotnorm && pdotnorm < s2dotnorm) {\n\t\t\t\t\treturn -Math.min(s1dotnorm - pdotnorm, s2dotnorm - pdotnorm);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -(pdotnorm - s1dotnorm + (s1dotnorm - s2dotnorm) * (s1dot - pdot) / (s1dot - s2dot));\n\t\t},\n\n\t\tsegmentDistance: function segmentDistance(A, B, E, F, direction) {\n\t\t\tvar normal = {\n\t\t\t\tx: direction.y,\n\t\t\t\ty: -direction.x\n\t\t\t};\n\n\t\t\tvar reverse = {\n\t\t\t\tx: -direction.x,\n\t\t\t\ty: -direction.y\n\t\t\t};\n\n\t\t\tvar dotA = A.x * normal.x + A.y * normal.y;\n\t\t\tvar dotB = B.x * normal.x + B.y * normal.y;\n\t\t\tvar dotE = E.x * normal.x + E.y * normal.y;\n\t\t\tvar dotF = F.x * normal.x + F.y * normal.y;\n\n\t\t\tvar crossA = A.x * direction.x + A.y * direction.y;\n\t\t\tvar crossB = B.x * direction.x + B.y * direction.y;\n\t\t\tvar crossE = E.x * direction.x + E.y * direction.y;\n\t\t\tvar crossF = F.x * direction.x + F.y * direction.y;\n\n\t\t\tvar crossABmin = Math.min(crossA, crossB);\n\t\t\tvar crossABmax = Math.max(crossA, crossB);\n\n\t\t\tvar crossEFmax = Math.max(crossE, crossF);\n\t\t\tvar crossEFmin = Math.min(crossE, crossF);\n\n\t\t\tvar ABmin = Math.min(dotA, dotB);\n\t\t\tvar ABmax = Math.max(dotA, dotB);\n\n\t\t\tvar EFmax = Math.max(dotE, dotF);\n\t\t\tvar EFmin = Math.min(dotE, dotF);\n\n\t\t\t// segments that will merely touch at one point\n\t\t\tif (_almostEqual(ABmax, EFmin, TOL) || _almostEqual(ABmin, EFmax, TOL)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// segments miss eachother completely\n\t\t\tif (ABmax < EFmin || ABmin > EFmax) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar overlap;\n\n\t\t\tif (ABmax > EFmax && ABmin < EFmin || EFmax > ABmax && EFmin < ABmin) {\n\t\t\t\toverlap = 1;\n\t\t\t} else {\n\t\t\t\tvar minMax = Math.min(ABmax, EFmax);\n\t\t\t\tvar maxMin = Math.max(ABmin, EFmin);\n\n\t\t\t\tvar maxMax = Math.max(ABmax, EFmax);\n\t\t\t\tvar minMin = Math.min(ABmin, EFmin);\n\n\t\t\t\toverlap = (minMax - maxMin) / (maxMax - minMin);\n\t\t\t}\n\n\t\t\tvar crossABE = (E.y - A.y) * (B.x - A.x) - (E.x - A.x) * (B.y - A.y);\n\t\t\tvar crossABF = (F.y - A.y) * (B.x - A.x) - (F.x - A.x) * (B.y - A.y);\n\n\t\t\t// lines are colinear\n\t\t\tif (_almostEqual(crossABE, 0) && _almostEqual(crossABF, 0)) {\n\n\t\t\t\tvar ABnorm = { x: B.y - A.y, y: A.x - B.x };\n\t\t\t\tvar EFnorm = { x: F.y - E.y, y: E.x - F.x };\n\n\t\t\t\tvar ABnormlength = Math.sqrt(ABnorm.x * ABnorm.x + ABnorm.y * ABnorm.y);\n\t\t\t\tABnorm.x /= ABnormlength;\n\t\t\t\tABnorm.y /= ABnormlength;\n\n\t\t\t\tvar EFnormlength = Math.sqrt(EFnorm.x * EFnorm.x + EFnorm.y * EFnorm.y);\n\t\t\t\tEFnorm.x /= EFnormlength;\n\t\t\t\tEFnorm.y /= EFnormlength;\n\n\t\t\t\t// segment normals must point in opposite directions\n\t\t\t\tif (Math.abs(ABnorm.y * EFnorm.x - ABnorm.x * EFnorm.y) < TOL && ABnorm.y * EFnorm.y + ABnorm.x * EFnorm.x < 0) {\n\t\t\t\t\t// normal of AB segment must point in same direction as given direction vector\n\t\t\t\t\tvar normdot = ABnorm.y * direction.y + ABnorm.x * direction.x;\n\t\t\t\t\t// the segments merely slide along eachother\n\t\t\t\t\tif (_almostEqual(normdot, 0, TOL)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tif (normdot < 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar distances = [];\n\n\t\t\t// coincident points\n\t\t\tif (_almostEqual(dotA, dotE)) {\n\t\t\t\tdistances.push(crossA - crossE);\n\t\t\t} else if (_almostEqual(dotA, dotF)) {\n\t\t\t\tdistances.push(crossA - crossF);\n\t\t\t} else if (dotA > EFmin && dotA < EFmax) {\n\t\t\t\tvar d = this.pointDistance(A, E, F, reverse);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t//  A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dB = this.pointDistance(B, E, F, reverse, true);\n\t\t\t\t\tif (dB < 0 || _almostEqual(dB * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_almostEqual(dotB, dotE)) {\n\t\t\t\tdistances.push(crossB - crossE);\n\t\t\t} else if (_almostEqual(dotB, dotF)) {\n\t\t\t\tdistances.push(crossB - crossF);\n\t\t\t} else if (dotB > EFmin && dotB < EFmax) {\n\t\t\t\tvar d = this.pointDistance(B, E, F, reverse);\n\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// crossA>crossB A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dA = this.pointDistance(A, E, F, reverse, true);\n\t\t\t\t\tif (dA < 0 || _almostEqual(dA * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dotE > ABmin && dotE < ABmax) {\n\t\t\t\tvar d = this.pointDistance(E, A, B, direction);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// crossF<crossE A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dF = this.pointDistance(F, A, B, direction, true);\n\t\t\t\t\tif (dF < 0 || _almostEqual(dF * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dotF > ABmin && dotF < ABmax) {\n\t\t\t\tvar d = this.pointDistance(F, A, B, direction);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// && crossE<crossF A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dE = this.pointDistance(E, A, B, direction, true);\n\t\t\t\t\tif (dE < 0 || _almostEqual(dE * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distances.length == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn Math.min.apply(Math, distances);\n\t\t},\n\n\t\tpolygonSlideDistance: function polygonSlideDistance(A, B, direction, ignoreNegative) {\n\n\t\t\tvar A1, A2, B1, B2, Aoffsetx, Aoffsety, Boffsetx, Boffsety;\n\n\t\t\tAoffsetx = A.offsetx || 0;\n\t\t\tAoffsety = A.offsety || 0;\n\n\t\t\tBoffsetx = B.offsetx || 0;\n\t\t\tBoffsety = B.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tvar edgeA = A;\n\t\t\tvar edgeB = B;\n\n\t\t\tvar distance = null;\n\t\t\tvar p, s1, s2, d;\n\n\t\t\tvar dir = _normalizeVector(direction);\n\n\t\t\tvar normal = {\n\t\t\t\tx: dir.y,\n\t\t\t\ty: -dir.x\n\t\t\t};\n\n\t\t\tvar reverse = {\n\t\t\t\tx: -dir.x,\n\t\t\t\ty: -dir.y\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < edgeB.length - 1; i++) {\n\t\t\t\tvar mind = null;\n\t\t\t\tfor (var j = 0; j < edgeA.length - 1; j++) {\n\t\t\t\t\tA1 = { x: edgeA[j].x + Aoffsetx, y: edgeA[j].y + Aoffsety };\n\t\t\t\t\tA2 = { x: edgeA[j + 1].x + Aoffsetx, y: edgeA[j + 1].y + Aoffsety };\n\t\t\t\t\tB1 = { x: edgeB[i].x + Boffsetx, y: edgeB[i].y + Boffsety };\n\t\t\t\t\tB2 = { x: edgeB[i + 1].x + Boffsetx, y: edgeB[i + 1].y + Boffsety };\n\n\t\t\t\t\tif (_almostEqual(A1.x, A2.x) && _almostEqual(A1.y, A2.y) || _almostEqual(B1.x, B2.x) && _almostEqual(B1.y, B2.y)) {\n\t\t\t\t\t\tcontinue; // ignore extremely small lines\n\t\t\t\t\t}\n\n\t\t\t\t\td = this.segmentDistance(A1, A2, B1, B2, dir);\n\n\t\t\t\t\tif (d !== null && (distance === null || d < distance)) {\n\t\t\t\t\t\tif (!ignoreNegative || d > 0 || _almostEqual(d, 0)) {\n\t\t\t\t\t\t\tdistance = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distance;\n\t\t},\n\n\t\t// project each point of B onto A in the given direction, and return the \n\t\tpolygonProjectionDistance: function polygonProjectionDistance(A, B, direction) {\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tvar edgeA = A;\n\t\t\tvar edgeB = B;\n\n\t\t\tvar distance = null;\n\t\t\tvar p, d, s1, s2;\n\n\t\t\tfor (var i = 0; i < edgeB.length; i++) {\n\t\t\t\t// the shortest/most negative projection of B onto A\n\t\t\t\tvar minprojection = null;\n\t\t\t\tvar minp = null;\n\t\t\t\tfor (var j = 0; j < edgeA.length - 1; j++) {\n\t\t\t\t\tp = { x: edgeB[i].x + Boffsetx, y: edgeB[i].y + Boffsety };\n\t\t\t\t\ts1 = { x: edgeA[j].x + Aoffsetx, y: edgeA[j].y + Aoffsety };\n\t\t\t\t\ts2 = { x: edgeA[j + 1].x + Aoffsetx, y: edgeA[j + 1].y + Aoffsety };\n\n\t\t\t\t\tif (Math.abs((s2.y - s1.y) * direction.x - (s2.x - s1.x) * direction.y) < TOL) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// project point, ignore edge boundaries\n\t\t\t\t\td = this.pointDistance(p, s1, s2, direction);\n\n\t\t\t\t\tif (d !== null && (minprojection === null || d < minprojection)) {\n\t\t\t\t\t\tminprojection = d;\n\t\t\t\t\t\tminp = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minprojection !== null && (distance === null || minprojection > distance)) {\n\t\t\t\t\tdistance = minprojection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn distance;\n\t\t},\n\n\t\t// searches for an arrangement of A and B such that they do not overlap\n\t\t// if an NFP is given, only search for startpoints that have not already been traversed in the given NFP\n\t\tsearchStartPoint: function searchStartPoint(A, B, inside, NFP) {\n\t\t\t// clone arrays\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < A.length - 1; i++) {\n\t\t\t\tif (!A[i].marked) {\n\t\t\t\t\tA[i].marked = true;\n\t\t\t\t\tfor (var j = 0; j < B.length; j++) {\n\t\t\t\t\t\tB.offsetx = A[i].x - B[j].x;\n\t\t\t\t\t\tB.offsety = A[i].y - B[j].y;\n\n\t\t\t\t\t\tvar Binside = null;\n\t\t\t\t\t\tfor (var k = 0; k < B.length; k++) {\n\t\t\t\t\t\t\tvar inpoly = this.pointInPolygon({ x: B[k].x + B.offsetx, y: B[k].y + B.offsety }, A);\n\t\t\t\t\t\t\tif (inpoly !== null) {\n\t\t\t\t\t\t\t\tBinside = inpoly;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Binside === null) {\n\t\t\t\t\t\t\t// A and B are the same\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar startPoint = { x: B.offsetx, y: B.offsety };\n\t\t\t\t\t\tif ((Binside && inside || !Binside && !inside) && !this.intersect(A, B) && !inNfp(startPoint, NFP)) {\n\t\t\t\t\t\t\treturn startPoint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// slide B along vector\n\t\t\t\t\t\tvar vx = A[i + 1].x - A[i].x;\n\t\t\t\t\t\tvar vy = A[i + 1].y - A[i].y;\n\n\t\t\t\t\t\tvar d1 = this.polygonProjectionDistance(A, B, { x: vx, y: vy });\n\t\t\t\t\t\tvar d2 = this.polygonProjectionDistance(B, A, { x: -vx, y: -vy });\n\n\t\t\t\t\t\tvar d = null;\n\n\t\t\t\t\t\t// todo: clean this up\n\t\t\t\t\t\tif (d1 === null && d2 === null) {\n\t\t\t\t\t\t\t// nothin\n\t\t\t\t\t\t} else if (d1 === null) {\n\t\t\t\t\t\t\td = d2;\n\t\t\t\t\t\t} else if (d2 === null) {\n\t\t\t\t\t\t\td = d1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\td = Math.min(d1, d2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only slide until no longer negative\n\t\t\t\t\t\t// todo: clean this up\n\t\t\t\t\t\tif (d !== null && !_almostEqual(d, 0) && d > 0) {} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar vd2 = vx * vx + vy * vy;\n\n\t\t\t\t\t\tif (d * d < vd2 && !_almostEqual(d * d, vd2)) {\n\t\t\t\t\t\t\tvar vd = Math.sqrt(vx * vx + vy * vy);\n\t\t\t\t\t\t\tvx *= d / vd;\n\t\t\t\t\t\t\tvy *= d / vd;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tB.offsetx += vx;\n\t\t\t\t\t\tB.offsety += vy;\n\n\t\t\t\t\t\tfor (k = 0; k < B.length; k++) {\n\t\t\t\t\t\t\tvar inpoly = this.pointInPolygon({ x: B[k].x + B.offsetx, y: B[k].y + B.offsety }, A);\n\t\t\t\t\t\t\tif (inpoly !== null) {\n\t\t\t\t\t\t\t\tBinside = inpoly;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstartPoint = { x: B.offsetx, y: B.offsety };\n\t\t\t\t\t\tif ((Binside && inside || !Binside && !inside) && !this.intersect(A, B) && !inNfp(startPoint, NFP)) {\n\t\t\t\t\t\t\treturn startPoint;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// returns true if point already exists in the given nfp\n\t\t\tfunction inNfp(p, nfp) {\n\t\t\t\tif (!nfp || nfp.length == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < nfp.length; i++) {\n\t\t\t\t\tfor (var j = 0; j < nfp[i].length; j++) {\n\t\t\t\t\t\tif (_almostEqual(p.x, nfp[i][j].x) && _almostEqual(p.y, nfp[i][j].y)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tisRectangle: function isRectangle(poly, tolerance) {\n\t\t\tvar bb = this.getPolygonBounds(poly);\n\t\t\ttolerance = tolerance || TOL;\n\n\t\t\tfor (var i = 0; i < poly.length; i++) {\n\t\t\t\tif (!_almostEqual(poly[i].x, bb.x) && !_almostEqual(poly[i].x, bb.x + bb.width)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!_almostEqual(poly[i].y, bb.y) && !_almostEqual(poly[i].y, bb.y + bb.height)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t// returns an interior NFP for the special case where A is a rectangle\n\t\tnoFitPolygonRectangle: function noFitPolygonRectangle(A, B) {\n\t\t\tvar minAx = A[0].x;\n\t\t\tvar minAy = A[0].y;\n\t\t\tvar maxAx = A[0].x;\n\t\t\tvar maxAy = A[0].y;\n\n\t\t\tfor (var i = 1; i < A.length; i++) {\n\t\t\t\tif (A[i].x < minAx) {\n\t\t\t\t\tminAx = A[i].x;\n\t\t\t\t}\n\t\t\t\tif (A[i].y < minAy) {\n\t\t\t\t\tminAy = A[i].y;\n\t\t\t\t}\n\t\t\t\tif (A[i].x > maxAx) {\n\t\t\t\t\tmaxAx = A[i].x;\n\t\t\t\t}\n\t\t\t\tif (A[i].y > maxAy) {\n\t\t\t\t\tmaxAy = A[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar minBx = B[0].x;\n\t\t\tvar minBy = B[0].y;\n\t\t\tvar maxBx = B[0].x;\n\t\t\tvar maxBy = B[0].y;\n\t\t\tfor (i = 1; i < B.length; i++) {\n\t\t\t\tif (B[i].x < minBx) {\n\t\t\t\t\tminBx = B[i].x;\n\t\t\t\t}\n\t\t\t\tif (B[i].y < minBy) {\n\t\t\t\t\tminBy = B[i].y;\n\t\t\t\t}\n\t\t\t\tif (B[i].x > maxBx) {\n\t\t\t\t\tmaxBx = B[i].x;\n\t\t\t\t}\n\t\t\t\tif (B[i].y > maxBy) {\n\t\t\t\t\tmaxBy = B[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (maxBx - minBx > maxAx - minAx) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (maxBy - minBy > maxAy - minAy) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn [[{ x: minAx - minBx + B[0].x, y: minAy - minBy + B[0].y }, { x: maxAx - maxBx + B[0].x, y: minAy - minBy + B[0].y }, { x: maxAx - maxBx + B[0].x, y: maxAy - maxBy + B[0].y }, { x: minAx - minBx + B[0].x, y: maxAy - maxBy + B[0].y }]];\n\t\t},\n\n\t\t// given a static polygon A and a movable polygon B, compute a no fit polygon by orbiting B about A\n\t\t// if the inside flag is set, B is orbited inside of A rather than outside\n\t\t// if the searchEdges flag is set, all edges of A are explored for NFPs - multiple \n\t\tnoFitPolygon: function noFitPolygon(A, B, inside, searchEdges) {\n\t\t\tif (!A || A.length < 3 || !B || B.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tA.offsetx = 0;\n\t\t\tA.offsety = 0;\n\n\t\t\tvar i, j;\n\n\t\t\tvar minA = A[0].y;\n\t\t\tvar minAindex = 0;\n\n\t\t\tvar maxB = B[0].y;\n\t\t\tvar maxBindex = 0;\n\n\t\t\tfor (i = 1; i < A.length; i++) {\n\t\t\t\tA[i].marked = false;\n\t\t\t\tif (A[i].y < minA) {\n\t\t\t\t\tminA = A[i].y;\n\t\t\t\t\tminAindex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 1; i < B.length; i++) {\n\t\t\t\tB[i].marked = false;\n\t\t\t\tif (B[i].y > maxB) {\n\t\t\t\t\tmaxB = B[i].y;\n\t\t\t\t\tmaxBindex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inside) {\n\t\t\t\t// shift B such that the bottom-most point of B is at the top-most point of A. This guarantees an initial placement with no intersections\n\t\t\t\tvar startpoint = {\n\t\t\t\t\tx: A[minAindex].x - B[maxBindex].x,\n\t\t\t\t\ty: A[minAindex].y - B[maxBindex].y\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// no reliable heuristic for inside\n\t\t\t\tvar startpoint = this.searchStartPoint(A, B, true);\n\t\t\t}\n\n\t\t\tvar NFPlist = [];\n\n\t\t\twhile (startpoint !== null) {\n\n\t\t\t\tB.offsetx = startpoint.x;\n\t\t\t\tB.offsety = startpoint.y;\n\n\t\t\t\t// maintain a list of touching points/edges\n\t\t\t\tvar touching;\n\n\t\t\t\tvar prevvector = null; // keep track of previous vector\n\t\t\t\tvar NFP = [{\n\t\t\t\t\tx: B[0].x + B.offsetx,\n\t\t\t\t\ty: B[0].y + B.offsety\n\t\t\t\t}];\n\n\t\t\t\tvar referencex = B[0].x + B.offsetx;\n\t\t\t\tvar referencey = B[0].y + B.offsety;\n\t\t\t\tvar startx = referencex;\n\t\t\t\tvar starty = referencey;\n\t\t\t\tvar counter = 0;\n\n\t\t\t\twhile (counter < 10 * (A.length + B.length)) {\n\t\t\t\t\t// sanity check, prevent infinite loop\n\t\t\t\t\ttouching = [];\n\t\t\t\t\t// find touching vertices/edges\n\t\t\t\t\tfor (i = 0; i < A.length; i++) {\n\t\t\t\t\t\tvar nexti = i == A.length - 1 ? 0 : i + 1;\n\t\t\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\t\t\tif (_almostEqual(A[i].x, B[j].x + B.offsetx) && _almostEqual(A[i].y, B[j].y + B.offsety)) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 0, A: i, B: j });\n\t\t\t\t\t\t\t} else if (_onSegment(A[i], A[nexti], { x: B[j].x + B.offsetx, y: B[j].y + B.offsety })) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 1, A: nexti, B: j });\n\t\t\t\t\t\t\t} else if (_onSegment({ x: B[j].x + B.offsetx, y: B[j].y + B.offsety }, { x: B[nextj].x + B.offsetx, y: B[nextj].y + B.offsety }, A[i])) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 2, A: i, B: nextj });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// generate translation vectors from touching vertices/edges\n\t\t\t\t\tvar vectors = [];\n\t\t\t\t\tfor (i = 0; i < touching.length; i++) {\n\t\t\t\t\t\tvar vertexA = A[touching[i].A];\n\t\t\t\t\t\tvertexA.marked = true;\n\n\t\t\t\t\t\t// adjacent A vertices\n\t\t\t\t\t\tvar prevAindex = touching[i].A - 1;\n\t\t\t\t\t\tvar nextAindex = touching[i].A + 1;\n\n\t\t\t\t\t\tprevAindex = prevAindex < 0 ? A.length - 1 : prevAindex; // loop\n\t\t\t\t\t\tnextAindex = nextAindex >= A.length ? 0 : nextAindex; // loop\n\n\t\t\t\t\t\tvar prevA = A[prevAindex];\n\t\t\t\t\t\tvar nextA = A[nextAindex];\n\n\t\t\t\t\t\t// adjacent B vertices\n\t\t\t\t\t\tvar vertexB = B[touching[i].B];\n\n\t\t\t\t\t\tvar prevBindex = touching[i].B - 1;\n\t\t\t\t\t\tvar nextBindex = touching[i].B + 1;\n\n\t\t\t\t\t\tprevBindex = prevBindex < 0 ? B.length - 1 : prevBindex; // loop\n\t\t\t\t\t\tnextBindex = nextBindex >= B.length ? 0 : nextBindex; // loop\n\n\t\t\t\t\t\tvar prevB = B[prevBindex];\n\t\t\t\t\t\tvar nextB = B[nextBindex];\n\n\t\t\t\t\t\tif (touching[i].type == 0) {\n\n\t\t\t\t\t\t\tvar vA1 = {\n\t\t\t\t\t\t\t\tx: prevA.x - vertexA.x,\n\t\t\t\t\t\t\t\ty: prevA.y - vertexA.y,\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: prevA\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar vA2 = {\n\t\t\t\t\t\t\t\tx: nextA.x - vertexA.x,\n\t\t\t\t\t\t\t\ty: nextA.y - vertexA.y,\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: nextA\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// B vectors need to be inverted\n\t\t\t\t\t\t\tvar vB1 = {\n\t\t\t\t\t\t\t\tx: vertexB.x - prevB.x,\n\t\t\t\t\t\t\t\ty: vertexB.y - prevB.y,\n\t\t\t\t\t\t\t\tstart: prevB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar vB2 = {\n\t\t\t\t\t\t\t\tx: vertexB.x - nextB.x,\n\t\t\t\t\t\t\t\ty: vertexB.y - nextB.y,\n\t\t\t\t\t\t\t\tstart: nextB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvectors.push(vA1);\n\t\t\t\t\t\t\tvectors.push(vA2);\n\t\t\t\t\t\t\tvectors.push(vB1);\n\t\t\t\t\t\t\tvectors.push(vB2);\n\t\t\t\t\t\t} else if (touching[i].type == 1) {\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: prevA,\n\t\t\t\t\t\t\t\tend: vertexA\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: prevA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: prevA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: prevA\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (touching[i].type == 2) {\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: prevB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (prevB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (prevB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: vertexB,\n\t\t\t\t\t\t\t\tend: prevB\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// todo: there should be a faster way to reject vectors that will cause immediate intersection. For now just check them all\n\n\t\t\t\t\tvar translate = null;\n\t\t\t\t\tvar maxd = 0;\n\n\t\t\t\t\tfor (i = 0; i < vectors.length; i++) {\n\t\t\t\t\t\tif (vectors[i].x == 0 && vectors[i].y == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if this vector points us back to where we came from, ignore it.\n\t\t\t\t\t\t// ie cross product = 0, dot product < 0\n\t\t\t\t\t\tif (prevvector && vectors[i].y * prevvector.y + vectors[i].x * prevvector.x < 0) {\n\n\t\t\t\t\t\t\t// compare magnitude with unit vectors\n\t\t\t\t\t\t\tvar vectorlength = Math.sqrt(vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y);\n\t\t\t\t\t\t\tvar unitv = { x: vectors[i].x / vectorlength, y: vectors[i].y / vectorlength };\n\n\t\t\t\t\t\t\tvar prevlength = Math.sqrt(prevvector.x * prevvector.x + prevvector.y * prevvector.y);\n\t\t\t\t\t\t\tvar prevunit = { x: prevvector.x / prevlength, y: prevvector.y / prevlength };\n\n\t\t\t\t\t\t\t// we need to scale down to unit vectors to normalize vector length. Could also just do a tan here\n\t\t\t\t\t\t\tif (Math.abs(unitv.y * prevunit.x - unitv.x * prevunit.y) < 0.0001) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar d = this.polygonSlideDistance(A, B, vectors[i], true);\n\t\t\t\t\t\tvar vecd2 = vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y;\n\n\t\t\t\t\t\tif (d === null || d * d > vecd2) {\n\t\t\t\t\t\t\tvar vecd = Math.sqrt(vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y);\n\t\t\t\t\t\t\td = vecd;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (d !== null && d > maxd) {\n\t\t\t\t\t\t\tmaxd = d;\n\t\t\t\t\t\t\ttranslate = vectors[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (translate === null || _almostEqual(maxd, 0)) {\n\t\t\t\t\t\t// didn't close the loop, something went wrong here\n\t\t\t\t\t\tNFP = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttranslate.start.marked = true;\n\t\t\t\t\ttranslate.end.marked = true;\n\n\t\t\t\t\tprevvector = translate;\n\n\t\t\t\t\t// trim\n\t\t\t\t\tvar vlength2 = translate.x * translate.x + translate.y * translate.y;\n\t\t\t\t\tif (maxd * maxd < vlength2 && !_almostEqual(maxd * maxd, vlength2)) {\n\t\t\t\t\t\tvar scale = Math.sqrt(maxd * maxd / vlength2);\n\t\t\t\t\t\ttranslate.x *= scale;\n\t\t\t\t\t\ttranslate.y *= scale;\n\t\t\t\t\t}\n\n\t\t\t\t\treferencex += translate.x;\n\t\t\t\t\treferencey += translate.y;\n\n\t\t\t\t\tif (_almostEqual(referencex, startx) && _almostEqual(referencey, starty)) {\n\t\t\t\t\t\t// we've made a full loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if A and B start on a touching horizontal line, the end point may not be the start point\n\t\t\t\t\tvar looped = false;\n\t\t\t\t\tif (NFP.length > 0) {\n\t\t\t\t\t\tfor (i = 0; i < NFP.length - 1; i++) {\n\t\t\t\t\t\t\tif (_almostEqual(referencex, NFP[i].x) && _almostEqual(referencey, NFP[i].y)) {\n\t\t\t\t\t\t\t\tlooped = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (looped) {\n\t\t\t\t\t\t// we've made a full loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tNFP.push({\n\t\t\t\t\t\tx: referencex,\n\t\t\t\t\t\ty: referencey\n\t\t\t\t\t});\n\n\t\t\t\t\tB.offsetx += translate.x;\n\t\t\t\t\tB.offsety += translate.y;\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tif (NFP && NFP.length > 0) {\n\t\t\t\t\tNFPlist.push(NFP);\n\t\t\t\t}\n\n\t\t\t\tif (!searchEdges) {\n\t\t\t\t\t// only get outer NFP or first inner NFP\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstartpoint = this.searchStartPoint(A, B, inside, NFPlist);\n\t\t\t}\n\n\t\t\treturn NFPlist;\n\t\t},\n\n\t\t// given two polygons that touch at at least one point, but do not intersect. Return the outer perimeter of both polygons as a single continuous polygon\n\t\t// A and B must have the same winding direction\n\t\tpolygonHull: function polygonHull(A, B) {\n\t\t\tif (!A || A.length < 3 || !B || B.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar i, j;\n\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\t// start at an extreme point that is guaranteed to be on the final polygon\n\t\t\tvar miny = A[0].y;\n\t\t\tvar startPolygon = A;\n\t\t\tvar startIndex = 0;\n\n\t\t\tfor (i = 0; i < A.length; i++) {\n\t\t\t\tif (A[i].y + Aoffsety < miny) {\n\t\t\t\t\tminy = A[i].y + Aoffsety;\n\t\t\t\t\tstartPolygon = A;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < B.length; i++) {\n\t\t\t\tif (B[i].y + Boffsety < miny) {\n\t\t\t\t\tminy = B[i].y + Boffsety;\n\t\t\t\t\tstartPolygon = B;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for simplicity we'll define polygon A as the starting polygon\n\t\t\tif (startPolygon == B) {\n\t\t\t\tB = A;\n\t\t\t\tA = startPolygon;\n\t\t\t\tAoffsetx = A.offsetx || 0;\n\t\t\t\tAoffsety = A.offsety || 0;\n\t\t\t\tBoffsetx = B.offsetx || 0;\n\t\t\t\tBoffsety = B.offsety || 0;\n\t\t\t}\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\tvar C = [];\n\t\t\tvar current = startIndex;\n\t\t\tvar intercept1 = null;\n\t\t\tvar intercept2 = null;\n\n\t\t\t// scan forward from the starting point\n\t\t\tfor (i = 0; i < A.length + 1; i++) {\n\t\t\t\tcurrent = current == A.length ? 0 : current;\n\t\t\t\tvar next = current == A.length - 1 ? 0 : current + 1;\n\t\t\t\tvar touching = false;\n\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\tif (_almostEqual(A[current].x + Aoffsetx, B[j].x + Boffsetx) && _almostEqual(A[current].y + Aoffsety, B[j].y + Boffsety)) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept1 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety }, { x: A[next].x + Aoffsetx, y: A[next].y + Aoffsety }, { x: B[j].x + Boffsetx, y: B[j].y + Boffsety })) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.push({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety });\n\t\t\t\t\t\tintercept1 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety }, { x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety }, { x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety })) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.push({ x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety });\n\t\t\t\t\t\tintercept1 = nextj;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (touching) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\n\t\t\t\tcurrent++;\n\t\t\t}\n\n\t\t\t// scan backward from the starting point\n\t\t\tcurrent = startIndex - 1;\n\t\t\tfor (i = 0; i < A.length + 1; i++) {\n\t\t\t\tcurrent = current < 0 ? A.length - 1 : current;\n\t\t\t\tvar next = current == 0 ? A.length - 1 : current - 1;\n\t\t\t\tvar touching = false;\n\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\tif (_almostEqual(A[current].x + Aoffsetx, B[j].x + Boffsetx) && _almostEqual(A[current].y, B[j].y + Boffsety)) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety }, { x: A[next].x + Aoffsetx, y: A[next].y + Aoffsety }, { x: B[j].x + Boffsetx, y: B[j].y + Boffsety })) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.unshift({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety }, { x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety }, { x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety })) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (touching) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\n\t\t\t\tcurrent--;\n\t\t\t}\n\n\t\t\tif (intercept1 === null || intercept2 === null) {\n\t\t\t\t// polygons not touching?\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// the relevant points on B now lie between intercept1 and intercept2\n\t\t\tcurrent = intercept1 + 1;\n\t\t\tfor (i = 0; i < B.length; i++) {\n\t\t\t\tcurrent = current == B.length ? 0 : current;\n\t\t\t\tC.push({ x: B[current].x + Boffsetx, y: B[current].y + Boffsety });\n\n\t\t\t\tif (current == intercept2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcurrent++;\n\t\t\t}\n\n\t\t\t// dedupe\n\t\t\tfor (i = 0; i < C.length; i++) {\n\t\t\t\tvar next = i == C.length - 1 ? 0 : i + 1;\n\t\t\t\tif (_almostEqual(C[i].x, C[next].x) && _almostEqual(C[i].y, C[next].y)) {\n\t\t\t\t\tC.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn C;\n\t\t},\n\n\t\trotatePolygon: function rotatePolygon(polygon, angle) {\n\t\t\tvar rotated = [];\n\t\t\tangle = angle * Math.PI / 180;\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tvar x = polygon[i].x;\n\t\t\t\tvar y = polygon[i].y;\n\t\t\t\tvar x1 = x * Math.cos(angle) - y * Math.sin(angle);\n\t\t\t\tvar y1 = x * Math.sin(angle) + y * Math.cos(angle);\n\n\t\t\t\trotated.push({ x: x1, y: y1 });\n\t\t\t}\n\t\t\t// reset bounding box\n\t\t\tvar bounds = GeometryUtil.getPolygonBounds(rotated);\n\t\t\trotated.x = bounds.x;\n\t\t\trotated.y = bounds.y;\n\t\t\trotated.width = bounds.width;\n\t\t\trotated.height = bounds.height;\n\n\t\t\treturn rotated;\n\t\t}\n\t};\n})(typeof window !== 'undefined' ? window : self);"},698:function(t,n){t.exports="'use strict';\n\n// jsClipper uses X/Y instead of x/y...\nfunction toClipperCoordinates(polygon) {\n\tvar clone = [];\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tclone.push({\n\t\t\tX: polygon[i].x,\n\t\t\tY: polygon[i].y\n\t\t});\n\t}\n\n\treturn clone;\n};\n\nfunction toNestCoordinates(polygon, scale) {\n\tvar clone = [];\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tclone.push({\n\t\t\tx: polygon[i].X / scale,\n\t\t\ty: polygon[i].Y / scale\n\t\t});\n\t}\n\n\treturn clone;\n};\n\nfunction rotatePolygon(polygon, degrees) {\n\tvar rotated = [];\n\tvar angle = degrees * Math.PI / 180;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar x = polygon[i].x;\n\t\tvar y = polygon[i].y;\n\t\tvar x1 = x * Math.cos(angle) - y * Math.sin(angle);\n\t\tvar y1 = x * Math.sin(angle) + y * Math.cos(angle);\n\n\t\trotated.push({ x: x1, y: y1 });\n\t}\n\n\tif (polygon.children && polygon.children.length > 0) {\n\t\trotated.children = [];\n\t\tfor (var j = 0; j < polygon.children.length; j++) {\n\t\t\trotated.children.push(rotatePolygon(polygon.children[j], degrees));\n\t\t}\n\t}\n\n\treturn rotated;\n};\n\nfunction PlacementWorker(binPolygon, paths, ids, rotations, config, nfpCache) {\n\tthis.binPolygon = binPolygon;\n\tthis.paths = paths;\n\tthis.ids = ids;\n\tthis.rotations = rotations;\n\tthis.config = config;\n\tthis.nfpCache = nfpCache || {};\n\n\t// return a placement for the paths/rotations given\n\t// happens inside a webworker\n\tthis.placePaths = function (paths) {\n\n\t\tvar self = global.env.self;\n\n\t\tif (!self.binPolygon) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar i, j, k, m, n, path;\n\n\t\t// rotate paths by given rotation\n\t\tvar rotated = [];\n\t\tfor (i = 0; i < paths.length; i++) {\n\t\t\tvar r = rotatePolygon(paths[i], paths[i].rotation);\n\t\t\tr.rotation = paths[i].rotation;\n\t\t\tr.source = paths[i].source;\n\t\t\tr.id = paths[i].id;\n\t\t\trotated.push(r);\n\t\t}\n\n\t\tpaths = rotated;\n\n\t\tvar allplacements = [];\n\t\tvar fitness = 0;\n\t\tvar binarea = Math.abs(GeometryUtil.polygonArea(self.binPolygon));\n\t\tvar key, nfp;\n\n\t\twhile (paths.length > 0) {\n\n\t\t\tvar placed = [];\n\t\t\tvar placements = [];\n\t\t\tfitness += 1; // add 1 for each new bin opened (lower fitness is better)\n\n\t\t\tfor (i = 0; i < paths.length; i++) {\n\t\t\t\tpath = paths[i];\n\n\t\t\t\t// inner NFP\n\t\t\t\tkey = JSON.stringify({ A: -1, B: path.id, inside: true, Arotation: 0, Brotation: path.rotation });\n\t\t\t\tvar binNfp = self.nfpCache[key];\n\n\t\t\t\t// part unplaceable, skip\n\t\t\t\tif (!binNfp || binNfp.length == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// ensure all necessary NFPs exist\n\t\t\t\tvar error = false;\n\t\t\t\tfor (j = 0; j < placed.length; j++) {\n\t\t\t\t\tkey = JSON.stringify({ A: placed[j].id, B: path.id, inside: false, Arotation: placed[j].rotation, Brotation: path.rotation });\n\t\t\t\t\tnfp = self.nfpCache[key];\n\n\t\t\t\t\tif (!nfp) {\n\t\t\t\t\t\terror = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// part unplaceable, skip\n\t\t\t\tif (error) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar position = null;\n\t\t\t\tif (placed.length == 0) {\n\t\t\t\t\t// first placement, put it on the left\n\t\t\t\t\tfor (j = 0; j < binNfp.length; j++) {\n\t\t\t\t\t\tfor (k = 0; k < binNfp[j].length; k++) {\n\t\t\t\t\t\t\tif (position === null || binNfp[j][k].x - path[0].x < position.x) {\n\t\t\t\t\t\t\t\tposition = {\n\t\t\t\t\t\t\t\t\tx: binNfp[j][k].x - path[0].x,\n\t\t\t\t\t\t\t\t\ty: binNfp[j][k].y - path[0].y,\n\t\t\t\t\t\t\t\t\tid: path.id,\n\t\t\t\t\t\t\t\t\trotation: path.rotation\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tplacements.push(position);\n\t\t\t\t\tplaced.push(path);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar clipperBinNfp = [];\n\t\t\t\tfor (j = 0; j < binNfp.length; j++) {\n\t\t\t\t\tclipperBinNfp.push(toClipperCoordinates(binNfp[j]));\n\t\t\t\t}\n\n\t\t\t\tClipperLib.JS.ScaleUpPaths(clipperBinNfp, self.config.clipperScale);\n\n\t\t\t\tvar clipper = new ClipperLib.Clipper();\n\t\t\t\tvar combinedNfp = new ClipperLib.Paths();\n\n\t\t\t\tfor (j = 0; j < placed.length; j++) {\n\t\t\t\t\tkey = JSON.stringify({ A: placed[j].id, B: path.id, inside: false, Arotation: placed[j].rotation, Brotation: path.rotation });\n\t\t\t\t\tnfp = self.nfpCache[key];\n\n\t\t\t\t\tif (!nfp) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k < nfp.length; k++) {\n\t\t\t\t\t\tvar clone = toClipperCoordinates(nfp[k]);\n\t\t\t\t\t\tfor (m = 0; m < clone.length; m++) {\n\t\t\t\t\t\t\tclone[m].X += placements[j].x;\n\t\t\t\t\t\t\tclone[m].Y += placements[j].y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tClipperLib.JS.ScaleUpPath(clone, self.config.clipperScale);\n\t\t\t\t\t\tclone = ClipperLib.Clipper.CleanPolygon(clone, 0.0001 * self.config.clipperScale);\n\t\t\t\t\t\tvar area = Math.abs(ClipperLib.Clipper.Area(clone));\n\t\t\t\t\t\tif (clone.length > 2 && area > 0.1 * self.config.clipperScale * self.config.clipperScale) {\n\t\t\t\t\t\t\tclipper.AddPath(clone, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!clipper.Execute(ClipperLib.ClipType.ctUnion, combinedNfp, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// difference with bin polygon\n\t\t\t\tvar finalNfp = new ClipperLib.Paths();\n\t\t\t\tclipper = new ClipperLib.Clipper();\n\n\t\t\t\tclipper.AddPaths(combinedNfp, ClipperLib.PolyType.ptClip, true);\n\t\t\t\tclipper.AddPaths(clipperBinNfp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (!clipper.Execute(ClipperLib.ClipType.ctDifference, finalNfp, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinalNfp = ClipperLib.Clipper.CleanPolygons(finalNfp, 0.0001 * self.config.clipperScale);\n\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\tvar area = Math.abs(ClipperLib.Clipper.Area(finalNfp[j]));\n\t\t\t\t\tif (finalNfp[j].length < 3 || area < 0.1 * self.config.clipperScale * self.config.clipperScale) {\n\t\t\t\t\t\tfinalNfp.splice(j, 1);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!finalNfp || finalNfp.length == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar f = [];\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\t// back to normal scale\n\t\t\t\t\tf.push(toNestCoordinates(finalNfp[j], self.config.clipperScale));\n\t\t\t\t}\n\t\t\t\tfinalNfp = f;\n\n\t\t\t\t// choose placement that results in the smallest bounding box\n\t\t\t\t// could use convex hull instead, but it can create oddly shaped nests (triangles or long slivers) which are not optimal for real-world use\n\t\t\t\t// todo: generalize gravity direction\n\t\t\t\tvar minwidth = null;\n\t\t\t\tvar minarea = null;\n\t\t\t\tvar minx = null;\n\t\t\t\tvar nf, area, shiftvector;\n\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\tnf = finalNfp[j];\n\t\t\t\t\tif (Math.abs(GeometryUtil.polygonArea(nf)) < 2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k < nf.length; k++) {\n\t\t\t\t\t\tvar allpoints = [];\n\t\t\t\t\t\tfor (m = 0; m < placed.length; m++) {\n\t\t\t\t\t\t\tfor (n = 0; n < placed[m].length; n++) {\n\t\t\t\t\t\t\t\tallpoints.push({ x: placed[m][n].x + placements[m].x, y: placed[m][n].y + placements[m].y });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshiftvector = {\n\t\t\t\t\t\t\tx: nf[k].x - path[0].x,\n\t\t\t\t\t\t\ty: nf[k].y - path[0].y,\n\t\t\t\t\t\t\tid: path.id,\n\t\t\t\t\t\t\trotation: path.rotation,\n\t\t\t\t\t\t\tnfp: combinedNfp\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (m = 0; m < path.length; m++) {\n\t\t\t\t\t\t\tallpoints.push({ x: path[m].x + shiftvector.x, y: path[m].y + shiftvector.y });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar rectbounds = GeometryUtil.getPolygonBounds(allpoints);\n\n\t\t\t\t\t\t// weigh width more, to help compress in direction of gravity\n\t\t\t\t\t\tarea = rectbounds.width * 2 + rectbounds.height;\n\n\t\t\t\t\t\tif (minarea === null || area < minarea || GeometryUtil.almostEqual(minarea, area) && (minx === null || shiftvector.x < minx)) {\n\t\t\t\t\t\t\tminarea = area;\n\t\t\t\t\t\t\tminwidth = rectbounds.width;\n\t\t\t\t\t\t\tposition = shiftvector;\n\t\t\t\t\t\t\tminx = shiftvector.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (position) {\n\t\t\t\t\tplaced.push(path);\n\t\t\t\t\tplacements.push(position);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minwidth) {\n\t\t\t\tfitness += minwidth / binarea;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < placed.length; i++) {\n\t\t\t\tvar index = paths.indexOf(placed[i]);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tpaths.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (placements && placements.length > 0) {\n\t\t\t\tallplacements.push(placements);\n\t\t\t} else {\n\t\t\t\tbreak; // something went wrong\n\t\t\t}\n\t\t}\n\n\t\t// there were parts that couldn't be placed\n\t\tfitness += 2 * paths.length;\n\n\t\treturn { placements: allplacements, fitness: fitness, paths: paths, area: binarea };\n\t};\n}\n(typeof window !== 'undefined' ? window : self).PlacementWorker = PlacementWorker;\n\n// clipperjs uses alerts for warnings\nfunction alert(message) {\n\tconsole.log('alert: ', message);\n}"},699:function(t,n,e){e(77)(e(700))},700:function(t,n){t.exports='"use strict";\n\n// SVGPathSeg API polyfill\n// https://github.com/progers/pathseg\n//\n// This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from\n// SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec\n// changes which were implemented in Firefox 43 and Chrome 46.\n\n(function () {\n    "use strict";\n\n    if (!("SVGPathSeg" in window)) {\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg\n        window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {\n            this.pathSegType = type;\n            this.pathSegTypeAsLetter = typeAsLetter;\n            this._owningPathSegList = owningPathSegList;\n        };\n\n        SVGPathSeg.PATHSEG_UNKNOWN = 0;\n        SVGPathSeg.PATHSEG_CLOSEPATH = 1;\n        SVGPathSeg.PATHSEG_MOVETO_ABS = 2;\n        SVGPathSeg.PATHSEG_MOVETO_REL = 3;\n        SVGPathSeg.PATHSEG_LINETO_ABS = 4;\n        SVGPathSeg.PATHSEG_LINETO_REL = 5;\n        SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;\n        SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;\n        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;\n        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;\n        SVGPathSeg.PATHSEG_ARC_ABS = 10;\n        SVGPathSeg.PATHSEG_ARC_REL = 11;\n        SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;\n        SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;\n        SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;\n        SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;\n        SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;\n        SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;\n        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;\n        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;\n\n        // Notify owning PathSegList on any changes so they can be synchronized back to the path element.\n        SVGPathSeg.prototype._segmentChanged = function () {\n            if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);\n        };\n\n        window.SVGPathSegClosePath = function (owningPathSegList) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);\n        };\n        SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegClosePath.prototype.toString = function () {\n            return "[object SVGPathSegClosePath]";\n        };\n        SVGPathSegClosePath.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter;\n        };\n        SVGPathSegClosePath.prototype.clone = function () {\n            return new SVGPathSegClosePath(undefined);\n        };\n\n        window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegMovetoAbs.prototype.toString = function () {\n            return "[object SVGPathSegMovetoAbs]";\n        };\n        SVGPathSegMovetoAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegMovetoAbs.prototype.clone = function () {\n            return new SVGPathSegMovetoAbs(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegMovetoAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegMovetoAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegMovetoRel.prototype.toString = function () {\n            return "[object SVGPathSegMovetoRel]";\n        };\n        SVGPathSegMovetoRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegMovetoRel.prototype.clone = function () {\n            return new SVGPathSegMovetoRel(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegMovetoRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegMovetoRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoAbs.prototype.toString = function () {\n            return "[object SVGPathSegLinetoAbs]";\n        };\n        SVGPathSegLinetoAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegLinetoAbs.prototype.clone = function () {\n            return new SVGPathSegLinetoAbs(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegLinetoAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegLinetoAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoRel.prototype.toString = function () {\n            return "[object SVGPathSegLinetoRel]";\n        };\n        SVGPathSegLinetoRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegLinetoRel.prototype.clone = function () {\n            return new SVGPathSegLinetoRel(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegLinetoRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegLinetoRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x1 = x1;\n            this._y1 = y1;\n            this._x2 = x2;\n            this._y2 = y2;\n        };\n        SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoCubicAbs.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoCubicAbs]";\n        };\n        SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoCubicAbs.prototype.clone = function () {\n            return new SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);\n        };\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function get() {\n                return this._x1;\n            }, set: function set(x1) {\n                this._x1 = x1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function get() {\n                return this._y1;\n            }, set: function set(y1) {\n                this._y1 = y1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function get() {\n                return this._x2;\n            }, set: function set(x2) {\n                this._x2 = x2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function get() {\n                return this._y2;\n            }, set: function set(y2) {\n                this._y2 = y2;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x1 = x1;\n            this._y1 = y1;\n            this._x2 = x2;\n            this._y2 = y2;\n        };\n        SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoCubicRel.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoCubicRel]";\n        };\n        SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoCubicRel.prototype.clone = function () {\n            return new SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);\n        };\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function get() {\n                return this._x1;\n            }, set: function set(x1) {\n                this._x1 = x1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function get() {\n                return this._y1;\n            }, set: function set(y1) {\n                this._y1 = y1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function get() {\n                return this._x2;\n            }, set: function set(x2) {\n                this._x2 = x2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function get() {\n                return this._y2;\n            }, set: function set(y2) {\n                this._y2 = y2;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x1 = x1;\n            this._y1 = y1;\n        };\n        SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoQuadraticAbs]";\n        };\n        SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {\n            return new SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);\n        };\n        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function get() {\n                return this._x1;\n            }, set: function set(x1) {\n                this._x1 = x1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function get() {\n                return this._y1;\n            }, set: function set(y1) {\n                this._y1 = y1;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x1 = x1;\n            this._y1 = y1;\n        };\n        SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoQuadraticRel]";\n        };\n        SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {\n            return new SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);\n        };\n        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function get() {\n                return this._x1;\n            }, set: function set(x1) {\n                this._x1 = x1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function get() {\n                return this._y1;\n            }, set: function set(y1) {\n                this._y1 = y1;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._r1 = r1;\n            this._r2 = r2;\n            this._angle = angle;\n            this._largeArcFlag = largeArcFlag;\n            this._sweepFlag = sweepFlag;\n        };\n        SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegArcAbs.prototype.toString = function () {\n            return "[object SVGPathSegArcAbs]";\n        };\n        SVGPathSegArcAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;\n        };\n        SVGPathSegArcAbs.prototype.clone = function () {\n            return new SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);\n        };\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "r1", { get: function get() {\n                return this._r1;\n            }, set: function set(r1) {\n                this._r1 = r1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "r2", { get: function get() {\n                return this._r2;\n            }, set: function set(r2) {\n                this._r2 = r2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "angle", { get: function get() {\n                return this._angle;\n            }, set: function set(angle) {\n                this._angle = angle;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function get() {\n                return this._largeArcFlag;\n            }, set: function set(largeArcFlag) {\n                this._largeArcFlag = largeArcFlag;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcAbs.prototype, "sweepFlag", { get: function get() {\n                return this._sweepFlag;\n            }, set: function set(sweepFlag) {\n                this._sweepFlag = sweepFlag;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._r1 = r1;\n            this._r2 = r2;\n            this._angle = angle;\n            this._largeArcFlag = largeArcFlag;\n            this._sweepFlag = sweepFlag;\n        };\n        SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegArcRel.prototype.toString = function () {\n            return "[object SVGPathSegArcRel]";\n        };\n        SVGPathSegArcRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y;\n        };\n        SVGPathSegArcRel.prototype.clone = function () {\n            return new SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);\n        };\n        Object.defineProperty(SVGPathSegArcRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "r1", { get: function get() {\n                return this._r1;\n            }, set: function set(r1) {\n                this._r1 = r1;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "r2", { get: function get() {\n                return this._r2;\n            }, set: function set(r2) {\n                this._r2 = r2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "angle", { get: function get() {\n                return this._angle;\n            }, set: function set(angle) {\n                this._angle = angle;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "largeArcFlag", { get: function get() {\n                return this._largeArcFlag;\n            }, set: function set(largeArcFlag) {\n                this._largeArcFlag = largeArcFlag;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegArcRel.prototype, "sweepFlag", { get: function get() {\n                return this._sweepFlag;\n            }, set: function set(sweepFlag) {\n                this._sweepFlag = sweepFlag;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);\n            this._x = x;\n        };\n        SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {\n            return "[object SVGPathSegLinetoHorizontalAbs]";\n        };\n        SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x;\n        };\n        SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {\n            return new SVGPathSegLinetoHorizontalAbs(undefined, this._x);\n        };\n        Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);\n            this._x = x;\n        };\n        SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoHorizontalRel.prototype.toString = function () {\n            return "[object SVGPathSegLinetoHorizontalRel]";\n        };\n        SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x;\n        };\n        SVGPathSegLinetoHorizontalRel.prototype.clone = function () {\n            return new SVGPathSegLinetoHorizontalRel(undefined, this._x);\n        };\n        Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);\n            this._y = y;\n        };\n        SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoVerticalAbs.prototype.toString = function () {\n            return "[object SVGPathSegLinetoVerticalAbs]";\n        };\n        SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._y;\n        };\n        SVGPathSegLinetoVerticalAbs.prototype.clone = function () {\n            return new SVGPathSegLinetoVerticalAbs(undefined, this._y);\n        };\n        Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);\n            this._y = y;\n        };\n        SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegLinetoVerticalRel.prototype.toString = function () {\n            return "[object SVGPathSegLinetoVerticalRel]";\n        };\n        SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._y;\n        };\n        SVGPathSegLinetoVerticalRel.prototype.clone = function () {\n            return new SVGPathSegLinetoVerticalRel(undefined, this._y);\n        };\n        Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x2 = x2;\n            this._y2 = y2;\n        };\n        SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoCubicSmoothAbs]";\n        };\n        SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {\n            return new SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);\n        };\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function get() {\n                return this._x2;\n            }, set: function set(x2) {\n                this._x2 = x2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function get() {\n                return this._y2;\n            }, set: function set(y2) {\n                this._y2 = y2;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);\n            this._x = x;\n            this._y = y;\n            this._x2 = x2;\n            this._y2 = y2;\n        };\n        SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoCubicSmoothRel]";\n        };\n        SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {\n            return new SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);\n        };\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function get() {\n                return this._x2;\n            }, set: function set(x2) {\n                this._x2 = x2;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function get() {\n                return this._y2;\n            }, set: function set(y2) {\n                this._y2 = y2;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoQuadraticSmoothAbs]";\n        };\n        SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {\n            return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {\n            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);\n            this._x = x;\n            this._y = y;\n        };\n        SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype);\n        SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {\n            return "[object SVGPathSegCurvetoQuadraticSmoothRel]";\n        };\n        SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {\n            return this.pathSegTypeAsLetter + " " + this._x + " " + this._y;\n        };\n        SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {\n            return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);\n        };\n        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function get() {\n                return this._x;\n            }, set: function set(x) {\n                this._x = x;this._segmentChanged();\n            }, enumerable: true });\n        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function get() {\n                return this._y;\n            }, set: function set(y) {\n                this._y = y;this._segmentChanged();\n            }, enumerable: true });\n\n        // Add createSVGPathSeg* functions to SVGPathElement.\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathElement.\n        SVGPathElement.prototype.createSVGPathSegClosePath = function () {\n            return new SVGPathSegClosePath(undefined);\n        };\n        SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {\n            return new SVGPathSegMovetoAbs(undefined, x, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {\n            return new SVGPathSegMovetoRel(undefined, x, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {\n            return new SVGPathSegLinetoAbs(undefined, x, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {\n            return new SVGPathSegLinetoRel(undefined, x, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {\n            return new SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {\n            return new SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {\n            return new SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {\n            return new SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);\n        };\n        SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n            return new SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n        };\n        SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n            return new SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {\n            return new SVGPathSegLinetoHorizontalAbs(undefined, x);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {\n            return new SVGPathSegLinetoHorizontalRel(undefined, x);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {\n            return new SVGPathSegLinetoVerticalAbs(undefined, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {\n            return new SVGPathSegLinetoVerticalRel(undefined, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {\n            return new SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {\n            return new SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {\n            return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);\n        };\n        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {\n            return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);\n        };\n    }\n\n    if (!("SVGPathSegList" in window)) {\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList\n        window.SVGPathSegList = function (pathElement) {\n            this._pathElement = pathElement;\n            this._list = this._parsePath(this._pathElement.getAttribute("d"));\n\n            // Use a MutationObserver to catch changes to the path\'s "d" attribute.\n            this._mutationObserverConfig = { "attributes": true, "attributeFilter": ["d"] };\n            this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));\n            this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);\n        };\n\n        Object.defineProperty(SVGPathSegList.prototype, "numberOfItems", {\n            get: function get() {\n                this._checkPathSynchronizedToList();\n                return this._list.length;\n            },\n            enumerable: true\n        });\n\n        // Add the pathSegList accessors to SVGPathElement.\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData\n        Object.defineProperty(SVGPathElement.prototype, "pathSegList", {\n            get: function get() {\n                if (!this._pathSegList) this._pathSegList = new SVGPathSegList(this);\n                return this._pathSegList;\n            },\n            enumerable: true\n        });\n        // FIXME: The following are not implemented and simply return SVGPathElement.pathSegList.\n        Object.defineProperty(SVGPathElement.prototype, "normalizedPathSegList", { get: function get() {\n                return this.pathSegList;\n            }, enumerable: true });\n        Object.defineProperty(SVGPathElement.prototype, "animatedPathSegList", { get: function get() {\n                return this.pathSegList;\n            }, enumerable: true });\n        Object.defineProperty(SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function get() {\n                return this.pathSegList;\n            }, enumerable: true });\n\n        // Process any pending mutations to the path element and update the list as needed.\n        // This should be the first call of all public functions and is needed because\n        // MutationObservers are not synchronous so we can have pending asynchronous mutations.\n        SVGPathSegList.prototype._checkPathSynchronizedToList = function () {\n            this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());\n        };\n\n        SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {\n            if (!this._pathElement) return;\n            var hasPathMutations = false;\n            mutationRecords.forEach(function (record) {\n                if (record.attributeName == "d") hasPathMutations = true;\n            });\n            if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute("d"));\n        };\n\n        // Serialize the list and update the path\'s \'d\' attribute.\n        SVGPathSegList.prototype._writeListToPath = function () {\n            this._pathElementMutationObserver.disconnect();\n            this._pathElement.setAttribute("d", SVGPathSegList._pathSegArrayAsString(this._list));\n            this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);\n        };\n\n        // When a path segment changes the list needs to be synchronized back to the path element.\n        SVGPathSegList.prototype.segmentChanged = function (pathSeg) {\n            this._writeListToPath();\n        };\n\n        SVGPathSegList.prototype.clear = function () {\n            this._checkPathSynchronizedToList();\n\n            this._list.forEach(function (pathSeg) {\n                pathSeg._owningPathSegList = null;\n            });\n            this._list = [];\n            this._writeListToPath();\n        };\n\n        SVGPathSegList.prototype.initialize = function (newItem) {\n            this._checkPathSynchronizedToList();\n\n            this._list = [newItem];\n            newItem._owningPathSegList = this;\n            this._writeListToPath();\n            return newItem;\n        };\n\n        SVGPathSegList.prototype._checkValidIndex = function (index) {\n            if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw "INDEX_SIZE_ERR";\n        };\n\n        SVGPathSegList.prototype.getItem = function (index) {\n            this._checkPathSynchronizedToList();\n\n            this._checkValidIndex(index);\n            return this._list[index];\n        };\n\n        SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {\n            this._checkPathSynchronizedToList();\n\n            // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.\n            if (index > this.numberOfItems) index = this.numberOfItems;\n            if (newItem._owningPathSegList) {\n                // SVG2 spec says to make a copy.\n                newItem = newItem.clone();\n            }\n            this._list.splice(index, 0, newItem);\n            newItem._owningPathSegList = this;\n            this._writeListToPath();\n            return newItem;\n        };\n\n        SVGPathSegList.prototype.replaceItem = function (newItem, index) {\n            this._checkPathSynchronizedToList();\n\n            if (newItem._owningPathSegList) {\n                // SVG2 spec says to make a copy.\n                newItem = newItem.clone();\n            }\n            this._checkValidIndex(index);\n            this._list[index] = newItem;\n            newItem._owningPathSegList = this;\n            this._writeListToPath();\n            return newItem;\n        };\n\n        SVGPathSegList.prototype.removeItem = function (index) {\n            this._checkPathSynchronizedToList();\n\n            this._checkValidIndex(index);\n            var item = this._list[index];\n            this._list.splice(index, 1);\n            this._writeListToPath();\n            return item;\n        };\n\n        SVGPathSegList.prototype.appendItem = function (newItem) {\n            this._checkPathSynchronizedToList();\n\n            if (newItem._owningPathSegList) {\n                // SVG2 spec says to make a copy.\n                newItem = newItem.clone();\n            }\n            this._list.push(newItem);\n            newItem._owningPathSegList = this;\n            // TODO: Optimize this to just append to the existing attribute.\n            this._writeListToPath();\n            return newItem;\n        };\n\n        SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {\n            var string = "";\n            var first = true;\n            pathSegArray.forEach(function (pathSeg) {\n                if (first) {\n                    first = false;\n                    string += pathSeg._asPathString();\n                } else {\n                    string += " " + pathSeg._asPathString();\n                }\n            });\n            return string;\n        };\n\n        // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.\n        SVGPathSegList.prototype._parsePath = function (string) {\n            if (!string || string.length == 0) return [];\n\n            var owningPathSegList = this;\n\n            var Builder = function Builder() {\n                this.pathSegList = [];\n            };\n\n            Builder.prototype.appendSegment = function (pathSeg) {\n                this.pathSegList.push(pathSeg);\n            };\n\n            var Source = function Source(string) {\n                this._string = string;\n                this._currentIndex = 0;\n                this._endIndex = this._string.length;\n                this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN;\n\n                this._skipOptionalSpaces();\n            };\n\n            Source.prototype._isCurrentSpace = function () {\n                var character = this._string[this._currentIndex];\n                return character <= " " && (character == " " || character == "\\n" || character == "\\t" || character == "\\r" || character == "\\f");\n            };\n\n            Source.prototype._skipOptionalSpaces = function () {\n                while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n                    this._currentIndex++;\n                }return this._currentIndex < this._endIndex;\n            };\n\n            Source.prototype._skipOptionalSpacesOrDelimiter = function () {\n                if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",") return false;\n                if (this._skipOptionalSpaces()) {\n                    if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {\n                        this._currentIndex++;\n                        this._skipOptionalSpaces();\n                    }\n                }\n                return this._currentIndex < this._endIndex;\n            };\n\n            Source.prototype.hasMoreData = function () {\n                return this._currentIndex < this._endIndex;\n            };\n\n            Source.prototype.peekSegmentType = function () {\n                var lookahead = this._string[this._currentIndex];\n                return this._pathSegTypeFromChar(lookahead);\n            };\n\n            Source.prototype._pathSegTypeFromChar = function (lookahead) {\n                switch (lookahead) {\n                    case "Z":\n                    case "z":\n                        return SVGPathSeg.PATHSEG_CLOSEPATH;\n                    case "M":\n                        return SVGPathSeg.PATHSEG_MOVETO_ABS;\n                    case "m":\n                        return SVGPathSeg.PATHSEG_MOVETO_REL;\n                    case "L":\n                        return SVGPathSeg.PATHSEG_LINETO_ABS;\n                    case "l":\n                        return SVGPathSeg.PATHSEG_LINETO_REL;\n                    case "C":\n                        return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;\n                    case "c":\n                        return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;\n                    case "Q":\n                        return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;\n                    case "q":\n                        return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;\n                    case "A":\n                        return SVGPathSeg.PATHSEG_ARC_ABS;\n                    case "a":\n                        return SVGPathSeg.PATHSEG_ARC_REL;\n                    case "H":\n                        return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;\n                    case "h":\n                        return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;\n                    case "V":\n                        return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;\n                    case "v":\n                        return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;\n                    case "S":\n                        return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;\n                    case "s":\n                        return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n                    case "T":\n                        return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;\n                    case "t":\n                        return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;\n                    default:\n                        return SVGPathSeg.PATHSEG_UNKNOWN;\n                }\n            };\n\n            Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {\n                // Check for remaining coordinates in the current command.\n                if ((lookahead == "+" || lookahead == "-" || lookahead == "." || lookahead >= "0" && lookahead <= "9") && previousCommand != SVGPathSeg.PATHSEG_CLOSEPATH) {\n                    if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_ABS) return SVGPathSeg.PATHSEG_LINETO_ABS;\n                    if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_REL) return SVGPathSeg.PATHSEG_LINETO_REL;\n                    return previousCommand;\n                }\n                return SVGPathSeg.PATHSEG_UNKNOWN;\n            };\n\n            Source.prototype.initialCommandIsMoveTo = function () {\n                // If the path is empty it is still valid, so return true.\n                if (!this.hasMoreData()) return true;\n                var command = this.peekSegmentType();\n                // Path must start with moveTo.\n                return command == SVGPathSeg.PATHSEG_MOVETO_ABS || command == SVGPathSeg.PATHSEG_MOVETO_REL;\n            };\n\n            // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.\n            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n            Source.prototype._parseNumber = function () {\n                var exponent = 0;\n                var integer = 0;\n                var frac = 1;\n                var decimal = 0;\n                var sign = 1;\n                var expsign = 1;\n\n                var startIndex = this._currentIndex;\n\n                this._skipOptionalSpaces();\n\n                // Read the sign.\n                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+") this._currentIndex++;else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {\n                    this._currentIndex++;\n                    sign = -1;\n                }\n\n                if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != ".")\n                    // The first character of a number must be one of [0-9+-.].\n                    return undefined;\n\n                // Read the integer part, build right-to-left.\n                var startIntPartIndex = this._currentIndex;\n                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {\n                    this._currentIndex++;\n                } // Advance to first non-digit.\n\n                if (this._currentIndex != startIntPartIndex) {\n                    var scanIntPartIndex = this._currentIndex - 1;\n                    var multiplier = 1;\n                    while (scanIntPartIndex >= startIntPartIndex) {\n                        integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");\n                        multiplier *= 10;\n                    }\n                }\n\n                // Read the decimals.\n                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {\n                    this._currentIndex++;\n\n                    // There must be a least one digit following the .\n                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;\n                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {\n                        decimal += (this._string.charAt(this._currentIndex++) - "0") * (frac *= 0.1);\n                    }\n                }\n\n                // Read the exponent part.\n                if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m") {\n                    this._currentIndex++;\n\n                    // Read the sign of the exponent.\n                    if (this._string.charAt(this._currentIndex) == "+") {\n                        this._currentIndex++;\n                    } else if (this._string.charAt(this._currentIndex) == "-") {\n                        this._currentIndex++;\n                        expsign = -1;\n                    }\n\n                    // There must be an exponent.\n                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") return undefined;\n\n                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {\n                        exponent *= 10;\n                        exponent += this._string.charAt(this._currentIndex) - "0";\n                        this._currentIndex++;\n                    }\n                }\n\n                var number = integer + decimal;\n                number *= sign;\n\n                if (exponent) number *= Math.pow(10, expsign * exponent);\n\n                if (startIndex == this._currentIndex) return undefined;\n\n                this._skipOptionalSpacesOrDelimiter();\n\n                return number;\n            };\n\n            Source.prototype._parseArcFlag = function () {\n                if (this._currentIndex >= this._endIndex) return undefined;\n                var flag = false;\n                var flagChar = this._string.charAt(this._currentIndex++);\n                if (flagChar == "0") flag = false;else if (flagChar == "1") flag = true;else return undefined;\n\n                this._skipOptionalSpacesOrDelimiter();\n                return flag;\n            };\n\n            Source.prototype.parseSegment = function () {\n                var lookahead = this._string[this._currentIndex];\n                var command = this._pathSegTypeFromChar(lookahead);\n                if (command == SVGPathSeg.PATHSEG_UNKNOWN) {\n                    // Possibly an implicit command. Not allowed if this is the first command.\n                    if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN) return null;\n                    command = this._nextCommandHelper(lookahead, this._previousCommand);\n                    if (command == SVGPathSeg.PATHSEG_UNKNOWN) return null;\n                } else {\n                    this._currentIndex++;\n                }\n\n                this._previousCommand = command;\n\n                switch (command) {\n                    case SVGPathSeg.PATHSEG_MOVETO_REL:\n                        return new SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_MOVETO_ABS:\n                        return new SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_REL:\n                        return new SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_ABS:\n                        return new SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                        return new SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                        return new SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                        return new SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());\n                    case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                        return new SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());\n                    case SVGPathSeg.PATHSEG_CLOSEPATH:\n                        this._skipOptionalSpaces();\n                        return new SVGPathSegClosePath(owningPathSegList);\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                        var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);\n                    case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                        var points = { x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n                        return new SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n                        return new SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n                    case SVGPathSeg.PATHSEG_ARC_REL:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);\n                    case SVGPathSeg.PATHSEG_ARC_ABS:\n                        var points = { x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber() };\n                        return new SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);\n                    default:\n                        throw "Unknown path seg type.";\n                }\n            };\n\n            var builder = new Builder();\n            var source = new Source(string);\n\n            if (!source.initialCommandIsMoveTo()) return [];\n            while (source.hasMoreData()) {\n                var pathSeg = source.parseSegment();\n                if (!pathSeg) return [];\n                builder.appendSegment(pathSeg);\n            }\n\n            return builder.pathSegList;\n        };\n    }\n})();'},701:function(t,n,e){e(77)(e(702))},702:function(t,n){t.exports="// matrix utility from SvgPath\n// https://github.com/fontello/svgpath\n\n'use strict';\n\nfunction Matrix() {\n  if (!(this instanceof Matrix)) {\n    return new Matrix();\n  }\n  this.queue = []; // list of matrixes to apply\n  this.cache = null; // combined matrix cache\n}\nif (typeof window !== 'undefined') window.Matrix = Matrix;\n\n// combine 2 matrixes\n// m1, m2 - [a, b, c, d, e, g]\n//\nMatrix.prototype.combine = function (m1, m2) {\n  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n};\n\nMatrix.prototype.isIdentity = function () {\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  var m = this.cache;\n\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return true;\n  }\n  return false;\n};\n\nMatrix.prototype.matrix = function (m) {\n  if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0) {\n    return this;\n  }\n  this.cache = null;\n  this.queue.push(m);\n  return this;\n};\n\nMatrix.prototype.translate = function (tx, ty) {\n  if (tx !== 0 || ty !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, 0, 1, tx, ty]);\n  }\n  return this;\n};\n\nMatrix.prototype.scale = function (sx, sy) {\n  if (sx !== 1 || sy !== 1) {\n    this.cache = null;\n    this.queue.push([sx, 0, 0, sy, 0, 0]);\n  }\n  return this;\n};\n\nMatrix.prototype.rotate = function (angle, rx, ry) {\n  var rad, cos, sin;\n\n  if (angle !== 0) {\n    this.translate(rx, ry);\n\n    rad = angle * Math.PI / 180;\n    cos = Math.cos(rad);\n    sin = Math.sin(rad);\n\n    this.queue.push([cos, sin, -sin, cos, 0, 0]);\n    this.cache = null;\n\n    this.translate(-rx, -ry);\n  }\n  return this;\n};\n\nMatrix.prototype.skewX = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0]);\n  }\n  return this;\n};\n\nMatrix.prototype.skewY = function (angle) {\n  if (angle !== 0) {\n    this.cache = null;\n    this.queue.push([1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0]);\n  }\n  return this;\n};\n\n// Flatten queue\n//\nMatrix.prototype.toArray = function () {\n  if (this.cache) {\n    return this.cache;\n  }\n\n  if (!this.queue.length) {\n    this.cache = [1, 0, 0, 1, 0, 0];\n    return this.cache;\n  }\n\n  this.cache = this.queue[0];\n\n  if (this.queue.length === 1) {\n    return this.cache;\n  }\n\n  for (var i = 1; i < this.queue.length; i++) {\n    this.cache = this.combine(this.cache, this.queue[i]);\n  }\n\n  return this.cache;\n};\n\n// Apply list of matrixes to (x,y) point.\n// If `isRelative` set, `translate` component of matrix will be skipped\n//\nMatrix.prototype.calc = function (x, y, isRelative) {\n  var m, i, len;\n\n  // Don't change point on empty transforms queue\n  if (!this.queue.length) {\n    return [x, y];\n  }\n\n  // Calculate final matrix, if not exists\n  //\n  // NB. if you deside to apply transforms to point one-by-one,\n  // they should be taken in reverse order\n\n  if (!this.cache) {\n    this.cache = this.toArray();\n  }\n\n  m = this.cache;\n\n  // Apply matrix to point\n  return [x * m[0] + y * m[2] + (isRelative ? 0 : m[4]), x * m[1] + y * m[3] + (isRelative ? 0 : m[5])];\n};"},703:function(t,n,e){e(77)(e(704))},704:function(t,n){t.exports='"use strict";\n\n// rev 452\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.1.3a                                                          *\n * Date      :  22 January 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti\'s clipping algorithm: *\n * "A generic solution to polygon clipping"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * "Polygon Offsetting by Computing Winding Numbers"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.1.3.2                                                         *\n * Date      :  1 February 2014                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu\'s JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See "LICENSE" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function () {\n  function k(a, b, c) {\n    d.biginteger_used = 1;null != a && ("number" == typeof a && "undefined" == typeof b ? this.fromInt(a) : "number" == typeof a ? this.fromNumber(a, b, c) : null == b && "string" != typeof a ? this.fromString(a, 256) : this.fromString(a, b));\n  }function q() {\n    return new k(null);\n  }function Q(a, b, c, e, d, g) {\n    for (; 0 <= --g;) {\n      var h = b * this[a++] + c[e] + d;d = Math.floor(h / 67108864);c[e++] = h & 67108863;\n    }return d;\n  }function R(a, b, c, e, d, g) {\n    var h = b & 32767;for (b >>= 15; 0 <= --g;) {\n      var l = this[a] & 32767,\n          k = this[a++] >> 15,\n          n = b * l + k * h,\n          l = h * l + ((n & 32767) << 15) + c[e] + (d & 1073741823);d = (l >>> 30) + (n >>> 15) + b * k + (d >>> 30);c[e++] = l & 1073741823;\n    }return d;\n  }function S(a, b, c, e, d, g) {\n    var h = b & 16383;for (b >>= 14; 0 <= --g;) {\n      var l = this[a] & 16383,\n          k = this[a++] >> 14,\n          n = b * l + k * h,\n          l = h * l + ((n & 16383) << 14) + c[e] + d;d = (l >> 28) + (n >> 14) + b * k;c[e++] = l & 268435455;\n    }return d;\n  }function L(a, b) {\n    var c = B[a.charCodeAt(b)];return null == c ? -1 : c;\n  }function v(a) {\n    var b = q();b.fromInt(a);return b;\n  }function C(a) {\n    var b = 1,\n        c;0 != (c = a >>> 16) && (a = c, b += 16);0 != (c = a >> 8) && (a = c, b += 8);0 != (c = a >> 4) && (a = c, b += 4);0 != (c = a >> 2) && (a = c, b += 2);0 != a >> 1 && (b += 1);return b;\n  }function x(a) {\n    this.m = a;\n  }function y(a) {\n    this.m = a;this.mp = a.invDigit();this.mpl = this.mp & 32767;this.mph = this.mp >> 15;this.um = (1 << a.DB - 15) - 1;this.mt2 = 2 * a.t;\n  }function T(a, b) {\n    return a & b;\n  }function I(a, b) {\n    return a | b;\n  }function M(a, b) {\n    return a ^ b;\n  }function N(a, b) {\n    return a & ~b;\n  }function A() {}function O(a) {\n    return a;\n  }function w(a) {\n    this.r2 = q();this.q3 = q();k.ONE.dlShiftTo(2 * a.t, this.r2);this.mu = this.r2.divide(a);this.m = a;\n  }var d = {},\n      D = !1;"undefined" !== typeof module && module.exports ? (module.exports = d, D = !0) : "undefined" !== typeof document ? window.ClipperLib = d : self.ClipperLib = d;var r;if (D) p = "chrome", r = "Netscape";else {\n    var p = navigator.userAgent.toString().toLowerCase();r = navigator.appName;\n  }var E, J, F, G, H, P;E = -1 != p.indexOf("chrome") && -1 == p.indexOf("chromium") ? 1 : 0;D = -1 != p.indexOf("chromium") ? 1 : 0;J = -1 != p.indexOf("safari") && -1 == p.indexOf("chrome") && -1 == p.indexOf("chromium") ? 1 : 0;F = -1 != p.indexOf("firefox") ? 1 : 0;p.indexOf("firefox/17");p.indexOf("firefox/15");p.indexOf("firefox/3");G = -1 != p.indexOf("opera") ? 1 : 0;p.indexOf("msie 10");\n  p.indexOf("msie 9");H = -1 != p.indexOf("msie 8") ? 1 : 0;P = -1 != p.indexOf("msie 7") ? 1 : 0;p = -1 != p.indexOf("msie ") ? 1 : 0;d.biginteger_used = null;"Microsoft Internet Explorer" == r ? (k.prototype.am = R, r = 30) : "Netscape" != r ? (k.prototype.am = Q, r = 26) : (k.prototype.am = S, r = 28);k.prototype.DB = r;k.prototype.DM = (1 << r) - 1;k.prototype.DV = 1 << r;k.prototype.FV = Math.pow(2, 52);k.prototype.F1 = 52 - r;k.prototype.F2 = 2 * r - 52;var B = [],\n      u;r = 48;for (u = 0; 9 >= u; ++u) {\n    B[r++] = u;\n  }r = 97;for (u = 10; 36 > u; ++u) {\n    B[r++] = u;\n  }r = 65;for (u = 10; 36 > u; ++u) {\n    B[r++] = u;\n  }x.prototype.convert = function (a) {\n    return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;\n  };x.prototype.revert = function (a) {\n    return a;\n  };x.prototype.reduce = function (a) {\n    a.divRemTo(this.m, null, a);\n  };x.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };x.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };y.prototype.convert = function (a) {\n    var b = q();a.abs().dlShiftTo(this.m.t, b);b.divRemTo(this.m, null, b);0 > a.s && 0 < b.compareTo(k.ZERO) && this.m.subTo(b, b);return b;\n  };y.prototype.revert = function (a) {\n    var b = q();a.copyTo(b);\n    this.reduce(b);return b;\n  };y.prototype.reduce = function (a) {\n    for (; a.t <= this.mt2;) {\n      a[a.t++] = 0;\n    }for (var b = 0; b < this.m.t; ++b) {\n      var c = a[b] & 32767,\n          e = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM,\n          c = b + this.m.t;for (a[c] += this.m.am(0, e, a, b, 0, this.m.t); a[c] >= a.DV;) {\n        a[c] -= a.DV, a[++c]++;\n      }\n    }a.clamp();a.drShiftTo(this.m.t, a);0 <= a.compareTo(this.m) && a.subTo(this.m, a);\n  };y.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };y.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };k.prototype.copyTo = function (a) {\n    for (var b = this.t - 1; 0 <= b; --b) {\n      a[b] = this[b];\n    }a.t = this.t;a.s = this.s;\n  };k.prototype.fromInt = function (a) {\n    this.t = 1;this.s = 0 > a ? -1 : 0;0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;\n  };k.prototype.fromString = function (a, b) {\n    var c;if (16 == b) c = 4;else if (8 == b) c = 3;else if (256 == b) c = 8;else if (2 == b) c = 1;else if (32 == b) c = 5;else if (4 == b) c = 2;else {\n      this.fromRadix(a, b);return;\n    }this.s = this.t = 0;for (var e = a.length, d = !1, g = 0; 0 <= --e;) {\n      var h = 8 == c ? a[e] & 255 : L(a, e);0 > h ? "-" == a.charAt(e) && (d = !0) : (d = !1, 0 == g ? this[this.t++] = h : g + c > this.DB ? (this[this.t - 1] |= (h & (1 << this.DB - g) - 1) << g, this[this.t++] = h >> this.DB - g) : this[this.t - 1] |= h << g, g += c, g >= this.DB && (g -= this.DB));\n    }8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < g && (this[this.t - 1] |= (1 << this.DB - g) - 1 << g));this.clamp();d && k.ZERO.subTo(this, this);\n  };k.prototype.clamp = function () {\n    for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;) {\n      --this.t;\n    }\n  };k.prototype.dlShiftTo = function (a, b) {\n    var c;for (c = this.t - 1; 0 <= c; --c) {\n      b[c + a] = this[c];\n    }for (c = a - 1; 0 <= c; --c) {\n      b[c] = 0;\n    }b.t = this.t + a;b.s = this.s;\n  };k.prototype.drShiftTo = function (a, b) {\n    for (var c = a; c < this.t; ++c) {\n      b[c - a] = this[c];\n    }b.t = Math.max(this.t - a, 0);b.s = this.s;\n  };k.prototype.lShiftTo = function (a, b) {\n    var c = a % this.DB,\n        e = this.DB - c,\n        d = (1 << e) - 1,\n        g = Math.floor(a / this.DB),\n        h = this.s << c & this.DM,\n        l;for (l = this.t - 1; 0 <= l; --l) {\n      b[l + g + 1] = this[l] >> e | h, h = (this[l] & d) << c;\n    }for (l = g - 1; 0 <= l; --l) {\n      b[l] = 0;\n    }b[g] = h;b.t = this.t + g + 1;b.s = this.s;b.clamp();\n  };k.prototype.rShiftTo = function (a, b) {\n    b.s = this.s;var c = Math.floor(a / this.DB);if (c >= this.t) b.t = 0;else {\n      var e = a % this.DB,\n          d = this.DB - e,\n          g = (1 << e) - 1;b[0] = this[c] >> e;for (var h = c + 1; h < this.t; ++h) {\n        b[h - c - 1] |= (this[h] & g) << d, b[h - c] = this[h] >> e;\n      }0 < e && (b[this.t - c - 1] |= (this.s & g) << d);b.t = this.t - c;b.clamp();\n    }\n  };k.prototype.subTo = function (a, b) {\n    for (var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;) {\n      e += this[c] - a[c], b[c++] = e & this.DM, e >>= this.DB;\n    }if (a.t < this.t) {\n      for (e -= a.s; c < this.t;) {\n        e += this[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += this.s;\n    } else {\n      for (e += this.s; c < a.t;) {\n        e -= a[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e -= a.s;\n    }b.s = 0 > e ? -1 : 0;-1 > e ? b[c++] = this.DV + e : 0 < e && (b[c++] = e);b.t = c;b.clamp();\n  };k.prototype.multiplyTo = function (a, b) {\n    var c = this.abs(),\n        e = a.abs(),\n        d = c.t;for (b.t = d + e.t; 0 <= --d;) {\n      b[d] = 0;\n    }for (d = 0; d < e.t; ++d) {\n      b[d + c.t] = c.am(0, e[d], b, d, 0, c.t);\n    }b.s = 0;b.clamp();this.s != a.s && k.ZERO.subTo(b, b);\n  };k.prototype.squareTo = function (a) {\n    for (var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;) {\n      a[c] = 0;\n    }for (c = 0; c < b.t - 1; ++c) {\n      var e = b.am(c, b[c], a, 2 * c, 0, 1);(a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, e, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);\n    }0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));a.s = 0;a.clamp();\n  };k.prototype.divRemTo = function (a, b, c) {\n    var e = a.abs();if (!(0 >= e.t)) {\n      var d = this.abs();if (d.t < e.t) null != b && b.fromInt(0), null != c && this.copyTo(c);else {\n        null == c && (c = q());var g = q(),\n            h = this.s;a = a.s;var l = this.DB - C(e[e.t - 1]);0 < l ? (e.lShiftTo(l, g), d.lShiftTo(l, c)) : (e.copyTo(g), d.copyTo(c));e = g.t;d = g[e - 1];if (0 != d) {\n          var z = d * (1 << this.F1) + (1 < e ? g[e - 2] >> this.F2 : 0),\n              n = this.FV / z,\n              z = (1 << this.F1) / z,\n              U = 1 << this.F2,\n              m = c.t,\n              p = m - e,\n              s = null == b ? q() : b;g.dlShiftTo(p, s);0 <= c.compareTo(s) && (c[c.t++] = 1, c.subTo(s, c));k.ONE.dlShiftTo(e, s);for (s.subTo(g, g); g.t < e;) {\n            g[g.t++] = 0;\n          }for (; 0 <= --p;) {\n            var r = c[--m] == d ? this.DM : Math.floor(c[m] * n + (c[m - 1] + U) * z);if ((c[m] += g.am(0, r, c, p, 0, e)) < r) for (g.dlShiftTo(p, s), c.subTo(s, c); c[m] < --r;) {\n              c.subTo(s, c);\n            }\n          }null != b && (c.drShiftTo(e, b), h != a && k.ZERO.subTo(b, b));c.t = e;c.clamp();0 < l && c.rShiftTo(l, c);0 > h && k.ZERO.subTo(c, c);\n        }\n      }\n    }\n  };k.prototype.invDigit = function () {\n    if (1 > this.t) return 0;var a = this[0];if (0 == (a & 1)) return 0;var b = a & 3,\n        b = b * (2 - (a & 15) * b) & 15,\n        b = b * (2 - (a & 255) * b) & 255,\n        b = b * (2 - ((a & 65535) * b & 65535)) & 65535,\n        b = b * (2 - a * b % this.DV) % this.DV;return 0 < b ? this.DV - b : -b;\n  };k.prototype.isEven = function () {\n    return 0 == (0 < this.t ? this[0] & 1 : this.s);\n  };\n  k.prototype.exp = function (a, b) {\n    if (4294967295 < a || 1 > a) return k.ONE;var c = q(),\n        e = q(),\n        d = b.convert(this),\n        g = C(a) - 1;for (d.copyTo(c); 0 <= --g;) {\n      if (b.sqrTo(c, e), 0 < (a & 1 << g)) b.mulTo(e, d, c);else var h = c,\n          c = e,\n          e = h;\n    }return b.revert(c);\n  };k.prototype.toString = function (a) {\n    if (0 > this.s) return "-" + this.negate().toString(a);if (16 == a) a = 4;else if (8 == a) a = 3;else if (2 == a) a = 1;else if (32 == a) a = 5;else if (4 == a) a = 2;else return this.toRadix(a);var b = (1 << a) - 1,\n        c,\n        e = !1,\n        d = "",\n        g = this.t,\n        h = this.DB - g * this.DB % a;if (0 < g--) for (h < this.DB && 0 < (c = this[g] >> h) && (e = !0, d = "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c)); 0 <= g;) {\n      h < a ? (c = (this[g] & (1 << h) - 1) << a - h, c |= this[--g] >> (h += this.DB - a)) : (c = this[g] >> (h -= a) & b, 0 >= h && (h += this.DB, --g)), 0 < c && (e = !0), e && (d += "0123456789abcdefghijklmnopqrstuvwxyz".charAt(c));\n    }return e ? d : "0";\n  };k.prototype.negate = function () {\n    var a = q();k.ZERO.subTo(this, a);return a;\n  };k.prototype.abs = function () {\n    return 0 > this.s ? this.negate() : this;\n  };k.prototype.compareTo = function (a) {\n    var b = this.s - a.s;if (0 != b) return b;var c = this.t,\n        b = c - a.t;if (0 != b) return 0 > this.s ? -b : b;for (; 0 <= --c;) {\n      if (0 != (b = this[c] - a[c])) return b;\n    }return 0;\n  };k.prototype.bitLength = function () {\n    return 0 >= this.t ? 0 : this.DB * (this.t - 1) + C(this[this.t - 1] ^ this.s & this.DM);\n  };k.prototype.mod = function (a) {\n    var b = q();this.abs().divRemTo(a, null, b);0 > this.s && 0 < b.compareTo(k.ZERO) && a.subTo(b, b);return b;\n  };k.prototype.modPowInt = function (a, b) {\n    var c;c = 256 > a || b.isEven() ? new x(b) : new y(b);return this.exp(a, c);\n  };k.ZERO = v(0);k.ONE = v(1);A.prototype.convert = O;A.prototype.revert = O;A.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);\n  };A.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);\n  };w.prototype.convert = function (a) {\n    if (0 > a.s || a.t > 2 * this.m.t) return a.mod(this.m);if (0 > a.compareTo(this.m)) return a;var b = q();a.copyTo(b);this.reduce(b);return b;\n  };w.prototype.revert = function (a) {\n    return a;\n  };w.prototype.reduce = function (a) {\n    a.drShiftTo(this.m.t - 1, this.r2);a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);for (this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);) {\n      a.dAddOffset(1, this.m.t + 1);\n    }for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m);) {\n      a.subTo(this.m, a);\n    }\n  };w.prototype.mulTo = function (a, b, c) {\n    a.multiplyTo(b, c);this.reduce(c);\n  };w.prototype.sqrTo = function (a, b) {\n    a.squareTo(b);this.reduce(b);\n  };var t = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],\n      V = 67108864 / t[t.length - 1];k.prototype.chunkSize = function (a) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(a));\n  };k.prototype.toRadix = function (a) {\n    null == a && (a = 10);if (0 == this.signum() || 2 > a || 36 < a) return "0";var b = this.chunkSize(a),\n        b = Math.pow(a, b),\n        c = v(b),\n        e = q(),\n        d = q(),\n        g = "";for (this.divRemTo(c, e, d); 0 < e.signum();) {\n      g = (b + d.intValue()).toString(a).substr(1) + g, e.divRemTo(c, e, d);\n    }return d.intValue().toString(a) + g;\n  };k.prototype.fromRadix = function (a, b) {\n    this.fromInt(0);null == b && (b = 10);for (var c = this.chunkSize(b), e = Math.pow(b, c), d = !1, g = 0, h = 0, l = 0; l < a.length; ++l) {\n      var z = L(a, l);0 > z ? "-" == a.charAt(l) && 0 == this.signum() && (d = !0) : (h = b * h + z, ++g >= c && (this.dMultiply(e), this.dAddOffset(h, 0), h = g = 0));\n    }0 < g && (this.dMultiply(Math.pow(b, g)), this.dAddOffset(h, 0));d && k.ZERO.subTo(this, this);\n  };k.prototype.fromNumber = function (a, b, c) {\n    if ("number" == typeof b) {\n      if (2 > a) this.fromInt(1);else for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(k.ONE.shiftLeft(a - 1), I, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);) {\n        this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(k.ONE.shiftLeft(a - 1), this);\n      }\n    } else {\n      c = [];var e = a & 7;c.length = (a >> 3) + 1;b.nextBytes(c);c[0] = 0 < e ? c[0] & (1 << e) - 1 : 0;this.fromString(c, 256);\n    }\n  };k.prototype.bitwiseTo = function (a, b, c) {\n    var e,\n        d,\n        g = Math.min(a.t, this.t);for (e = 0; e < g; ++e) {\n      c[e] = b(this[e], a[e]);\n    }if (a.t < this.t) {\n      d = a.s & this.DM;for (e = g; e < this.t; ++e) {\n        c[e] = b(this[e], d);\n      }c.t = this.t;\n    } else {\n      d = this.s & this.DM;for (e = g; e < a.t; ++e) {\n        c[e] = b(d, a[e]);\n      }c.t = a.t;\n    }c.s = b(this.s, a.s);c.clamp();\n  };k.prototype.changeBit = function (a, b) {\n    var c = k.ONE.shiftLeft(a);this.bitwiseTo(c, b, c);return c;\n  };k.prototype.addTo = function (a, b) {\n    for (var c = 0, e = 0, d = Math.min(a.t, this.t); c < d;) {\n      e += this[c] + a[c], b[c++] = e & this.DM, e >>= this.DB;\n    }if (a.t < this.t) {\n      for (e += a.s; c < this.t;) {\n        e += this[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += this.s;\n    } else {\n      for (e += this.s; c < a.t;) {\n        e += a[c], b[c++] = e & this.DM, e >>= this.DB;\n      }e += a.s;\n    }b.s = 0 > e ? -1 : 0;0 < e ? b[c++] = e : -1 > e && (b[c++] = this.DV + e);b.t = c;b.clamp();\n  };k.prototype.dMultiply = function (a) {\n    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);++this.t;this.clamp();\n  };k.prototype.dAddOffset = function (a, b) {\n    if (0 != a) {\n      for (; this.t <= b;) {\n        this[this.t++] = 0;\n      }for (this[b] += a; this[b] >= this.DV;) {\n        this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];\n      }\n    }\n  };k.prototype.multiplyLowerTo = function (a, b, c) {\n    var e = Math.min(this.t + a.t, b);c.s = 0;for (c.t = e; 0 < e;) {\n      c[--e] = 0;\n    }var d;for (d = c.t - this.t; e < d; ++e) {\n      c[e + this.t] = this.am(0, a[e], c, e, 0, this.t);\n    }for (d = Math.min(a.t, b); e < d; ++e) {\n      this.am(0, a[e], c, e, 0, b - e);\n    }c.clamp();\n  };k.prototype.multiplyUpperTo = function (a, b, c) {\n    --b;var e = c.t = this.t + a.t - b;for (c.s = 0; 0 <= --e;) {\n      c[e] = 0;\n    }for (e = Math.max(b - this.t, 0); e < a.t; ++e) {\n      c[this.t + e - b] = this.am(b - e, a[e], c, 0, 0, this.t + e - b);\n    }c.clamp();c.drShiftTo(1, c);\n  };k.prototype.modInt = function (a) {\n    if (0 >= a) return 0;var b = this.DV % a,\n        c = 0 > this.s ? a - 1 : 0;if (0 < this.t) if (0 == b) c = this[0] % a;else for (var e = this.t - 1; 0 <= e; --e) {\n      c = (b * c + this[e]) % a;\n    }return c;\n  };k.prototype.millerRabin = function (a) {\n    var b = this.subtract(k.ONE),\n        c = b.getLowestSetBit();if (0 >= c) return !1;var e = b.shiftRight(c);a = a + 1 >> 1;a > t.length && (a = t.length);for (var d = q(), g = 0; g < a; ++g) {\n      d.fromInt(t[Math.floor(Math.random() * t.length)]);var h = d.modPow(e, this);if (0 != h.compareTo(k.ONE) && 0 != h.compareTo(b)) {\n        for (var l = 1; l++ < c && 0 != h.compareTo(b);) {\n          if (h = h.modPowInt(2, this), 0 == h.compareTo(k.ONE)) return !1;\n        }if (0 != h.compareTo(b)) return !1;\n      }\n    }return !0;\n  };\n  k.prototype.clone = function () {\n    var a = q();this.copyTo(a);return a;\n  };k.prototype.intValue = function () {\n    if (0 > this.s) {\n      if (1 == this.t) return this[0] - this.DV;if (0 == this.t) return -1;\n    } else {\n      if (1 == this.t) return this[0];if (0 == this.t) return 0;\n    }return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];\n  };k.prototype.byteValue = function () {\n    return 0 == this.t ? this.s : this[0] << 24 >> 24;\n  };k.prototype.shortValue = function () {\n    return 0 == this.t ? this.s : this[0] << 16 >> 16;\n  };k.prototype.signum = function () {\n    return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;\n  };k.prototype.toByteArray = function () {\n    var a = this.t,\n        b = [];b[0] = this.s;var c = this.DB - a * this.DB % 8,\n        e,\n        d = 0;if (0 < a--) for (c < this.DB && (e = this[a] >> c) != (this.s & this.DM) >> c && (b[d++] = e | this.s << this.DB - c); 0 <= a;) {\n      if (8 > c ? (e = (this[a] & (1 << c) - 1) << 8 - c, e |= this[--a] >> (c += this.DB - 8)) : (e = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (e & 128) && (e |= -256), 0 == d && (this.s & 128) != (e & 128) && ++d, 0 < d || e != this.s) b[d++] = e;\n    }return b;\n  };k.prototype.equals = function (a) {\n    return 0 == this.compareTo(a);\n  };k.prototype.min = function (a) {\n    return 0 > this.compareTo(a) ? this : a;\n  };k.prototype.max = function (a) {\n    return 0 < this.compareTo(a) ? this : a;\n  };k.prototype.and = function (a) {\n    var b = q();this.bitwiseTo(a, T, b);return b;\n  };k.prototype.or = function (a) {\n    var b = q();this.bitwiseTo(a, I, b);return b;\n  };k.prototype.xor = function (a) {\n    var b = q();this.bitwiseTo(a, M, b);return b;\n  };k.prototype.andNot = function (a) {\n    var b = q();this.bitwiseTo(a, N, b);return b;\n  };k.prototype.not = function () {\n    for (var a = q(), b = 0; b < this.t; ++b) {\n      a[b] = this.DM & ~this[b];\n    }a.t = this.t;a.s = ~this.s;return a;\n  };k.prototype.shiftLeft = function (a) {\n    var b = q();0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);return b;\n  };k.prototype.shiftRight = function (a) {\n    var b = q();0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);return b;\n  };k.prototype.getLowestSetBit = function () {\n    for (var a = 0; a < this.t; ++a) {\n      if (0 != this[a]) {\n        var b = a * this.DB;a = this[a];if (0 == a) a = -1;else {\n          var c = 0;0 == (a & 65535) && (a >>= 16, c += 16);0 == (a & 255) && (a >>= 8, c += 8);0 == (a & 15) && (a >>= 4, c += 4);0 == (a & 3) && (a >>= 2, c += 2);0 == (a & 1) && ++c;a = c;\n        }return b + a;\n      }\n    }return 0 > this.s ? this.t * this.DB : -1;\n  };k.prototype.bitCount = function () {\n    for (var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c) {\n      for (var e = this[c] ^ b, d = 0; 0 != e;) {\n        e &= e - 1, ++d;\n      }a += d;\n    }return a;\n  };k.prototype.testBit = function (a) {\n    var b = Math.floor(a / this.DB);return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);\n  };k.prototype.setBit = function (a) {\n    return this.changeBit(a, I);\n  };k.prototype.clearBit = function (a) {\n    return this.changeBit(a, N);\n  };k.prototype.flipBit = function (a) {\n    return this.changeBit(a, M);\n  };k.prototype.add = function (a) {\n    var b = q();this.addTo(a, b);return b;\n  };k.prototype.subtract = function (a) {\n    var b = q();this.subTo(a, b);return b;\n  };\n  k.prototype.multiply = function (a) {\n    var b = q();this.multiplyTo(a, b);return b;\n  };k.prototype.divide = function (a) {\n    var b = q();this.divRemTo(a, b, null);return b;\n  };k.prototype.remainder = function (a) {\n    var b = q();this.divRemTo(a, null, b);return b;\n  };k.prototype.divideAndRemainder = function (a) {\n    var b = q(),\n        c = q();this.divRemTo(a, b, c);return [b, c];\n  };k.prototype.modPow = function (a, b) {\n    var c = a.bitLength(),\n        e,\n        d = v(1),\n        g;if (0 >= c) return d;e = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;g = 8 > c ? new x(b) : b.isEven() ? new w(b) : new y(b);var h = [],\n        l = 3,\n        k = e - 1,\n        n = (1 << e) - 1;h[1] = g.convert(this);if (1 < e) for (c = q(), g.sqrTo(h[1], c); l <= n;) {\n      h[l] = q(), g.mulTo(c, h[l - 2], h[l]), l += 2;\n    }for (var m = a.t - 1, p, r = !0, s = q(), c = C(a[m]) - 1; 0 <= m;) {\n      c >= k ? p = a[m] >> c - k & n : (p = (a[m] & (1 << c + 1) - 1) << k - c, 0 < m && (p |= a[m - 1] >> this.DB + c - k));for (l = e; 0 == (p & 1);) {\n        p >>= 1, --l;\n      }0 > (c -= l) && (c += this.DB, --m);if (r) h[p].copyTo(d), r = !1;else {\n        for (; 1 < l;) {\n          g.sqrTo(d, s), g.sqrTo(s, d), l -= 2;\n        }0 < l ? g.sqrTo(d, s) : (l = d, d = s, s = l);g.mulTo(s, h[p], d);\n      }for (; 0 <= m && 0 == (a[m] & 1 << c);) {\n        g.sqrTo(d, s), l = d, d = s, s = l, 0 > --c && (c = this.DB - 1, --m);\n      }\n    }return g.revert(d);\n  };k.prototype.modInverse = function (a) {\n    var b = a.isEven();if (this.isEven() && b || 0 == a.signum()) return k.ZERO;for (var c = a.clone(), e = this.clone(), d = v(1), g = v(0), h = v(0), l = v(1); 0 != c.signum();) {\n      for (; c.isEven();) {\n        c.rShiftTo(1, c), b ? (d.isEven() && g.isEven() || (d.addTo(this, d), g.subTo(a, g)), d.rShiftTo(1, d)) : g.isEven() || g.subTo(a, g), g.rShiftTo(1, g);\n      }for (; e.isEven();) {\n        e.rShiftTo(1, e), b ? (h.isEven() && l.isEven() || (h.addTo(this, h), l.subTo(a, l)), h.rShiftTo(1, h)) : l.isEven() || l.subTo(a, l), l.rShiftTo(1, l);\n      }0 <= c.compareTo(e) ? (c.subTo(e, c), b && d.subTo(h, d), g.subTo(l, g)) : (e.subTo(c, e), b && h.subTo(d, h), l.subTo(g, l));\n    }if (0 != e.compareTo(k.ONE)) return k.ZERO;if (0 <= l.compareTo(a)) return l.subtract(a);if (0 > l.signum()) l.addTo(a, l);else return l;return 0 > l.signum() ? l.add(a) : l;\n  };k.prototype.pow = function (a) {\n    return this.exp(a, new A());\n  };k.prototype.gcd = function (a) {\n    var b = 0 > this.s ? this.negate() : this.clone();a = 0 > a.s ? a.negate() : a.clone();if (0 > b.compareTo(a)) {\n      var c = b,\n          b = a;a = c;\n    }var c = b.getLowestSetBit(),\n        e = a.getLowestSetBit();if (0 > e) return b;c < e && (e = c);0 < e && (b.rShiftTo(e, b), a.rShiftTo(e, a));for (; 0 < b.signum();) {\n      0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));\n    }0 < e && a.lShiftTo(e, a);return a;\n  };k.prototype.isProbablePrime = function (a) {\n    var b,\n        c = this.abs();if (1 == c.t && c[0] <= t[t.length - 1]) {\n      for (b = 0; b < t.length; ++b) {\n        if (c[0] == t[b]) return !0;\n      }return !1;\n    }if (c.isEven()) return !1;for (b = 1; b < t.length;) {\n      for (var e = t[b], d = b + 1; d < t.length && e < V;) {\n        e *= t[d++];\n      }for (e = c.modInt(e); b < d;) {\n        if (0 == e % t[b++]) return !1;\n      }\n    }return c.millerRabin(a);\n  };k.prototype.square = function () {\n    var a = q();this.squareTo(a);return a;\n  };var m = k;m.prototype.IsNegative = function () {\n    return -1 == this.compareTo(m.ZERO) ? !0 : !1;\n  };m.op_Equality = function (a, b) {\n    return 0 == a.compareTo(b) ? !0 : !1;\n  };m.op_Inequality = function (a, b) {\n    return 0 != a.compareTo(b) ? !0 : !1;\n  };m.op_GreaterThan = function (a, b) {\n    return 0 < a.compareTo(b) ? !0 : !1;\n  };m.op_LessThan = function (a, b) {\n    return 0 > a.compareTo(b) ? !0 : !1;\n  };m.op_Addition = function (a, b) {\n    return new m(a).add(new m(b));\n  };m.op_Subtraction = function (a, b) {\n    return new m(a).subtract(new m(b));\n  };m.Int128Mul = function (a, b) {\n    return new m(a).multiply(new m(b));\n  };m.op_Division = function (a, b) {\n    return a.divide(b);\n  };m.prototype.ToDouble = function () {\n    return parseFloat(this.toString());\n  };if ("undefined" == typeof K) var K = function K(a, b) {\n    var c;if ("undefined" == typeof Object.getOwnPropertyNames) for (c in b.prototype) {\n      if ("undefined" == typeof a.prototype[c] || a.prototype[c] == Object.prototype[c]) a.prototype[c] = b.prototype[c];\n    } else for (var e = Object.getOwnPropertyNames(b.prototype), d = 0; d < e.length; d++) {\n      "undefined" == typeof Object.getOwnPropertyDescriptor(a.prototype, e[d]) && Object.defineProperty(a.prototype, e[d], Object.getOwnPropertyDescriptor(b.prototype, e[d]));\n    }for (c in b) {\n      "undefined" == typeof a[c] && (a[c] = b[c]);\n    }a.$baseCtor = b;\n  };d.Path = function () {\n    return [];\n  };d.Paths = function () {\n    return [];\n  };d.DoublePoint = function () {\n    var a = arguments;this.Y = this.X = 0;1 == a.length ? (this.X = a[0].X, this.Y = a[0].Y) : 2 == a.length && (this.X = a[0], this.Y = a[1]);\n  };d.DoublePoint0 = function () {\n    this.Y = this.X = 0;\n  };d.DoublePoint1 = function (a) {\n    this.X = a.X;this.Y = a.Y;\n  };d.DoublePoint2 = function (a, b) {\n    this.X = a;this.Y = b;\n  };d.PolyNode = function () {\n    this.m_Parent = null;this.m_polygon = new d.Path();this.m_endtype = this.m_jointype = this.m_Index = 0;this.m_Childs = [];this.IsOpen = !1;\n  };d.PolyNode.prototype.IsHoleNode = function () {\n    for (var a = !0, b = this.m_Parent; null !== b;) {\n      a = !a, b = b.m_Parent;\n    }return a;\n  };d.PolyNode.prototype.ChildCount = function () {\n    return this.m_Childs.length;\n  };d.PolyNode.prototype.Contour = function () {\n    return this.m_polygon;\n  };d.PolyNode.prototype.AddChild = function (a) {\n    var b = this.m_Childs.length;this.m_Childs.push(a);a.m_Parent = this;a.m_Index = b;\n  };d.PolyNode.prototype.GetNext = function () {\n    return 0 < this.m_Childs.length ? this.m_Childs[0] : this.GetNextSiblingUp();\n  };d.PolyNode.prototype.GetNextSiblingUp = function () {\n    return null === this.m_Parent ? null : this.m_Index == this.m_Parent.m_Childs.length - 1 ? this.m_Parent.GetNextSiblingUp() : this.m_Parent.m_Childs[this.m_Index + 1];\n  };d.PolyNode.prototype.Childs = function () {\n    return this.m_Childs;\n  };d.PolyNode.prototype.Parent = function () {\n    return this.m_Parent;\n  };\n  d.PolyNode.prototype.IsHole = function () {\n    return this.IsHoleNode();\n  };d.PolyTree = function () {\n    this.m_AllPolys = [];d.PolyNode.call(this);\n  };d.PolyTree.prototype.Clear = function () {\n    for (var a = 0, b = this.m_AllPolys.length; a < b; a++) {\n      this.m_AllPolys[a] = null;\n    }this.m_AllPolys.length = 0;this.m_Childs.length = 0;\n  };d.PolyTree.prototype.GetFirst = function () {\n    return 0 < this.m_Childs.length ? this.m_Childs[0] : null;\n  };d.PolyTree.prototype.Total = function () {\n    return this.m_AllPolys.length;\n  };K(d.PolyTree, d.PolyNode);d.Math_Abs_Int64 = d.Math_Abs_Int32 = d.Math_Abs_Double = function (a) {\n    return Math.abs(a);\n  };d.Math_Max_Int32_Int32 = function (a, b) {\n    return Math.max(a, b);\n  };d.Cast_Int32 = p || G || J ? function (a) {\n    return a | 0;\n  } : function (a) {\n    return ~~a;\n  };d.Cast_Int64 = E ? function (a) {\n    return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : ~~a;\n  } : F && "function" == typeof Number.toInteger ? function (a) {\n    return Number.toInteger(a);\n  } : P || H ? function (a) {\n    return parseInt(a, 10);\n  } : p ? function (a) {\n    return -2147483648 > a || 2147483647 < a ? 0 > a ? Math.ceil(a) : Math.floor(a) : a | 0;\n  } : function (a) {\n    return 0 > a ? Math.ceil(a) : Math.floor(a);\n  };d.Clear = function (a) {\n    a.length = 0;\n  };d.PI = 3.141592653589793;d.PI2 = 6.283185307179586;d.IntPoint = function () {\n    var a;a = arguments;var b = a.length;this.Y = this.X = 0;2 == b ? (this.X = a[0], this.Y = a[1]) : 1 == b ? a[0] instanceof d.DoublePoint ? (a = a[0], this.X = d.Clipper.Round(a.X), this.Y = d.Clipper.Round(a.Y)) : (a = a[0], this.X = a.X, this.Y = a.Y) : this.Y = this.X = 0;\n  };d.IntPoint.op_Equality = function (a, b) {\n    return a.X == b.X && a.Y == b.Y;\n  };d.IntPoint.op_Inequality = function (a, b) {\n    return a.X != b.X || a.Y != b.Y;\n  };d.IntPoint0 = function () {\n    this.Y = this.X = 0;\n  };d.IntPoint1 = function (a) {\n    this.X = a.X;this.Y = a.Y;\n  };d.IntPoint1dp = function (a) {\n    this.X = d.Clipper.Round(a.X);this.Y = d.Clipper.Round(a.Y);\n  };d.IntPoint2 = function (a, b) {\n    this.X = a;this.Y = b;\n  };d.IntRect = function () {\n    var a = arguments,\n        b = a.length;4 == b ? (this.left = a[0], this.top = a[1], this.right = a[2], this.bottom = a[3]) : 1 == b ? (this.left = ir.left, this.top = ir.top, this.right = ir.right, this.bottom = ir.bottom) : this.bottom = this.right = this.top = this.left = 0;\n  };d.IntRect0 = function () {\n    this.bottom = this.right = this.top = this.left = 0;\n  };d.IntRect1 = function (a) {\n    this.left = a.left;this.top = a.top;this.right = a.right;this.bottom = a.bottom;\n  };d.IntRect4 = function (a, b, c, e) {\n    this.left = a;this.top = b;this.right = c;this.bottom = e;\n  };d.ClipType = { ctIntersection: 0, ctUnion: 1, ctDifference: 2, ctXor: 3 };d.PolyType = { ptSubject: 0, ptClip: 1 };d.PolyFillType = { pftEvenOdd: 0, pftNonZero: 1, pftPositive: 2, pftNegative: 3 };d.JoinType = { jtSquare: 0, jtRound: 1, jtMiter: 2 };d.EndType = { etOpenSquare: 0, etOpenRound: 1, etOpenButt: 2, etClosedLine: 3, etClosedPolygon: 4 };d.EdgeSide = { esLeft: 0, esRight: 1 };d.Direction = { dRightToLeft: 0, dLeftToRight: 1 };d.TEdge = function () {\n    this.Bot = new d.IntPoint();this.Curr = new d.IntPoint();this.Top = new d.IntPoint();this.Delta = new d.IntPoint();this.Dx = 0;this.PolyTyp = d.PolyType.ptSubject;this.Side = d.EdgeSide.esLeft;this.OutIdx = this.WindCnt2 = this.WindCnt = this.WindDelta = 0;this.PrevInSEL = this.NextInSEL = this.PrevInAEL = this.NextInAEL = this.NextInLML = this.Prev = this.Next = null;\n  };d.IntersectNode = function () {\n    this.Edge2 = this.Edge1 = null;this.Pt = new d.IntPoint();\n  };d.MyIntersectNodeSort = function () {};d.MyIntersectNodeSort.Compare = function (a, b) {\n    return b.Pt.Y - a.Pt.Y;\n  };d.LocalMinima = function () {\n    this.Y = 0;this.Next = this.RightBound = this.LeftBound = null;\n  };d.Scanbeam = function () {\n    this.Y = 0;this.Next = null;\n  };d.OutRec = function () {\n    this.Idx = 0;this.IsOpen = this.IsHole = !1;this.PolyNode = this.BottomPt = this.Pts = this.FirstLeft = null;\n  };d.OutPt = function () {\n    this.Idx = 0;this.Pt = new d.IntPoint();this.Prev = this.Next = null;\n  };d.Join = function () {\n    this.OutPt2 = this.OutPt1 = null;this.OffPt = new d.IntPoint();\n  };d.ClipperBase = function () {\n    this.m_CurrentLM = this.m_MinimaList = null;this.m_edges = [];this.PreserveCollinear = this.m_HasOpenPaths = this.m_UseFullRange = !1;this.m_CurrentLM = this.m_MinimaList = null;this.m_HasOpenPaths = this.m_UseFullRange = !1;\n  };d.ClipperBase.horizontal = -9007199254740992;d.ClipperBase.Skip = -2;d.ClipperBase.Unassigned = -1;d.ClipperBase.tolerance = 1E-20;d.ClipperBase.loRange = 47453132;d.ClipperBase.hiRange = 0xfffffffffffff;d.ClipperBase.near_zero = function (a) {\n    return a > -d.ClipperBase.tolerance && a < d.ClipperBase.tolerance;\n  };d.ClipperBase.IsHorizontal = function (a) {\n    return 0 === a.Delta.Y;\n  };\n  d.ClipperBase.prototype.PointIsVertex = function (a, b) {\n    var c = b;do {\n      if (d.IntPoint.op_Equality(c.Pt, a)) return !0;c = c.Next;\n    } while (c != b);return !1;\n  };d.ClipperBase.prototype.PointOnLineSegment = function (a, b, c, e) {\n    return e ? a.X == b.X && a.Y == b.Y || a.X == c.X && a.Y == c.Y || a.X > b.X == a.X < c.X && a.Y > b.Y == a.Y < c.Y && m.op_Equality(m.Int128Mul(a.X - b.X, c.Y - b.Y), m.Int128Mul(c.X - b.X, a.Y - b.Y)) : a.X == b.X && a.Y == b.Y || a.X == c.X && a.Y == c.Y || a.X > b.X == a.X < c.X && a.Y > b.Y == a.Y < c.Y && (a.X - b.X) * (c.Y - b.Y) == (c.X - b.X) * (a.Y - b.Y);\n  };d.ClipperBase.prototype.PointOnPolygon = function (a, b, c) {\n    for (var e = b;;) {\n      if (this.PointOnLineSegment(a, e.Pt, e.Next.Pt, c)) return !0;e = e.Next;if (e == b) break;\n    }return !1;\n  };d.ClipperBase.prototype.SlopesEqual = d.ClipperBase.SlopesEqual = function () {\n    var a = arguments,\n        b = a.length,\n        c,\n        e,\n        f;if (3 == b) return b = a[0], c = a[1], (a = a[2]) ? m.op_Equality(m.Int128Mul(b.Delta.Y, c.Delta.X), m.Int128Mul(b.Delta.X, c.Delta.Y)) : d.Cast_Int64(b.Delta.Y * c.Delta.X) == d.Cast_Int64(b.Delta.X * c.Delta.Y);if (4 == b) return b = a[0], c = a[1], e = a[2], (a = a[3]) ? m.op_Equality(m.Int128Mul(b.Y - c.Y, c.X - e.X), m.Int128Mul(b.X - c.X, c.Y - e.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (c.X - e.X)) - d.Cast_Int64((b.X - c.X) * (c.Y - e.Y));b = a[0];c = a[1];e = a[2];f = a[3];return (a = a[4]) ? m.op_Equality(m.Int128Mul(b.Y - c.Y, e.X - f.X), m.Int128Mul(b.X - c.X, e.Y - f.Y)) : 0 === d.Cast_Int64((b.Y - c.Y) * (e.X - f.X)) - d.Cast_Int64((b.X - c.X) * (e.Y - f.Y));\n  };d.ClipperBase.SlopesEqual3 = function (a, b, c) {\n    return c ? m.op_Equality(m.Int128Mul(a.Delta.Y, b.Delta.X), m.Int128Mul(a.Delta.X, b.Delta.Y)) : d.Cast_Int64(a.Delta.Y * b.Delta.X) == d.Cast_Int64(a.Delta.X * b.Delta.Y);\n  };d.ClipperBase.SlopesEqual4 = function (a, b, c, e) {\n    return e ? m.op_Equality(m.Int128Mul(a.Y - b.Y, b.X - c.X), m.Int128Mul(a.X - b.X, b.Y - c.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (b.X - c.X)) - d.Cast_Int64((a.X - b.X) * (b.Y - c.Y));\n  };d.ClipperBase.SlopesEqual5 = function (a, b, c, e, f) {\n    return f ? m.op_Equality(m.Int128Mul(a.Y - b.Y, c.X - e.X), m.Int128Mul(a.X - b.X, c.Y - e.Y)) : 0 === d.Cast_Int64((a.Y - b.Y) * (c.X - e.X)) - d.Cast_Int64((a.X - b.X) * (c.Y - e.Y));\n  };d.ClipperBase.prototype.Clear = function () {\n    this.DisposeLocalMinimaList();for (var a = 0, b = this.m_edges.length; a < b; ++a) {\n      for (var c = 0, e = this.m_edges[a].length; c < e; ++c) {\n        this.m_edges[a][c] = null;\n      }d.Clear(this.m_edges[a]);\n    }d.Clear(this.m_edges);this.m_HasOpenPaths = this.m_UseFullRange = !1;\n  };d.ClipperBase.prototype.DisposeLocalMinimaList = function () {\n    for (; null !== this.m_MinimaList;) {\n      var a = this.m_MinimaList.Next;this.m_MinimaList = null;this.m_MinimaList = a;\n    }this.m_CurrentLM = null;\n  };d.ClipperBase.prototype.RangeTest = function (a, b) {\n    if (b.Value) (a.X > d.ClipperBase.hiRange || a.Y > d.ClipperBase.hiRange || -a.X > d.ClipperBase.hiRange || -a.Y > d.ClipperBase.hiRange) && d.Error("Coordinate outside allowed range in RangeTest().");else if (a.X > d.ClipperBase.loRange || a.Y > d.ClipperBase.loRange || -a.X > d.ClipperBase.loRange || -a.Y > d.ClipperBase.loRange) b.Value = !0, this.RangeTest(a, b);\n  };d.ClipperBase.prototype.InitEdge = function (a, b, c, e) {\n    a.Next = b;a.Prev = c;a.Curr.X = e.X;a.Curr.Y = e.Y;a.OutIdx = -1;\n  };d.ClipperBase.prototype.InitEdge2 = function (a, b) {\n    a.Curr.Y >= a.Next.Curr.Y ? (a.Bot.X = a.Curr.X, a.Bot.Y = a.Curr.Y, a.Top.X = a.Next.Curr.X, a.Top.Y = a.Next.Curr.Y) : (a.Top.X = a.Curr.X, a.Top.Y = a.Curr.Y, a.Bot.X = a.Next.Curr.X, a.Bot.Y = a.Next.Curr.Y);this.SetDx(a);a.PolyTyp = b;\n  };d.ClipperBase.prototype.FindNextLocMin = function (a) {\n    for (var b;;) {\n      for (; d.IntPoint.op_Inequality(a.Bot, a.Prev.Bot) || d.IntPoint.op_Equality(a.Curr, a.Top);) {\n        a = a.Next;\n      }if (a.Dx != d.ClipperBase.horizontal && a.Prev.Dx != d.ClipperBase.horizontal) break;for (; a.Prev.Dx == d.ClipperBase.horizontal;) {\n        a = a.Prev;\n      }for (b = a; a.Dx == d.ClipperBase.horizontal;) {\n        a = a.Next;\n      }if (a.Top.Y != a.Prev.Bot.Y) {\n        b.Prev.Bot.X < a.Bot.X && (a = b);break;\n      }\n    }return a;\n  };d.ClipperBase.prototype.ProcessBound = function (a, b) {\n    var c = a,\n        e = a,\n        f;a.Dx == d.ClipperBase.horizontal && (f = b ? a.Prev.Bot.X : a.Next.Bot.X, a.Bot.X != f && this.ReverseHorizontal(a));if (e.OutIdx != d.ClipperBase.Skip) if (b) {\n      for (; e.Top.Y == e.Next.Bot.Y && e.Next.OutIdx != d.ClipperBase.Skip;) {\n        e = e.Next;\n      }if (e.Dx == d.ClipperBase.horizontal && e.Next.OutIdx != d.ClipperBase.Skip) {\n        for (f = e; f.Prev.Dx == d.ClipperBase.horizontal;) {\n          f = f.Prev;\n        }f.Prev.Top.X == e.Next.Top.X ? b || (e = f.Prev) : f.Prev.Top.X > e.Next.Top.X && (e = f.Prev);\n      }for (; a != e;) {\n        a.NextInLML = a.Next, a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a), a = a.Next;\n      }a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a);e = e.Next;\n    } else {\n      for (; e.Top.Y == e.Prev.Bot.Y && e.Prev.OutIdx != d.ClipperBase.Skip;) {\n        e = e.Prev;\n      }if (e.Dx == d.ClipperBase.horizontal && e.Prev.OutIdx != d.ClipperBase.Skip) {\n        for (f = e; f.Next.Dx == d.ClipperBase.horizontal;) {\n          f = f.Next;\n        }f.Next.Top.X == e.Prev.Top.X ? b || (e = f.Next) : f.Next.Top.X > e.Prev.Top.X && (e = f.Next);\n      }for (; a != e;) {\n        a.NextInLML = a.Prev, a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Next.Top.X && this.ReverseHorizontal(a), a = a.Prev;\n      }a.Dx == d.ClipperBase.horizontal && a != c && a.Bot.X != a.Next.Top.X && this.ReverseHorizontal(a);e = e.Prev;\n    }if (e.OutIdx == d.ClipperBase.Skip) {\n      a = e;if (b) {\n        for (; a.Top.Y == a.Next.Bot.Y;) {\n          a = a.Next;\n        }for (; a != e && a.Dx == d.ClipperBase.horizontal;) {\n          a = a.Prev;\n        }\n      } else {\n        for (; a.Top.Y == a.Prev.Bot.Y;) {\n          a = a.Prev;\n        }for (; a != e && a.Dx == d.ClipperBase.horizontal;) {\n          a = a.Next;\n        }\n      }a == e ? e = b ? a.Next : a.Prev : (a = b ? e.Next : e.Prev, c = new d.LocalMinima(), c.Next = null, c.Y = a.Bot.Y, c.LeftBound = null, c.RightBound = a, c.RightBound.WindDelta = 0, e = this.ProcessBound(c.RightBound, b), this.InsertLocalMinima(c));\n    }return e;\n  };d.ClipperBase.prototype.AddPath = function (a, b, c) {\n    c || b != d.PolyType.ptClip || d.Error("AddPath: Open paths must be subject.");var e = a.length - 1;if (c) for (; 0 < e && d.IntPoint.op_Equality(a[e], a[0]);) {\n      --e;\n    }for (; 0 < e && d.IntPoint.op_Equality(a[e], a[e - 1]);) {\n      --e;\n    }if (c && 2 > e || !c && 1 > e) return !1;for (var f = [], g = 0; g <= e; g++) {\n      f.push(new d.TEdge());\n    }var h = !0;f[1].Curr.X = a[1].X;f[1].Curr.Y = a[1].Y;var l = { Value: this.m_UseFullRange };this.RangeTest(a[0], l);this.m_UseFullRange = l.Value;l.Value = this.m_UseFullRange;this.RangeTest(a[e], l);this.m_UseFullRange = l.Value;this.InitEdge(f[0], f[1], f[e], a[0]);this.InitEdge(f[e], f[0], f[e - 1], a[e]);for (g = e - 1; 1 <= g; --g) {\n      l.Value = this.m_UseFullRange, this.RangeTest(a[g], l), this.m_UseFullRange = l.Value, this.InitEdge(f[g], f[g + 1], f[g - 1], a[g]);\n    }for (g = a = e = f[0];;) {\n      if (d.IntPoint.op_Equality(a.Curr, a.Next.Curr)) {\n        if (a == a.Next) break;a == e && (e = a.Next);g = a = this.RemoveEdge(a);\n      } else {\n        if (a.Prev == a.Next) break;else if (c && d.ClipperBase.SlopesEqual(a.Prev.Curr, a.Curr, a.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(a.Prev.Curr, a.Curr, a.Next.Curr))) {\n          a == e && (e = a.Next);a = this.RemoveEdge(a);g = a = a.Prev;continue;\n        }a = a.Next;if (a == g) break;\n      }\n    }if (!c && a == a.Next || c && a.Prev == a.Next) return !1;c || (this.m_HasOpenPaths = !0, e.Prev.OutIdx = d.ClipperBase.Skip);a = e;do {\n      this.InitEdge2(a, b), a = a.Next, h && a.Curr.Y != e.Curr.Y && (h = !1);\n    } while (a != e);if (h) {\n      if (c) return !1;a.Prev.OutIdx = d.ClipperBase.Skip;a.Prev.Bot.X < a.Prev.Top.X && this.ReverseHorizontal(a.Prev);\n      b = new d.LocalMinima();b.Next = null;b.Y = a.Bot.Y;b.LeftBound = null;b.RightBound = a;b.RightBound.Side = d.EdgeSide.esRight;for (b.RightBound.WindDelta = 0; a.Next.OutIdx != d.ClipperBase.Skip;) {\n        a.NextInLML = a.Next, a.Bot.X != a.Prev.Top.X && this.ReverseHorizontal(a), a = a.Next;\n      }this.InsertLocalMinima(b);this.m_edges.push(f);return !0;\n    }this.m_edges.push(f);for (h = null;;) {\n      a = this.FindNextLocMin(a);if (a == h) break;else null == h && (h = a);b = new d.LocalMinima();b.Next = null;b.Y = a.Bot.Y;a.Dx < a.Prev.Dx ? (b.LeftBound = a.Prev, b.RightBound = a, f = !1) : (b.LeftBound = a, b.RightBound = a.Prev, f = !0);b.LeftBound.Side = d.EdgeSide.esLeft;b.RightBound.Side = d.EdgeSide.esRight;b.LeftBound.WindDelta = c ? b.LeftBound.Next == b.RightBound ? -1 : 1 : 0;b.RightBound.WindDelta = -b.LeftBound.WindDelta;a = this.ProcessBound(b.LeftBound, f);e = this.ProcessBound(b.RightBound, !f);b.LeftBound.OutIdx == d.ClipperBase.Skip ? b.LeftBound = null : b.RightBound.OutIdx == d.ClipperBase.Skip && (b.RightBound = null);this.InsertLocalMinima(b);f || (a = e);\n    }return !0;\n  };d.ClipperBase.prototype.AddPaths = function (a, b, c) {\n    for (var e = !1, d = 0, g = a.length; d < g; ++d) {\n      this.AddPath(a[d], b, c) && (e = !0);\n    }return e;\n  };d.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (a, b, c) {\n    return d.IntPoint.op_Equality(a, c) || d.IntPoint.op_Equality(a, b) || d.IntPoint.op_Equality(c, b) ? !1 : a.X != c.X ? b.X > a.X == b.X < c.X : b.Y > a.Y == b.Y < c.Y;\n  };d.ClipperBase.prototype.RemoveEdge = function (a) {\n    a.Prev.Next = a.Next;a.Next.Prev = a.Prev;var b = a.Next;a.Prev = null;return b;\n  };d.ClipperBase.prototype.SetDx = function (a) {\n    a.Delta.X = a.Top.X - a.Bot.X;a.Delta.Y = a.Top.Y - a.Bot.Y;a.Dx = 0 === a.Delta.Y ? d.ClipperBase.horizontal : a.Delta.X / a.Delta.Y;\n  };d.ClipperBase.prototype.InsertLocalMinima = function (a) {\n    if (null === this.m_MinimaList) this.m_MinimaList = a;else if (a.Y >= this.m_MinimaList.Y) a.Next = this.m_MinimaList, this.m_MinimaList = a;else {\n      for (var b = this.m_MinimaList; null !== b.Next && a.Y < b.Next.Y;) {\n        b = b.Next;\n      }a.Next = b.Next;b.Next = a;\n    }\n  };d.ClipperBase.prototype.PopLocalMinima = function () {\n    null !== this.m_CurrentLM && (this.m_CurrentLM = this.m_CurrentLM.Next);\n  };d.ClipperBase.prototype.ReverseHorizontal = function (a) {\n    var b = a.Top.X;a.Top.X = a.Bot.X;a.Bot.X = b;\n  };d.ClipperBase.prototype.Reset = function () {\n    this.m_CurrentLM = this.m_MinimaList;if (null != this.m_CurrentLM) for (var a = this.m_MinimaList; null != a;) {\n      var b = a.LeftBound;null != b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, b.Side = d.EdgeSide.esLeft, b.OutIdx = d.ClipperBase.Unassigned);b = a.RightBound;null != b && (b.Curr.X = b.Bot.X, b.Curr.Y = b.Bot.Y, b.Side = d.EdgeSide.esRight, b.OutIdx = d.ClipperBase.Unassigned);a = a.Next;\n    }\n  };d.Clipper = function (a) {\n    "undefined" == typeof a && (a = 0);this.m_PolyOuts = null;this.m_ClipType = d.ClipType.ctIntersection;this.m_IntersectNodeComparer = this.m_IntersectList = this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;this.m_ExecuteLocked = !1;this.m_SubjFillType = this.m_ClipFillType = d.PolyFillType.pftEvenOdd;this.m_GhostJoins = this.m_Joins = null;this.StrictlySimple = this.ReverseSolution = this.m_UsingPolyTree = !1;d.ClipperBase.call(this);this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;this.m_IntersectList = [];this.m_IntersectNodeComparer = d.MyIntersectNodeSort.Compare;this.m_UsingPolyTree = this.m_ExecuteLocked = !1;this.m_PolyOuts = [];this.m_Joins = [];this.m_GhostJoins = [];this.ReverseSolution = 0 !== (1 & a);this.StrictlySimple = 0 !== (2 & a);this.PreserveCollinear = 0 !== (4 & a);\n  };d.Clipper.ioReverseSolution = 1;d.Clipper.ioStrictlySimple = 2;d.Clipper.ioPreserveCollinear = 4;d.Clipper.prototype.Clear = function () {\n    0 !== this.m_edges.length && (this.DisposeAllPolyPts(), d.ClipperBase.prototype.Clear.call(this));\n  };d.Clipper.prototype.DisposeScanbeamList = function () {\n    for (; null !== this.m_Scanbeam;) {\n      var a = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;this.m_Scanbeam = a;\n    }\n  };d.Clipper.prototype.Reset = function () {\n    d.ClipperBase.prototype.Reset.call(this);this.m_SortedEdges = this.m_ActiveEdges = this.m_Scanbeam = null;for (var a = this.m_MinimaList; null !== a;) {\n      this.InsertScanbeam(a.Y), a = a.Next;\n    }\n  };d.Clipper.prototype.InsertScanbeam = function (a) {\n    if (null === this.m_Scanbeam) this.m_Scanbeam = new d.Scanbeam(), this.m_Scanbeam.Next = null, this.m_Scanbeam.Y = a;else if (a > this.m_Scanbeam.Y) {\n      var b = new d.Scanbeam();b.Y = a;b.Next = this.m_Scanbeam;this.m_Scanbeam = b;\n    } else {\n      for (var c = this.m_Scanbeam; null !== c.Next && a <= c.Next.Y;) {\n        c = c.Next;\n      }a != c.Y && (b = new d.Scanbeam(), b.Y = a, b.Next = c.Next, c.Next = b);\n    }\n  };d.Clipper.prototype.Execute = function () {\n    var a = arguments,\n        b = a.length,\n        c = a[1] instanceof d.PolyTree;if (4 != b || c) {\n      if (4 == b && c) {\n        var b = a[0],\n            e = a[1],\n            c = a[2],\n            a = a[3];if (this.m_ExecuteLocked) return !1;this.m_ExecuteLocked = !0;this.m_SubjFillType = c;this.m_ClipFillType = a;this.m_ClipType = b;this.m_UsingPolyTree = !0;try {\n          (f = this.ExecuteInternal()) && this.BuildResult2(e);\n        } finally {\n          this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;\n        }return f;\n      }if (2 == b && !c || 2 == b && c) return b = a[0], e = a[1], this.Execute(b, e, d.PolyFillType.pftEvenOdd, d.PolyFillType.pftEvenOdd);\n    } else {\n      b = a[0];e = a[1];c = a[2];a = a[3];if (this.m_ExecuteLocked) return !1;this.m_HasOpenPaths && d.Error("Error: PolyTree struct is need for open path clipping.");this.m_ExecuteLocked = !0;d.Clear(e);this.m_SubjFillType = c;this.m_ClipFillType = a;this.m_ClipType = b;this.m_UsingPolyTree = !1;try {\n        var f = this.ExecuteInternal();f && this.BuildResult(e);\n      } finally {\n        this.DisposeAllPolyPts(), this.m_ExecuteLocked = !1;\n      }return f;\n    }\n  };d.Clipper.prototype.FixHoleLinkage = function (a) {\n    if (null !== a.FirstLeft && (a.IsHole == a.FirstLeft.IsHole || null === a.FirstLeft.Pts)) {\n      for (var b = a.FirstLeft; null !== b && (b.IsHole == a.IsHole || null === b.Pts);) {\n        b = b.FirstLeft;\n      }a.FirstLeft = b;\n    }\n  };d.Clipper.prototype.ExecuteInternal = function () {\n    try {\n      this.Reset();if (null === this.m_CurrentLM) return !1;var a = this.PopScanbeam();do {\n        this.InsertLocalMinimaIntoAEL(a);d.Clear(this.m_GhostJoins);this.ProcessHorizontals(!1);if (null === this.m_Scanbeam) break;var b = this.PopScanbeam();\n        if (!this.ProcessIntersections(a, b)) return !1;this.ProcessEdgesAtTopOfScanbeam(b);a = b;\n      } while (null !== this.m_Scanbeam || null !== this.m_CurrentLM);for (var a = 0, c = this.m_PolyOuts.length; a < c; a++) {\n        var e = this.m_PolyOuts[a];null === e.Pts || e.IsOpen || (e.IsHole ^ this.ReverseSolution) == 0 < this.Area(e) && this.ReversePolyPtLinks(e.Pts);\n      }this.JoinCommonEdges();a = 0;for (c = this.m_PolyOuts.length; a < c; a++) {\n        e = this.m_PolyOuts[a], null === e.Pts || e.IsOpen || this.FixupOutPolygon(e);\n      }this.StrictlySimple && this.DoSimplePolygons();return !0;\n    } finally {\n      d.Clear(this.m_Joins), d.Clear(this.m_GhostJoins);\n    }\n  };d.Clipper.prototype.PopScanbeam = function () {\n    var a = this.m_Scanbeam.Y;this.m_Scanbeam = this.m_Scanbeam.Next;return a;\n  };d.Clipper.prototype.DisposeAllPolyPts = function () {\n    for (var a = 0, b = this.m_PolyOuts.length; a < b; ++a) {\n      this.DisposeOutRec(a);\n    }d.Clear(this.m_PolyOuts);\n  };d.Clipper.prototype.DisposeOutRec = function (a) {\n    var b = this.m_PolyOuts[a];null !== b.Pts && this.DisposeOutPts(b.Pts);this.m_PolyOuts[a] = null;\n  };d.Clipper.prototype.DisposeOutPts = function (a) {\n    if (null !== a) for (a.Prev.Next = null; null !== a;) {\n      a = a.Next;\n    }\n  };d.Clipper.prototype.AddJoin = function (a, b, c) {\n    var e = new d.Join();e.OutPt1 = a;e.OutPt2 = b;e.OffPt.X = c.X;e.OffPt.Y = c.Y;this.m_Joins.push(e);\n  };d.Clipper.prototype.AddGhostJoin = function (a, b) {\n    var c = new d.Join();c.OutPt1 = a;c.OffPt.X = b.X;c.OffPt.Y = b.Y;this.m_GhostJoins.push(c);\n  };d.Clipper.prototype.InsertLocalMinimaIntoAEL = function (a) {\n    for (; null !== this.m_CurrentLM && this.m_CurrentLM.Y == a;) {\n      var b = this.m_CurrentLM.LeftBound,\n          c = this.m_CurrentLM.RightBound;this.PopLocalMinima();var e = null;null === b ? (this.InsertEdgeIntoAEL(c, null), this.SetWindingCount(c), this.IsContributing(c) && (e = this.AddOutPt(c, c.Bot))) : (null == c ? (this.InsertEdgeIntoAEL(b, null), this.SetWindingCount(b), this.IsContributing(b) && (e = this.AddOutPt(b, b.Bot))) : (this.InsertEdgeIntoAEL(b, null), this.InsertEdgeIntoAEL(c, b), this.SetWindingCount(b), c.WindCnt = b.WindCnt, c.WindCnt2 = b.WindCnt2, this.IsContributing(b) && (e = this.AddLocalMinPoly(b, c, b.Bot))), this.InsertScanbeam(b.Top.Y));null != c && (d.ClipperBase.IsHorizontal(c) ? this.AddEdgeToSEL(c) : this.InsertScanbeam(c.Top.Y));\n      if (null != b && null != c) {\n        if (null !== e && d.ClipperBase.IsHorizontal(c) && 0 < this.m_GhostJoins.length && 0 !== c.WindDelta) for (var f = 0, g = this.m_GhostJoins.length; f < g; f++) {\n          var h = this.m_GhostJoins[f];this.HorzSegmentsOverlap(h.OutPt1.Pt, h.OffPt, c.Bot, c.Top) && this.AddJoin(h.OutPt1, e, h.OffPt);\n        }0 <= b.OutIdx && null !== b.PrevInAEL && b.PrevInAEL.Curr.X == b.Bot.X && 0 <= b.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual(b.PrevInAEL, b, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== b.PrevInAEL.WindDelta && (f = this.AddOutPt(b.PrevInAEL, b.Bot), this.AddJoin(e, f, b.Top));if (b.NextInAEL != c && (0 <= c.OutIdx && 0 <= c.PrevInAEL.OutIdx && d.ClipperBase.SlopesEqual(c.PrevInAEL, c, this.m_UseFullRange) && 0 !== c.WindDelta && 0 !== c.PrevInAEL.WindDelta && (f = this.AddOutPt(c.PrevInAEL, c.Bot), this.AddJoin(e, f, c.Top)), e = b.NextInAEL, null !== e)) for (; e != c;) {\n          this.IntersectEdges(c, e, b.Curr, !1), e = e.NextInAEL;\n        }\n      }\n    }\n  };d.Clipper.prototype.InsertEdgeIntoAEL = function (a, b) {\n    if (null === this.m_ActiveEdges) a.PrevInAEL = null, a.NextInAEL = null, this.m_ActiveEdges = a;else if (null === b && this.E2InsertsBeforeE1(this.m_ActiveEdges, a)) a.PrevInAEL = null, a.NextInAEL = this.m_ActiveEdges, this.m_ActiveEdges = this.m_ActiveEdges.PrevInAEL = a;else {\n      null === b && (b = this.m_ActiveEdges);for (; null !== b.NextInAEL && !this.E2InsertsBeforeE1(b.NextInAEL, a);) {\n        b = b.NextInAEL;\n      }a.NextInAEL = b.NextInAEL;null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = a);a.PrevInAEL = b;b.NextInAEL = a;\n    }\n  };d.Clipper.prototype.E2InsertsBeforeE1 = function (a, b) {\n    return b.Curr.X == a.Curr.X ? b.Top.Y > a.Top.Y ? b.Top.X < d.Clipper.TopX(a, b.Top.Y) : a.Top.X > d.Clipper.TopX(b, a.Top.Y) : b.Curr.X < a.Curr.X;\n  };d.Clipper.prototype.IsEvenOddFillType = function (a) {\n    return a.PolyTyp == d.PolyType.ptSubject ? this.m_SubjFillType == d.PolyFillType.pftEvenOdd : this.m_ClipFillType == d.PolyFillType.pftEvenOdd;\n  };d.Clipper.prototype.IsEvenOddAltFillType = function (a) {\n    return a.PolyTyp == d.PolyType.ptSubject ? this.m_ClipFillType == d.PolyFillType.pftEvenOdd : this.m_SubjFillType == d.PolyFillType.pftEvenOdd;\n  };d.Clipper.prototype.IsContributing = function (a) {\n    var b, c;a.PolyTyp == d.PolyType.ptSubject ? (b = this.m_SubjFillType, c = this.m_ClipFillType) : (b = this.m_ClipFillType, c = this.m_SubjFillType);\n    switch (b) {case d.PolyFillType.pftEvenOdd:\n        if (0 === a.WindDelta && 1 != a.WindCnt) return !1;break;case d.PolyFillType.pftNonZero:\n        if (1 != Math.abs(a.WindCnt)) return !1;break;case d.PolyFillType.pftPositive:\n        if (1 != a.WindCnt) return !1;break;default:\n        if (-1 != a.WindCnt) return !1;}switch (this.m_ClipType) {case d.ClipType.ctIntersection:\n        switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 !== a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 < a.WindCnt2;default:\n            return 0 > a.WindCnt2;}case d.ClipType.ctUnion:\n        switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;}case d.ClipType.ctDifference:\n        if (a.PolyTyp == d.PolyType.ptSubject) switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;} else switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 !== a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 < a.WindCnt2;default:\n            return 0 > a.WindCnt2;}case d.ClipType.ctXor:\n        if (0 === a.WindDelta) switch (c) {case d.PolyFillType.pftEvenOdd:case d.PolyFillType.pftNonZero:\n            return 0 === a.WindCnt2;case d.PolyFillType.pftPositive:\n            return 0 >= a.WindCnt2;default:\n            return 0 <= a.WindCnt2;}}return !0;\n  };d.Clipper.prototype.SetWindingCount = function (a) {\n    for (var b = a.PrevInAEL; null !== b && (b.PolyTyp != a.PolyTyp || 0 === b.WindDelta);) {\n      b = b.PrevInAEL;\n    }if (null === b) a.WindCnt = 0 === a.WindDelta ? 1 : a.WindDelta, a.WindCnt2 = 0, b = this.m_ActiveEdges;else {\n      if (0 === a.WindDelta && this.m_ClipType != d.ClipType.ctUnion) a.WindCnt = 1;else if (this.IsEvenOddFillType(a)) {\n        if (0 === a.WindDelta) {\n          for (var c = !0, e = b.PrevInAEL; null !== e;) {\n            e.PolyTyp == b.PolyTyp && 0 !== e.WindDelta && (c = !c), e = e.PrevInAEL;\n          }a.WindCnt = c ? 0 : 1;\n        } else a.WindCnt = a.WindDelta;\n      } else 0 > b.WindCnt * b.WindDelta ? 1 < Math.abs(b.WindCnt) ? a.WindCnt = 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta : a.WindCnt = 0 === a.WindDelta ? 1 : a.WindDelta : a.WindCnt = 0 === a.WindDelta ? 0 > b.WindCnt ? b.WindCnt - 1 : b.WindCnt + 1 : 0 > b.WindDelta * a.WindDelta ? b.WindCnt : b.WindCnt + a.WindDelta;\n      a.WindCnt2 = b.WindCnt2;b = b.NextInAEL;\n    }if (this.IsEvenOddAltFillType(a)) for (; b != a;) {\n      0 !== b.WindDelta && (a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0), b = b.NextInAEL;\n    } else for (; b != a;) {\n      a.WindCnt2 += b.WindDelta, b = b.NextInAEL;\n    }\n  };d.Clipper.prototype.AddEdgeToSEL = function (a) {\n    null === this.m_SortedEdges ? (this.m_SortedEdges = a, a.PrevInSEL = null, a.NextInSEL = null) : (a.NextInSEL = this.m_SortedEdges, a.PrevInSEL = null, this.m_SortedEdges = this.m_SortedEdges.PrevInSEL = a);\n  };d.Clipper.prototype.CopyAELToSEL = function () {\n    var a = this.m_ActiveEdges;for (this.m_SortedEdges = a; null !== a;) {\n      a.PrevInSEL = a.PrevInAEL, a = a.NextInSEL = a.NextInAEL;\n    }\n  };d.Clipper.prototype.SwapPositionsInAEL = function (a, b) {\n    if (a.NextInAEL != a.PrevInAEL && b.NextInAEL != b.PrevInAEL) {\n      if (a.NextInAEL == b) {\n        var c = b.NextInAEL;null !== c && (c.PrevInAEL = a);var e = a.PrevInAEL;null !== e && (e.NextInAEL = b);b.PrevInAEL = e;b.NextInAEL = a;a.PrevInAEL = b;a.NextInAEL = c;\n      } else b.NextInAEL == a ? (c = a.NextInAEL, null !== c && (c.PrevInAEL = b), e = b.PrevInAEL, null !== e && (e.NextInAEL = a), a.PrevInAEL = e, a.NextInAEL = b, b.PrevInAEL = a, b.NextInAEL = c) : (c = a.NextInAEL, e = a.PrevInAEL, a.NextInAEL = b.NextInAEL, null !== a.NextInAEL && (a.NextInAEL.PrevInAEL = a), a.PrevInAEL = b.PrevInAEL, null !== a.PrevInAEL && (a.PrevInAEL.NextInAEL = a), b.NextInAEL = c, null !== b.NextInAEL && (b.NextInAEL.PrevInAEL = b), b.PrevInAEL = e, null !== b.PrevInAEL && (b.PrevInAEL.NextInAEL = b));null === a.PrevInAEL ? this.m_ActiveEdges = a : null === b.PrevInAEL && (this.m_ActiveEdges = b);\n    }\n  };d.Clipper.prototype.SwapPositionsInSEL = function (a, b) {\n    if (null !== a.NextInSEL || null !== a.PrevInSEL) if (null !== b.NextInSEL || null !== b.PrevInSEL) {\n      if (a.NextInSEL == b) {\n        var c = b.NextInSEL;null !== c && (c.PrevInSEL = a);var e = a.PrevInSEL;null !== e && (e.NextInSEL = b);b.PrevInSEL = e;b.NextInSEL = a;a.PrevInSEL = b;a.NextInSEL = c;\n      } else b.NextInSEL == a ? (c = a.NextInSEL, null !== c && (c.PrevInSEL = b), e = b.PrevInSEL, null !== e && (e.NextInSEL = a), a.PrevInSEL = e, a.NextInSEL = b, b.PrevInSEL = a, b.NextInSEL = c) : (c = a.NextInSEL, e = a.PrevInSEL, a.NextInSEL = b.NextInSEL, null !== a.NextInSEL && (a.NextInSEL.PrevInSEL = a), a.PrevInSEL = b.PrevInSEL, null !== a.PrevInSEL && (a.PrevInSEL.NextInSEL = a), b.NextInSEL = c, null !== b.NextInSEL && (b.NextInSEL.PrevInSEL = b), b.PrevInSEL = e, null !== b.PrevInSEL && (b.PrevInSEL.NextInSEL = b));null === a.PrevInSEL ? this.m_SortedEdges = a : null === b.PrevInSEL && (this.m_SortedEdges = b);\n    }\n  };d.Clipper.prototype.AddLocalMaxPoly = function (a, b, c) {\n    this.AddOutPt(a, c);0 == b.WindDelta && this.AddOutPt(b, c);a.OutIdx == b.OutIdx ? (a.OutIdx = -1, b.OutIdx = -1) : a.OutIdx < b.OutIdx ? this.AppendPolygon(a, b) : this.AppendPolygon(b, a);\n  };d.Clipper.prototype.AddLocalMinPoly = function (a, b, c) {\n    var e, f;d.ClipperBase.IsHorizontal(b) || a.Dx > b.Dx ? (e = this.AddOutPt(a, c), b.OutIdx = a.OutIdx, a.Side = d.EdgeSide.esLeft, b.Side = d.EdgeSide.esRight, f = a, a = f.PrevInAEL == b ? b.PrevInAEL : f.PrevInAEL) : (e = this.AddOutPt(b, c), a.OutIdx = b.OutIdx, a.Side = d.EdgeSide.esRight, b.Side = d.EdgeSide.esLeft, f = b, a = f.PrevInAEL == a ? a.PrevInAEL : f.PrevInAEL);null !== a && 0 <= a.OutIdx && d.Clipper.TopX(a, c.Y) == d.Clipper.TopX(f, c.Y) && d.ClipperBase.SlopesEqual(f, a, this.m_UseFullRange) && 0 !== f.WindDelta && 0 !== a.WindDelta && (c = this.AddOutPt(a, c), this.AddJoin(e, c, f.Top));return e;\n  };d.Clipper.prototype.CreateOutRec = function () {\n    var a = new d.OutRec();a.Idx = -1;a.IsHole = !1;a.IsOpen = !1;a.FirstLeft = null;a.Pts = null;a.BottomPt = null;a.PolyNode = null;this.m_PolyOuts.push(a);a.Idx = this.m_PolyOuts.length - 1;return a;\n  };d.Clipper.prototype.AddOutPt = function (a, b) {\n    var c = a.Side == d.EdgeSide.esLeft;if (0 > a.OutIdx) {\n      var e = this.CreateOutRec();e.IsOpen = 0 === a.WindDelta;var f = new d.OutPt();e.Pts = f;f.Idx = e.Idx;f.Pt.X = b.X;f.Pt.Y = b.Y;f.Next = f;f.Prev = f;e.IsOpen || this.SetHoleState(a, e);a.OutIdx = e.Idx;\n    } else {\n      var e = this.m_PolyOuts[a.OutIdx],\n          g = e.Pts;if (c && d.IntPoint.op_Equality(b, g.Pt)) return g;if (!c && d.IntPoint.op_Equality(b, g.Prev.Pt)) return g.Prev;f = new d.OutPt();f.Idx = e.Idx;f.Pt.X = b.X;f.Pt.Y = b.Y;f.Next = g;f.Prev = g.Prev;f.Prev.Next = f;g.Prev = f;c && (e.Pts = f);\n    }return f;\n  };d.Clipper.prototype.SwapPoints = function (a, b) {\n    var c = new d.IntPoint(a.Value);a.Value.X = b.Value.X;a.Value.Y = b.Value.Y;b.Value.X = c.X;b.Value.Y = c.Y;\n  };d.Clipper.prototype.HorzSegmentsOverlap = function (a, b, c, e) {\n    return a.X > c.X == a.X < e.X ? !0 : b.X > c.X == b.X < e.X ? !0 : c.X > a.X == c.X < b.X ? !0 : e.X > a.X == e.X < b.X ? !0 : a.X == c.X && b.X == e.X ? !0 : a.X == e.X && b.X == c.X ? !0 : !1;\n  };d.Clipper.prototype.InsertPolyPtBetween = function (a, b, c) {\n    var e = new d.OutPt();e.Pt.X = c.X;e.Pt.Y = c.Y;b == a.Next ? (a.Next = e, b.Prev = e, e.Next = b, e.Prev = a) : (b.Next = e, a.Prev = e, e.Next = a, e.Prev = b);return e;\n  };d.Clipper.prototype.SetHoleState = function (a, b) {\n    for (var c = !1, e = a.PrevInAEL; null !== e;) {\n      0 <= e.OutIdx && 0 != e.WindDelta && (c = !c, null === b.FirstLeft && (b.FirstLeft = this.m_PolyOuts[e.OutIdx])), e = e.PrevInAEL;\n    }c && (b.IsHole = !0);\n  };d.Clipper.prototype.GetDx = function (a, b) {\n    return a.Y == b.Y ? d.ClipperBase.horizontal : (b.X - a.X) / (b.Y - a.Y);\n  };d.Clipper.prototype.FirstIsBottomPt = function (a, b) {\n    for (var c = a.Prev; d.IntPoint.op_Equality(c.Pt, a.Pt) && c != a;) {\n      c = c.Prev;\n    }for (var e = Math.abs(this.GetDx(a.Pt, c.Pt)), c = a.Next; d.IntPoint.op_Equality(c.Pt, a.Pt) && c != a;) {\n      c = c.Next;\n    }for (var f = Math.abs(this.GetDx(a.Pt, c.Pt)), c = b.Prev; d.IntPoint.op_Equality(c.Pt, b.Pt) && c != b;) {\n      c = c.Prev;\n    }for (var g = Math.abs(this.GetDx(b.Pt, c.Pt)), c = b.Next; d.IntPoint.op_Equality(c.Pt, b.Pt) && c != b;) {\n      c = c.Next;\n    }c = Math.abs(this.GetDx(b.Pt, c.Pt));return e >= g && e >= c || f >= g && f >= c;\n  };d.Clipper.prototype.GetBottomPt = function (a) {\n    for (var b = null, c = a.Next; c != a;) {\n      c.Pt.Y > a.Pt.Y ? (a = c, b = null) : c.Pt.Y == a.Pt.Y && c.Pt.X <= a.Pt.X && (c.Pt.X < a.Pt.X ? (b = null, a = c) : c.Next != a && c.Prev != a && (b = c)), c = c.Next;\n    }if (null !== b) for (; b != c;) {\n      for (this.FirstIsBottomPt(c, b) || (a = b), b = b.Next; d.IntPoint.op_Inequality(b.Pt, a.Pt);) {\n        b = b.Next;\n      }\n    }return a;\n  };d.Clipper.prototype.GetLowermostRec = function (a, b) {\n    null === a.BottomPt && (a.BottomPt = this.GetBottomPt(a.Pts));null === b.BottomPt && (b.BottomPt = this.GetBottomPt(b.Pts));var c = a.BottomPt,\n        e = b.BottomPt;return c.Pt.Y > e.Pt.Y ? a : c.Pt.Y < e.Pt.Y ? b : c.Pt.X < e.Pt.X ? a : c.Pt.X > e.Pt.X ? b : c.Next == c ? b : e.Next == e ? a : this.FirstIsBottomPt(c, e) ? a : b;\n  };d.Clipper.prototype.Param1RightOfParam2 = function (a, b) {\n    do {\n      if (a = a.FirstLeft, a == b) return !0;\n    } while (null !== a);return !1;\n  };d.Clipper.prototype.GetOutRec = function (a) {\n    for (a = this.m_PolyOuts[a]; a != this.m_PolyOuts[a.Idx];) {\n      a = this.m_PolyOuts[a.Idx];\n    }return a;\n  };d.Clipper.prototype.AppendPolygon = function (a, b) {\n    var c = this.m_PolyOuts[a.OutIdx],\n        e = this.m_PolyOuts[b.OutIdx],\n        f;f = this.Param1RightOfParam2(c, e) ? e : this.Param1RightOfParam2(e, c) ? c : this.GetLowermostRec(c, e);var g = c.Pts,\n        h = g.Prev,\n        l = e.Pts,\n        k = l.Prev;a.Side == d.EdgeSide.esLeft ? (b.Side == d.EdgeSide.esLeft ? (this.ReversePolyPtLinks(l), l.Next = g, g.Prev = l, h.Next = k, k.Prev = h, c.Pts = k) : (k.Next = g, g.Prev = k, l.Prev = h, h.Next = l, c.Pts = l), g = d.EdgeSide.esLeft) : (b.Side == d.EdgeSide.esRight ? (this.ReversePolyPtLinks(l), h.Next = k, k.Prev = h, l.Next = g, g.Prev = l) : (h.Next = l, l.Prev = h, g.Prev = k, k.Next = g), g = d.EdgeSide.esRight);c.BottomPt = null;f == e && (e.FirstLeft != c && (c.FirstLeft = e.FirstLeft), c.IsHole = e.IsHole);e.Pts = null;e.BottomPt = null;e.FirstLeft = c;f = a.OutIdx;h = b.OutIdx;a.OutIdx = -1;b.OutIdx = -1;for (l = this.m_ActiveEdges; null !== l;) {\n      if (l.OutIdx == h) {\n        l.OutIdx = f;l.Side = g;break;\n      }l = l.NextInAEL;\n    }e.Idx = c.Idx;\n  };d.Clipper.prototype.ReversePolyPtLinks = function (a) {\n    if (null !== a) {\n      var b, c;b = a;do {\n        c = b.Next, b.Next = b.Prev, b = b.Prev = c;\n      } while (b != a);\n    }\n  };d.Clipper.SwapSides = function (a, b) {\n    var c = a.Side;a.Side = b.Side;b.Side = c;\n  };d.Clipper.SwapPolyIndexes = function (a, b) {\n    var c = a.OutIdx;a.OutIdx = b.OutIdx;b.OutIdx = c;\n  };d.Clipper.prototype.IntersectEdges = function (a, b, c, e) {\n    var f = !e && null === a.NextInLML && a.Top.X == c.X && a.Top.Y == c.Y;e = !e && null === b.NextInLML && b.Top.X == c.X && b.Top.Y == c.Y;var g = 0 <= a.OutIdx,\n        h = 0 <= b.OutIdx;if (0 === a.WindDelta || 0 === b.WindDelta) 0 === a.WindDelta && 0 === b.WindDelta ? (f || e) && g && h && this.AddLocalMaxPoly(a, b, c) : a.PolyTyp == b.PolyTyp && a.WindDelta != b.WindDelta && this.m_ClipType == d.ClipType.ctUnion ? 0 === a.WindDelta ? h && (this.AddOutPt(a, c), g && (a.OutIdx = -1)) : g && (this.AddOutPt(b, c), h && (b.OutIdx = -1)) : a.PolyTyp != b.PolyTyp && (0 !== a.WindDelta || 1 != Math.abs(b.WindCnt) || this.m_ClipType == d.ClipType.ctUnion && 0 !== b.WindCnt2 ? 0 !== b.WindDelta || 1 != Math.abs(a.WindCnt) || this.m_ClipType == d.ClipType.ctUnion && 0 !== a.WindCnt2 || (this.AddOutPt(b, c), h && (b.OutIdx = -1)) : (this.AddOutPt(a, c), g && (a.OutIdx = -1))), f && (0 > a.OutIdx ? this.DeleteFromAEL(a) : d.Error("Error intersecting polylines")), e && (0 > b.OutIdx ? this.DeleteFromAEL(b) : d.Error("Error intersecting polylines"));else {\n      if (a.PolyTyp == b.PolyTyp) {\n        if (this.IsEvenOddFillType(a)) {\n          var l = a.WindCnt;a.WindCnt = b.WindCnt;b.WindCnt = l;\n        } else a.WindCnt = 0 === a.WindCnt + b.WindDelta ? -a.WindCnt : a.WindCnt + b.WindDelta, b.WindCnt = 0 === b.WindCnt - a.WindDelta ? -b.WindCnt : b.WindCnt - a.WindDelta;\n      } else this.IsEvenOddFillType(b) ? a.WindCnt2 = 0 === a.WindCnt2 ? 1 : 0 : a.WindCnt2 += b.WindDelta, this.IsEvenOddFillType(a) ? b.WindCnt2 = 0 === b.WindCnt2 ? 1 : 0 : b.WindCnt2 -= a.WindDelta;var k, n, m;a.PolyTyp == d.PolyType.ptSubject ? (k = this.m_SubjFillType, m = this.m_ClipFillType) : (k = this.m_ClipFillType, m = this.m_SubjFillType);b.PolyTyp == d.PolyType.ptSubject ? (n = this.m_SubjFillType, l = this.m_ClipFillType) : (n = this.m_ClipFillType, l = this.m_SubjFillType);switch (k) {case d.PolyFillType.pftPositive:\n          k = a.WindCnt;break;case d.PolyFillType.pftNegative:\n          k = -a.WindCnt;break;default:\n          k = Math.abs(a.WindCnt);}switch (n) {case d.PolyFillType.pftPositive:\n          n = b.WindCnt;break;case d.PolyFillType.pftNegative:\n          n = -b.WindCnt;break;default:\n          n = Math.abs(b.WindCnt);}if (g && h) f || e || 0 !== k && 1 != k || 0 !== n && 1 != n || a.PolyTyp != b.PolyTyp && this.m_ClipType != d.ClipType.ctXor ? this.AddLocalMaxPoly(a, b, c) : (this.AddOutPt(a, c), this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b));else if (g) {\n        if (0 === n || 1 == n) this.AddOutPt(a, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);\n      } else if (h) {\n        if (0 === k || 1 == k) this.AddOutPt(b, c), d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b);\n      } else if (!(0 !== k && 1 != k || 0 !== n && 1 != n || f || e)) {\n        switch (m) {case d.PolyFillType.pftPositive:\n            g = a.WindCnt2;break;case d.PolyFillType.pftNegative:\n            g = -a.WindCnt2;break;default:\n            g = Math.abs(a.WindCnt2);}switch (l) {case d.PolyFillType.pftPositive:\n            h = b.WindCnt2;break;case d.PolyFillType.pftNegative:\n            h = -b.WindCnt2;break;default:\n            h = Math.abs(b.WindCnt2);}if (a.PolyTyp != b.PolyTyp) this.AddLocalMinPoly(a, b, c);else if (1 == k && 1 == n) switch (this.m_ClipType) {case d.ClipType.ctIntersection:\n            0 < g && 0 < h && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctUnion:\n            0 >= g && 0 >= h && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctDifference:\n            (a.PolyTyp == d.PolyType.ptClip && 0 < g && 0 < h || a.PolyTyp == d.PolyType.ptSubject && 0 >= g && 0 >= h) && this.AddLocalMinPoly(a, b, c);break;case d.ClipType.ctXor:\n            this.AddLocalMinPoly(a, b, c);} else d.Clipper.SwapSides(a, b);\n      }f != e && (f && 0 <= a.OutIdx || e && 0 <= b.OutIdx) && (d.Clipper.SwapSides(a, b), d.Clipper.SwapPolyIndexes(a, b));f && this.DeleteFromAEL(a);e && this.DeleteFromAEL(b);\n    }\n  };d.Clipper.prototype.DeleteFromAEL = function (a) {\n    var b = a.PrevInAEL,\n        c = a.NextInAEL;if (null !== b || null !== c || a == this.m_ActiveEdges) null !== b ? b.NextInAEL = c : this.m_ActiveEdges = c, null !== c && (c.PrevInAEL = b), a.NextInAEL = null, a.PrevInAEL = null;\n  };d.Clipper.prototype.DeleteFromSEL = function (a) {\n    var b = a.PrevInSEL,\n        c = a.NextInSEL;if (null !== b || null !== c || a == this.m_SortedEdges) null !== b ? b.NextInSEL = c : this.m_SortedEdges = c, null !== c && (c.PrevInSEL = b), a.NextInSEL = null, a.PrevInSEL = null;\n  };d.Clipper.prototype.UpdateEdgeIntoAEL = function (a) {\n    null === a.NextInLML && d.Error("UpdateEdgeIntoAEL: invalid call");var b = a.PrevInAEL,\n        c = a.NextInAEL;a.NextInLML.OutIdx = a.OutIdx;null !== b ? b.NextInAEL = a.NextInLML : this.m_ActiveEdges = a.NextInLML;null !== c && (c.PrevInAEL = a.NextInLML);a.NextInLML.Side = a.Side;a.NextInLML.WindDelta = a.WindDelta;a.NextInLML.WindCnt = a.WindCnt;a.NextInLML.WindCnt2 = a.WindCnt2;a = a.NextInLML;\n    a.Curr.X = a.Bot.X;a.Curr.Y = a.Bot.Y;a.PrevInAEL = b;a.NextInAEL = c;d.ClipperBase.IsHorizontal(a) || this.InsertScanbeam(a.Top.Y);return a;\n  };d.Clipper.prototype.ProcessHorizontals = function (a) {\n    for (var b = this.m_SortedEdges; null !== b;) {\n      this.DeleteFromSEL(b), this.ProcessHorizontal(b, a), b = this.m_SortedEdges;\n    }\n  };d.Clipper.prototype.GetHorzDirection = function (a, b) {\n    a.Bot.X < a.Top.X ? (b.Left = a.Bot.X, b.Right = a.Top.X, b.Dir = d.Direction.dLeftToRight) : (b.Left = a.Top.X, b.Right = a.Bot.X, b.Dir = d.Direction.dRightToLeft);\n  };d.Clipper.prototype.PrepareHorzJoins = function (a, b) {\n    var c = this.m_PolyOuts[a.OutIdx].Pts;a.Side != d.EdgeSide.esLeft && (c = c.Prev);b && (d.IntPoint.op_Equality(c.Pt, a.Top) ? this.AddGhostJoin(c, a.Bot) : this.AddGhostJoin(c, a.Top));\n  };d.Clipper.prototype.ProcessHorizontal = function (a, b) {\n    var c = { Dir: null, Left: null, Right: null };this.GetHorzDirection(a, c);for (var e = c.Dir, f = c.Left, g = c.Right, h = a, l = null; null !== h.NextInLML && d.ClipperBase.IsHorizontal(h.NextInLML);) {\n      h = h.NextInLML;\n    }for (null === h.NextInLML && (l = this.GetMaximaPair(h));;) {\n      for (var k = a == h, n = this.GetNextInAEL(a, e); null !== n && !(n.Curr.X == a.Top.X && null !== a.NextInLML && n.Dx < a.NextInLML.Dx);) {\n        c = this.GetNextInAEL(n, e);if (e == d.Direction.dLeftToRight && n.Curr.X <= g || e == d.Direction.dRightToLeft && n.Curr.X >= f) {\n          0 <= a.OutIdx && 0 != a.WindDelta && this.PrepareHorzJoins(a, b);if (n == l && k) {\n            e == d.Direction.dLeftToRight ? this.IntersectEdges(a, n, n.Top, !1) : this.IntersectEdges(n, a, n.Top, !1);0 <= l.OutIdx && d.Error("ProcessHorizontal error");return;\n          }if (e == d.Direction.dLeftToRight) {\n            var m = new d.IntPoint(n.Curr.X, a.Curr.Y);this.IntersectEdges(a, n, m, !0);\n          } else m = new d.IntPoint(n.Curr.X, a.Curr.Y), this.IntersectEdges(n, a, m, !0);this.SwapPositionsInAEL(a, n);\n        } else if (e == d.Direction.dLeftToRight && n.Curr.X >= g || e == d.Direction.dRightToLeft && n.Curr.X <= f) break;n = c;\n      }0 <= a.OutIdx && 0 !== a.WindDelta && this.PrepareHorzJoins(a, b);if (null !== a.NextInLML && d.ClipperBase.IsHorizontal(a.NextInLML)) a = this.UpdateEdgeIntoAEL(a), 0 <= a.OutIdx && this.AddOutPt(a, a.Bot), c = { Dir: e, Left: f, Right: g }, this.GetHorzDirection(a, c), e = c.Dir, f = c.Left, g = c.Right;else break;\n    }null !== a.NextInLML ? 0 <= a.OutIdx ? (e = this.AddOutPt(a, a.Top), a = this.UpdateEdgeIntoAEL(a), 0 !== a.WindDelta && (f = a.PrevInAEL, c = a.NextInAEL, null !== f && f.Curr.X == a.Bot.X && f.Curr.Y == a.Bot.Y && 0 !== f.WindDelta && 0 <= f.OutIdx && f.Curr.Y > f.Top.Y && d.ClipperBase.SlopesEqual(a, f, this.m_UseFullRange) ? (c = this.AddOutPt(f, a.Bot), this.AddJoin(e, c, a.Top)) : null !== c && c.Curr.X == a.Bot.X && c.Curr.Y == a.Bot.Y && 0 !== c.WindDelta && 0 <= c.OutIdx && c.Curr.Y > c.Top.Y && d.ClipperBase.SlopesEqual(a, c, this.m_UseFullRange) && (c = this.AddOutPt(c, a.Bot), this.AddJoin(e, c, a.Top)))) : this.UpdateEdgeIntoAEL(a) : null !== l ? 0 <= l.OutIdx ? (e == d.Direction.dLeftToRight ? this.IntersectEdges(a, l, a.Top, !1) : this.IntersectEdges(l, a, a.Top, !1), 0 <= l.OutIdx && d.Error("ProcessHorizontal error")) : (this.DeleteFromAEL(a), this.DeleteFromAEL(l)) : (0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a));\n  };d.Clipper.prototype.GetNextInAEL = function (a, b) {\n    return b == d.Direction.dLeftToRight ? a.NextInAEL : a.PrevInAEL;\n  };d.Clipper.prototype.IsMinima = function (a) {\n    return null !== a && a.Prev.NextInLML != a && a.Next.NextInLML != a;\n  };d.Clipper.prototype.IsMaxima = function (a, b) {\n    return null !== a && a.Top.Y == b && null === a.NextInLML;\n  };d.Clipper.prototype.IsIntermediate = function (a, b) {\n    return a.Top.Y == b && null !== a.NextInLML;\n  };d.Clipper.prototype.GetMaximaPair = function (a) {\n    var b = null;d.IntPoint.op_Equality(a.Next.Top, a.Top) && null === a.Next.NextInLML ? b = a.Next : d.IntPoint.op_Equality(a.Prev.Top, a.Top) && null === a.Prev.NextInLML && (b = a.Prev);return null === b || -2 != b.OutIdx && (b.NextInAEL != b.PrevInAEL || d.ClipperBase.IsHorizontal(b)) ? b : null;\n  };d.Clipper.prototype.ProcessIntersections = function (a, b) {\n    if (null == this.m_ActiveEdges) return !0;try {\n      this.BuildIntersectList(a, b);if (0 == this.m_IntersectList.length) return !0;if (1 == this.m_IntersectList.length || this.FixupIntersectionOrder()) this.ProcessIntersectList();else return !1;\n    } catch (c) {\n      this.m_SortedEdges = null, this.m_IntersectList.length = 0, d.Error("ProcessIntersections error");\n    }this.m_SortedEdges = null;return !0;\n  };d.Clipper.prototype.BuildIntersectList = function (a, b) {\n    if (null !== this.m_ActiveEdges) {\n      var c = this.m_ActiveEdges;for (this.m_SortedEdges = c; null !== c;) {\n        c.PrevInSEL = c.PrevInAEL, c.NextInSEL = c.NextInAEL, c.Curr.X = d.Clipper.TopX(c, b), c = c.NextInAEL;\n      }for (var e = !0; e && null !== this.m_SortedEdges;) {\n        e = !1;for (c = this.m_SortedEdges; null !== c.NextInSEL;) {\n          var f = c.NextInSEL,\n              g = new d.IntPoint();c.Curr.X > f.Curr.X ? (!this.IntersectPoint(c, f, g) && c.Curr.X > f.Curr.X + 1 && d.Error("Intersection error"), g.Y > a && (g.Y = a, Math.abs(c.Dx) > Math.abs(f.Dx) ? g.X = d.Clipper.TopX(f, a) : g.X = d.Clipper.TopX(c, a)), e = new d.IntersectNode(), e.Edge1 = c, e.Edge2 = f, e.Pt.X = g.X, e.Pt.Y = g.Y, this.m_IntersectList.push(e), this.SwapPositionsInSEL(c, f), e = !0) : c = f;\n        }if (null !== c.PrevInSEL) c.PrevInSEL.NextInSEL = null;else break;\n      }this.m_SortedEdges = null;\n    }\n  };d.Clipper.prototype.EdgesAdjacent = function (a) {\n    return a.Edge1.NextInSEL == a.Edge2 || a.Edge1.PrevInSEL == a.Edge2;\n  };d.Clipper.IntersectNodeSort = function (a, b) {\n    return b.Pt.Y - a.Pt.Y;\n  };d.Clipper.prototype.FixupIntersectionOrder = function () {\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);this.CopyAELToSEL();for (var a = this.m_IntersectList.length, b = 0; b < a; b++) {\n      if (!this.EdgesAdjacent(this.m_IntersectList[b])) {\n        for (var c = b + 1; c < a && !this.EdgesAdjacent(this.m_IntersectList[c]);) {\n          c++;\n        }if (c == a) return !1;var e = this.m_IntersectList[b];this.m_IntersectList[b] = this.m_IntersectList[c];this.m_IntersectList[c] = e;\n      }this.SwapPositionsInSEL(this.m_IntersectList[b].Edge1, this.m_IntersectList[b].Edge2);\n    }return !0;\n  };d.Clipper.prototype.ProcessIntersectList = function () {\n    for (var a = 0, b = this.m_IntersectList.length; a < b; a++) {\n      var c = this.m_IntersectList[a];this.IntersectEdges(c.Edge1, c.Edge2, c.Pt, !0);this.SwapPositionsInAEL(c.Edge1, c.Edge2);\n    }this.m_IntersectList.length = 0;\n  };E = function E(a) {\n    return 0 > a ? Math.ceil(a - 0.5) : Math.round(a);\n  };F = function F(a) {\n    return 0 > a ? Math.ceil(a - 0.5) : Math.floor(a + 0.5);\n  };G = function G(a) {\n    return 0 > a ? -Math.round(Math.abs(a)) : Math.round(a);\n  };H = function H(a) {\n    if (0 > a) return a -= 0.5, -2147483648 > a ? Math.ceil(a) : a | 0;a += 0.5;return 2147483647 < a ? Math.floor(a) : a | 0;\n  };d.Clipper.Round = p ? E : D ? G : J ? H : F;d.Clipper.TopX = function (a, b) {\n    return b == a.Top.Y ? a.Top.X : a.Bot.X + d.Clipper.Round(a.Dx * (b - a.Bot.Y));\n  };d.Clipper.prototype.IntersectPoint = function (a, b, c) {\n    c.X = 0;c.Y = 0;var e, f;if (d.ClipperBase.SlopesEqual(a, b, this.m_UseFullRange) || a.Dx == b.Dx) return b.Bot.Y > a.Bot.Y ? (c.X = b.Bot.X, c.Y = b.Bot.Y) : (c.X = a.Bot.X, c.Y = a.Bot.Y), !1;if (0 === a.Delta.X) c.X = a.Bot.X, d.ClipperBase.IsHorizontal(b) ? c.Y = b.Bot.Y : (f = b.Bot.Y - b.Bot.X / b.Dx, c.Y = d.Clipper.Round(c.X / b.Dx + f));else if (0 === b.Delta.X) c.X = b.Bot.X, d.ClipperBase.IsHorizontal(a) ? c.Y = a.Bot.Y : (e = a.Bot.Y - a.Bot.X / a.Dx, c.Y = d.Clipper.Round(c.X / a.Dx + e));else {\n      e = a.Bot.X - a.Bot.Y * a.Dx;f = b.Bot.X - b.Bot.Y * b.Dx;var g = (f - e) / (a.Dx - b.Dx);c.Y = d.Clipper.Round(g);Math.abs(a.Dx) < Math.abs(b.Dx) ? c.X = d.Clipper.Round(a.Dx * g + e) : c.X = d.Clipper.Round(b.Dx * g + f);\n    }if (c.Y < a.Top.Y || c.Y < b.Top.Y) {\n      if (a.Top.Y > b.Top.Y) return c.Y = a.Top.Y, c.X = d.Clipper.TopX(b, a.Top.Y), c.X < a.Top.X;c.Y = b.Top.Y;Math.abs(a.Dx) < Math.abs(b.Dx) ? c.X = d.Clipper.TopX(a, c.Y) : c.X = d.Clipper.TopX(b, c.Y);\n    }return !0;\n  };d.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (a) {\n    for (var b = this.m_ActiveEdges; null !== b;) {\n      var c = this.IsMaxima(b, a);c && (c = this.GetMaximaPair(b), c = null === c || !d.ClipperBase.IsHorizontal(c));if (c) {\n        var e = b.PrevInAEL;this.DoMaxima(b);\n        b = null === e ? this.m_ActiveEdges : e.NextInAEL;\n      } else this.IsIntermediate(b, a) && d.ClipperBase.IsHorizontal(b.NextInLML) ? (b = this.UpdateEdgeIntoAEL(b), 0 <= b.OutIdx && this.AddOutPt(b, b.Bot), this.AddEdgeToSEL(b)) : (b.Curr.X = d.Clipper.TopX(b, a), b.Curr.Y = a), this.StrictlySimple && (e = b.PrevInAEL, 0 <= b.OutIdx && 0 !== b.WindDelta && null !== e && 0 <= e.OutIdx && e.Curr.X == b.Curr.X && 0 !== e.WindDelta && (c = this.AddOutPt(e, b.Curr), e = this.AddOutPt(b, b.Curr), this.AddJoin(c, e, b.Curr))), b = b.NextInAEL;\n    }this.ProcessHorizontals(!0);for (b = this.m_ActiveEdges; null !== b;) {\n      if (this.IsIntermediate(b, a)) {\n        c = null;0 <= b.OutIdx && (c = this.AddOutPt(b, b.Top));var b = this.UpdateEdgeIntoAEL(b),\n            e = b.PrevInAEL,\n            f = b.NextInAEL;null !== e && e.Curr.X == b.Bot.X && e.Curr.Y == b.Bot.Y && null !== c && 0 <= e.OutIdx && e.Curr.Y > e.Top.Y && d.ClipperBase.SlopesEqual(b, e, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== e.WindDelta ? (e = this.AddOutPt(e, b.Bot), this.AddJoin(c, e, b.Top)) : null !== f && f.Curr.X == b.Bot.X && f.Curr.Y == b.Bot.Y && null !== c && 0 <= f.OutIdx && f.Curr.Y > f.Top.Y && d.ClipperBase.SlopesEqual(b, f, this.m_UseFullRange) && 0 !== b.WindDelta && 0 !== f.WindDelta && (e = this.AddOutPt(f, b.Bot), this.AddJoin(c, e, b.Top));\n      }b = b.NextInAEL;\n    }\n  };d.Clipper.prototype.DoMaxima = function (a) {\n    var b = this.GetMaximaPair(a);if (null === b) 0 <= a.OutIdx && this.AddOutPt(a, a.Top), this.DeleteFromAEL(a);else {\n      for (var c = a.NextInAEL; null !== c && c != b;) {\n        this.IntersectEdges(a, c, a.Top, !0), this.SwapPositionsInAEL(a, c), c = a.NextInAEL;\n      }-1 == a.OutIdx && -1 == b.OutIdx ? (this.DeleteFromAEL(a), this.DeleteFromAEL(b)) : 0 <= a.OutIdx && 0 <= b.OutIdx ? this.IntersectEdges(a, b, a.Top, !1) : 0 === a.WindDelta ? (0 <= a.OutIdx && (this.AddOutPt(a, a.Top), a.OutIdx = -1), this.DeleteFromAEL(a), 0 <= b.OutIdx && (this.AddOutPt(b, a.Top), b.OutIdx = -1), this.DeleteFromAEL(b)) : d.Error("DoMaxima error");\n    }\n  };d.Clipper.ReversePaths = function (a) {\n    for (var b = 0, c = a.length; b < c; b++) {\n      a[b].reverse();\n    }\n  };d.Clipper.Orientation = function (a) {\n    return 0 <= d.Clipper.Area(a);\n  };d.Clipper.prototype.PointCount = function (a) {\n    if (null === a) return 0;var b = 0,\n        c = a;do {\n      b++, c = c.Next;\n    } while (c != a);return b;\n  };d.Clipper.prototype.BuildResult = function (a) {\n    d.Clear(a);for (var b = 0, c = this.m_PolyOuts.length; b < c; b++) {\n      var e = this.m_PolyOuts[b];if (null !== e.Pts) {\n        var e = e.Pts.Prev,\n            f = this.PointCount(e);if (!(2 > f)) {\n          for (var g = Array(f), h = 0; h < f; h++) {\n            g[h] = e.Pt, e = e.Prev;\n          }a.push(g);\n        }\n      }\n    }\n  };d.Clipper.prototype.BuildResult2 = function (a) {\n    a.Clear();for (var b = 0, c = this.m_PolyOuts.length; b < c; b++) {\n      var e = this.m_PolyOuts[b],\n          f = this.PointCount(e.Pts);if (!(e.IsOpen && 2 > f || !e.IsOpen && 3 > f)) {\n        this.FixHoleLinkage(e);var g = new d.PolyNode();a.m_AllPolys.push(g);e.PolyNode = g;g.m_polygon.length = f;for (var e = e.Pts.Prev, h = 0; h < f; h++) {\n          g.m_polygon[h] = e.Pt, e = e.Prev;\n        }\n      }\n    }b = 0;for (c = this.m_PolyOuts.length; b < c; b++) {\n      e = this.m_PolyOuts[b], null !== e.PolyNode && (e.IsOpen ? (e.PolyNode.IsOpen = !0, a.AddChild(e.PolyNode)) : null !== e.FirstLeft && null != e.FirstLeft.PolyNode ? e.FirstLeft.PolyNode.AddChild(e.PolyNode) : a.AddChild(e.PolyNode));\n    }\n  };d.Clipper.prototype.FixupOutPolygon = function (a) {\n    var b = null;a.BottomPt = null;for (var c = a.Pts;;) {\n      if (c.Prev == c || c.Prev == c.Next) {\n        this.DisposeOutPts(c);a.Pts = null;return;\n      }if (d.IntPoint.op_Equality(c.Pt, c.Next.Pt) || d.IntPoint.op_Equality(c.Pt, c.Prev.Pt) || d.ClipperBase.SlopesEqual(c.Prev.Pt, c.Pt, c.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(c.Prev.Pt, c.Pt, c.Next.Pt))) b = null, c.Prev.Next = c.Next, c = c.Next.Prev = c.Prev;else if (c == b) break;else null === b && (b = c), c = c.Next;\n    }a.Pts = c;\n  };d.Clipper.prototype.DupOutPt = function (a, b) {\n    var c = new d.OutPt();c.Pt.X = a.Pt.X;c.Pt.Y = a.Pt.Y;c.Idx = a.Idx;b ? (c.Next = a.Next, c.Prev = a, a.Next.Prev = c, a.Next = c) : (c.Prev = a.Prev, c.Next = a, a.Prev.Next = c, a.Prev = c);return c;\n  };d.Clipper.prototype.GetOverlap = function (a, b, c, e, d) {\n    a < b ? c < e ? (d.Left = Math.max(a, c), d.Right = Math.min(b, e)) : (d.Left = Math.max(a, e), d.Right = Math.min(b, c)) : c < e ? (d.Left = Math.max(b, c), d.Right = Math.min(a, e)) : (d.Left = Math.max(b, e), d.Right = Math.min(a, c));return d.Left < d.Right;\n  };d.Clipper.prototype.JoinHorz = function (a, b, c, e, f, g) {\n    var h = a.Pt.X > b.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;e = c.Pt.X > e.Pt.X ? d.Direction.dRightToLeft : d.Direction.dLeftToRight;if (h == e) return !1;if (h == d.Direction.dLeftToRight) {\n      for (; a.Next.Pt.X <= f.X && a.Next.Pt.X >= a.Pt.X && a.Next.Pt.Y == f.Y;) {\n        a = a.Next;\n      }g && a.Pt.X != f.X && (a = a.Next);b = this.DupOutPt(a, !g);d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, b = this.DupOutPt(a, !g));\n    } else {\n      for (; a.Next.Pt.X >= f.X && a.Next.Pt.X <= a.Pt.X && a.Next.Pt.Y == f.Y;) {\n        a = a.Next;\n      }g || a.Pt.X == f.X || (a = a.Next);b = this.DupOutPt(a, g);d.IntPoint.op_Inequality(b.Pt, f) && (a = b, a.Pt.X = f.X, a.Pt.Y = f.Y, b = this.DupOutPt(a, g));\n    }if (e == d.Direction.dLeftToRight) {\n      for (; c.Next.Pt.X <= f.X && c.Next.Pt.X >= c.Pt.X && c.Next.Pt.Y == f.Y;) {\n        c = c.Next;\n      }g && c.Pt.X != f.X && (c = c.Next);\n      e = this.DupOutPt(c, !g);d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, e = this.DupOutPt(c, !g));\n    } else {\n      for (; c.Next.Pt.X >= f.X && c.Next.Pt.X <= c.Pt.X && c.Next.Pt.Y == f.Y;) {\n        c = c.Next;\n      }g || c.Pt.X == f.X || (c = c.Next);e = this.DupOutPt(c, g);d.IntPoint.op_Inequality(e.Pt, f) && (c = e, c.Pt.X = f.X, c.Pt.Y = f.Y, e = this.DupOutPt(c, g));\n    }h == d.Direction.dLeftToRight == g ? (a.Prev = c, c.Next = a, b.Next = e, e.Prev = b) : (a.Next = c, c.Prev = a, b.Prev = e, e.Next = b);return !0;\n  };d.Clipper.prototype.JoinPoints = function (a, b, c) {\n    var e = a.OutPt1,\n        f = new d.OutPt(),\n        g = a.OutPt2,\n        h = new d.OutPt();if ((h = a.OutPt1.Pt.Y == a.OffPt.Y) && d.IntPoint.op_Equality(a.OffPt, a.OutPt1.Pt) && d.IntPoint.op_Equality(a.OffPt, a.OutPt2.Pt)) {\n      for (f = a.OutPt1.Next; f != e && d.IntPoint.op_Equality(f.Pt, a.OffPt);) {\n        f = f.Next;\n      }f = f.Pt.Y > a.OffPt.Y;for (h = a.OutPt2.Next; h != g && d.IntPoint.op_Equality(h.Pt, a.OffPt);) {\n        h = h.Next;\n      }if (f == h.Pt.Y > a.OffPt.Y) return !1;f ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);a.OutPt1 = e;a.OutPt2 = f;return !0;\n    }if (h) {\n      for (f = e; e.Prev.Pt.Y == e.Pt.Y && e.Prev != f && e.Prev != g;) {\n        e = e.Prev;\n      }for (; f.Next.Pt.Y == f.Pt.Y && f.Next != e && f.Next != g;) {\n        f = f.Next;\n      }if (f.Next == e || f.Next == g) return !1;for (h = g; g.Prev.Pt.Y == g.Pt.Y && g.Prev != h && g.Prev != f;) {\n        g = g.Prev;\n      }for (; h.Next.Pt.Y == h.Pt.Y && h.Next != g && h.Next != e;) {\n        h = h.Next;\n      }if (h.Next == g || h.Next == e) return !1;c = { Left: null, Right: null };if (!this.GetOverlap(e.Pt.X, f.Pt.X, g.Pt.X, h.Pt.X, c)) return !1;b = c.Left;var l = c.Right;c = new d.IntPoint();e.Pt.X >= b && e.Pt.X <= l ? (c.X = e.Pt.X, c.Y = e.Pt.Y, b = e.Pt.X > f.Pt.X) : g.Pt.X >= b && g.Pt.X <= l ? (c.X = g.Pt.X, c.Y = g.Pt.Y, b = g.Pt.X > h.Pt.X) : f.Pt.X >= b && f.Pt.X <= l ? (c.X = f.Pt.X, c.Y = f.Pt.Y, b = f.Pt.X > e.Pt.X) : (c.X = h.Pt.X, c.Y = h.Pt.Y, b = h.Pt.X > g.Pt.X);a.OutPt1 = e;a.OutPt2 = g;return this.JoinHorz(e, f, g, h, c, b);\n    }for (f = e.Next; d.IntPoint.op_Equality(f.Pt, e.Pt) && f != e;) {\n      f = f.Next;\n    }if (l = f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) {\n      for (f = e.Prev; d.IntPoint.op_Equality(f.Pt, e.Pt) && f != e;) {\n        f = f.Prev;\n      }if (f.Pt.Y > e.Pt.Y || !d.ClipperBase.SlopesEqual(e.Pt, f.Pt, a.OffPt, this.m_UseFullRange)) return !1;\n    }for (h = g.Next; d.IntPoint.op_Equality(h.Pt, g.Pt) && h != g;) {\n      h = h.Next;\n    }var k = h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange);if (k) {\n      for (h = g.Prev; d.IntPoint.op_Equality(h.Pt, g.Pt) && h != g;) {\n        h = h.Prev;\n      }if (h.Pt.Y > g.Pt.Y || !d.ClipperBase.SlopesEqual(g.Pt, h.Pt, a.OffPt, this.m_UseFullRange)) return !1;\n    }if (f == e || h == g || f == h || b == c && l == k) return !1;l ? (f = this.DupOutPt(e, !1), h = this.DupOutPt(g, !0), e.Prev = g, g.Next = e, f.Next = h, h.Prev = f) : (f = this.DupOutPt(e, !0), h = this.DupOutPt(g, !1), e.Next = g, g.Prev = e, f.Prev = h, h.Next = f);a.OutPt1 = e;a.OutPt2 = f;return !0;\n  };d.Clipper.GetBounds = function (a) {\n    for (var b = 0, c = a.length; b < c && 0 == a[b].length;) {\n      b++;\n    }if (b == c) return new d.IntRect(0, 0, 0, 0);var e = new d.IntRect();e.left = a[b][0].X;e.right = e.left;e.top = a[b][0].Y;for (e.bottom = e.top; b < c; b++) {\n      for (var f = 0, g = a[b].length; f < g; f++) {\n        a[b][f].X < e.left ? e.left = a[b][f].X : a[b][f].X > e.right && (e.right = a[b][f].X), a[b][f].Y < e.top ? e.top = a[b][f].Y : a[b][f].Y > e.bottom && (e.bottom = a[b][f].Y);\n      }\n    }return e;\n  };d.Clipper.prototype.GetBounds2 = function (a) {\n    var b = a,\n        c = new d.IntRect();c.left = a.Pt.X;c.right = a.Pt.X;c.top = a.Pt.Y;c.bottom = a.Pt.Y;for (a = a.Next; a != b;) {\n      a.Pt.X < c.left && (c.left = a.Pt.X), a.Pt.X > c.right && (c.right = a.Pt.X), a.Pt.Y < c.top && (c.top = a.Pt.Y), a.Pt.Y > c.bottom && (c.bottom = a.Pt.Y), a = a.Next;\n    }return c;\n  };d.Clipper.PointInPolygon = function (a, b) {\n    var c = 0,\n        e = b.length;if (3 > e) return 0;for (var d = b[0], g = 1; g <= e; ++g) {\n      var h = g == e ? b[0] : b[g];if (h.Y == a.Y && (h.X == a.X || d.Y == a.Y && h.X > a.X == d.X < a.X)) return -1;if (d.Y < a.Y != h.Y < a.Y) if (d.X >= a.X) {\n        if (h.X > a.X) c = 1 - c;else {\n          var l = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);if (0 == l) return -1;0 < l == h.Y > d.Y && (c = 1 - c);\n        }\n      } else if (h.X > a.X) {\n        l = (d.X - a.X) * (h.Y - a.Y) - (h.X - a.X) * (d.Y - a.Y);if (0 == l) return -1;0 < l == h.Y > d.Y && (c = 1 - c);\n      }d = h;\n    }return c;\n  };d.Clipper.prototype.PointInPolygon = function (a, b) {\n    for (var c = 0, e = b;;) {\n      var d = b.Pt.X,\n          g = b.Pt.Y,\n          h = b.Next.Pt.X,\n          l = b.Next.Pt.Y;if (l == a.Y && (h == a.X || g == a.Y && h > a.X == d < a.X)) return -1;if (g < a.Y != l < a.Y) if (d >= a.X) {\n        if (h > a.X) c = 1 - c;else {\n          d = (d - a.X) * (l - a.Y) - (h - a.X) * (g - a.Y);if (0 == d) return -1;0 < d == l > g && (c = 1 - c);\n        }\n      } else if (h > a.X) {\n        d = (d - a.X) * (l - a.Y) - (h - a.X) * (g - a.Y);if (0 == d) return -1;0 < d == l > g && (c = 1 - c);\n      }b = b.Next;if (e == b) break;\n    }return c;\n  };d.Clipper.prototype.Poly2ContainsPoly1 = function (a, b) {\n    var c = a;do {\n      var e = this.PointInPolygon(c.Pt, b);if (0 <= e) return 0 != e;c = c.Next;\n    } while (c != a);return !0;\n  };d.Clipper.prototype.FixupFirstLefts1 = function (a, b) {\n    for (var c = 0, e = this.m_PolyOuts.length; c < e; c++) {\n      var d = this.m_PolyOuts[c];null !== d.Pts && d.FirstLeft == a && this.Poly2ContainsPoly1(d.Pts, b.Pts) && (d.FirstLeft = b);\n    }\n  };d.Clipper.prototype.FixupFirstLefts2 = function (a, b) {\n    for (var c = 0, e = this.m_PolyOuts, d = e.length, g = e[c]; c < d; c++, g = e[c]) {\n      g.FirstLeft == a && (g.FirstLeft = b);\n    }\n  };d.Clipper.ParseFirstLeft = function (a) {\n    for (; null != a && null == a.Pts;) {\n      a = a.FirstLeft;\n    }return a;\n  };d.Clipper.prototype.JoinCommonEdges = function () {\n    for (var a = 0, b = this.m_Joins.length; a < b; a++) {\n      var c = this.m_Joins[a],\n          e = this.GetOutRec(c.OutPt1.Idx),\n          f = this.GetOutRec(c.OutPt2.Idx);if (null != e.Pts && null != f.Pts) {\n        var g;g = e == f ? e : this.Param1RightOfParam2(e, f) ? f : this.Param1RightOfParam2(f, e) ? e : this.GetLowermostRec(e, f);if (this.JoinPoints(c, e, f)) if (e == f) {\n          e.Pts = c.OutPt1;e.BottomPt = null;f = this.CreateOutRec();f.Pts = c.OutPt2;this.UpdateOutPtIdxs(f);if (this.m_UsingPolyTree) {\n            g = 0;for (var h = this.m_PolyOuts.length; g < h - 1; g++) {\n              var l = this.m_PolyOuts[g];null != l.Pts && d.Clipper.ParseFirstLeft(l.FirstLeft) == e && l.IsHole != e.IsHole && this.Poly2ContainsPoly1(l.Pts, c.OutPt2) && (l.FirstLeft = f);\n            }\n          }this.Poly2ContainsPoly1(f.Pts, e.Pts) ? (f.IsHole = !e.IsHole, f.FirstLeft = e, this.m_UsingPolyTree && this.FixupFirstLefts2(f, e), (f.IsHole ^ this.ReverseSolution) == 0 < this.Area(f) && this.ReversePolyPtLinks(f.Pts)) : this.Poly2ContainsPoly1(e.Pts, f.Pts) ? (f.IsHole = e.IsHole, e.IsHole = !f.IsHole, f.FirstLeft = e.FirstLeft, e.FirstLeft = f, this.m_UsingPolyTree && this.FixupFirstLefts2(e, f), (e.IsHole ^ this.ReverseSolution) == 0 < this.Area(e) && this.ReversePolyPtLinks(e.Pts)) : (f.IsHole = e.IsHole, f.FirstLeft = e.FirstLeft, this.m_UsingPolyTree && this.FixupFirstLefts1(e, f));\n        } else f.Pts = null, f.BottomPt = null, f.Idx = e.Idx, e.IsHole = g.IsHole, g == f && (e.FirstLeft = f.FirstLeft), f.FirstLeft = e, this.m_UsingPolyTree && this.FixupFirstLefts2(f, e);\n      }\n    }\n  };d.Clipper.prototype.UpdateOutPtIdxs = function (a) {\n    var b = a.Pts;do {\n      b.Idx = a.Idx, b = b.Prev;\n    } while (b != a.Pts);\n  };d.Clipper.prototype.DoSimplePolygons = function () {\n    for (var a = 0; a < this.m_PolyOuts.length;) {\n      var b = this.m_PolyOuts[a++],\n          c = b.Pts;if (null !== c) {\n        do {\n          for (var e = c.Next; e != b.Pts;) {\n            if (d.IntPoint.op_Equality(c.Pt, e.Pt) && e.Next != c && e.Prev != c) {\n              var f = c.Prev,\n                  g = e.Prev;c.Prev = g;g.Next = c;e.Prev = f;f.Next = e;b.Pts = c;f = this.CreateOutRec();f.Pts = e;this.UpdateOutPtIdxs(f);this.Poly2ContainsPoly1(f.Pts, b.Pts) ? (f.IsHole = !b.IsHole, f.FirstLeft = b) : this.Poly2ContainsPoly1(b.Pts, f.Pts) ? (f.IsHole = b.IsHole, b.IsHole = !f.IsHole, f.FirstLeft = b.FirstLeft, b.FirstLeft = f) : (f.IsHole = b.IsHole, f.FirstLeft = b.FirstLeft);e = c;\n            }e = e.Next;\n          }c = c.Next;\n        } while (c != b.Pts);\n      }\n    }\n  };d.Clipper.Area = function (a) {\n    var b = a.length;if (3 > b) return 0;for (var c = 0, e = 0, d = b - 1; e < b; ++e) {\n      c += (a[d].X + a[e].X) * (a[d].Y - a[e].Y), d = e;\n    }return 0.5 * -c;\n  };d.Clipper.prototype.Area = function (a) {\n    var b = a.Pts;if (null == b) return 0;var c = 0;do {\n      c += (b.Prev.Pt.X + b.Pt.X) * (b.Prev.Pt.Y - b.Pt.Y), b = b.Next;\n    } while (b != a.Pts);\n    return 0.5 * c;\n  };d.Clipper.SimplifyPolygon = function (a, b) {\n    var c = [],\n        e = new d.Clipper(0);e.StrictlySimple = !0;e.AddPath(a, d.PolyType.ptSubject, !0);e.Execute(d.ClipType.ctUnion, c, b, b);return c;\n  };d.Clipper.SimplifyPolygons = function (a, b) {\n    "undefined" == typeof b && (b = d.PolyFillType.pftEvenOdd);var c = [],\n        e = new d.Clipper(0);e.StrictlySimple = !0;e.AddPaths(a, d.PolyType.ptSubject, !0);e.Execute(d.ClipType.ctUnion, c, b, b);return c;\n  };d.Clipper.DistanceSqrd = function (a, b) {\n    var c = a.X - b.X,\n        e = a.Y - b.Y;return c * c + e * e;\n  };d.Clipper.DistanceFromLineSqrd = function (a, b, c) {\n    var e = b.Y - c.Y;c = c.X - b.X;b = e * b.X + c * b.Y;b = e * a.X + c * a.Y - b;return b * b / (e * e + c * c);\n  };d.Clipper.SlopesNearCollinear = function (a, b, c, e) {\n    return d.Clipper.DistanceFromLineSqrd(b, a, c) < e;\n  };d.Clipper.PointsAreClose = function (a, b, c) {\n    var e = a.X - b.X;a = a.Y - b.Y;return e * e + a * a <= c;\n  };d.Clipper.ExcludeOp = function (a) {\n    var b = a.Prev;b.Next = a.Next;a.Next.Prev = b;b.Idx = 0;return b;\n  };d.Clipper.CleanPolygon = function (a, b) {\n    "undefined" == typeof b && (b = 1.415);var c = a.length;if (0 == c) return [];for (var e = Array(c), f = 0; f < c; ++f) {\n      e[f] = new d.OutPt();\n    }for (f = 0; f < c; ++f) {\n      e[f].Pt = a[f], e[f].Next = e[(f + 1) % c], e[f].Next.Prev = e[f], e[f].Idx = 0;\n    }f = b * b;for (e = e[0]; 0 == e.Idx && e.Next != e.Prev;) {\n      d.Clipper.PointsAreClose(e.Pt, e.Prev.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : d.Clipper.PointsAreClose(e.Prev.Pt, e.Next.Pt, f) ? (d.Clipper.ExcludeOp(e.Next), e = d.Clipper.ExcludeOp(e), c -= 2) : d.Clipper.SlopesNearCollinear(e.Prev.Pt, e.Pt, e.Next.Pt, f) ? (e = d.Clipper.ExcludeOp(e), c--) : (e.Idx = 1, e = e.Next);\n    }3 > c && (c = 0);for (var g = Array(c), f = 0; f < c; ++f) {\n      g[f] = new d.IntPoint(e.Pt), e = e.Next;\n    }return g;\n  };d.Clipper.CleanPolygons = function (a, b) {\n    for (var c = Array(a.length), e = 0, f = a.length; e < f; e++) {\n      c[e] = d.Clipper.CleanPolygon(a[e], b);\n    }return c;\n  };d.Clipper.Minkowski = function (a, b, c, e) {\n    var f = e ? 1 : 0,\n        g = a.length,\n        h = b.length;e = [];if (c) for (c = 0; c < h; c++) {\n      for (var l = Array(g), k = 0, n = a.length, m = a[k]; k < n; k++, m = a[k]) {\n        l[k] = new d.IntPoint(b[c].X + m.X, b[c].Y + m.Y);\n      }e.push(l);\n    } else for (c = 0; c < h; c++) {\n      l = Array(g);k = 0;n = a.length;for (m = a[k]; k < n; k++, m = a[k]) {\n        l[k] = new d.IntPoint(b[c].X - m.X, b[c].Y - m.Y);\n      }e.push(l);\n    }a = [];for (c = 0; c < h - 1 + f; c++) {\n      for (k = 0; k < g; k++) {\n        b = [], b.push(e[c % h][k % g]), b.push(e[(c + 1) % h][k % g]), b.push(e[(c + 1) % h][(k + 1) % g]), b.push(e[c % h][(k + 1) % g]), d.Clipper.Orientation(b) || b.reverse(), a.push(b);\n      }\n    }f = new d.Clipper(0);f.AddPaths(a, d.PolyType.ptSubject, !0);f.Execute(d.ClipType.ctUnion, e, d.PolyFillType.pftNonZero, d.PolyFillType.pftNonZero);return e;\n  };d.Clipper.MinkowskiSum = function () {\n    var a = arguments,\n        b = a.length;if (3 == b) {\n      var c = a[0],\n          e = a[2];return d.Clipper.Minkowski(c, a[1], !0, e);\n    }if (4 == b) {\n      for (var c = a[0], f = a[1], b = a[2], e = a[3], a = new d.Clipper(), g, h = 0, l = f.length; h < l; ++h) {\n        g = d.Clipper.Minkowski(c, f[h], !0, e), a.AddPaths(g, d.PolyType.ptSubject, !0);\n      }e && a.AddPaths(f, d.PolyType.ptClip, !0);c = new d.Paths();a.Execute(d.ClipType.ctUnion, c, b, b);return c;\n    }\n  };d.Clipper.MinkowskiDiff = function (a, b, c) {\n    return d.Clipper.Minkowski(a, b, !1, c);\n  };d.Clipper.PolyTreeToPaths = function (a) {\n    var b = [];d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntAny, b);return b;\n  };d.Clipper.AddPolyNodeToPaths = function (a, b, c) {\n    var e = !0;switch (b) {case d.Clipper.NodeType.ntOpen:\n        return;case d.Clipper.NodeType.ntClosed:\n        e = !a.IsOpen;}0 < a.m_polygon.length && e && c.push(a.m_polygon);e = 0;a = a.Childs();for (var f = a.length, g = a[e]; e < f; e++, g = a[e]) {\n      d.Clipper.AddPolyNodeToPaths(g, b, c);\n    }\n  };d.Clipper.OpenPathsFromPolyTree = function (a) {\n    for (var b = new d.Paths(), c = 0, e = a.ChildCount(); c < e; c++) {\n      a.Childs()[c].IsOpen && b.push(a.Childs()[c].m_polygon);\n    }return b;\n  };d.Clipper.ClosedPathsFromPolyTree = function (a) {\n    var b = new d.Paths();d.Clipper.AddPolyNodeToPaths(a, d.Clipper.NodeType.ntClosed, b);return b;\n  };K(d.Clipper, d.ClipperBase);d.Clipper.NodeType = { ntAny: 0, ntOpen: 1,\n    ntClosed: 2 };d.ClipperOffset = function (a, b) {\n    "undefined" == typeof a && (a = 2);"undefined" == typeof b && (b = d.ClipperOffset.def_arc_tolerance);this.m_destPolys = new d.Paths();this.m_srcPoly = new d.Path();this.m_destPoly = new d.Path();this.m_normals = [];this.m_StepsPerRad = this.m_miterLim = this.m_cos = this.m_sin = this.m_sinA = this.m_delta = 0;this.m_lowest = new d.IntPoint();this.m_polyNodes = new d.PolyNode();this.MiterLimit = a;this.ArcTolerance = b;this.m_lowest.X = -1;\n  };d.ClipperOffset.two_pi = 6.28318530717959;d.ClipperOffset.def_arc_tolerance = 0.25;d.ClipperOffset.prototype.Clear = function () {\n    d.Clear(this.m_polyNodes.Childs());this.m_lowest.X = -1;\n  };d.ClipperOffset.Round = d.Clipper.Round;d.ClipperOffset.prototype.AddPath = function (a, b, c) {\n    var e = a.length - 1;if (!(0 > e)) {\n      var f = new d.PolyNode();f.m_jointype = b;f.m_endtype = c;if (c == d.EndType.etClosedLine || c == d.EndType.etClosedPolygon) for (; 0 < e && d.IntPoint.op_Equality(a[0], a[e]);) {\n        e--;\n      }f.m_polygon.push(a[0]);var g = 0;b = 0;for (var h = 1; h <= e; h++) {\n        d.IntPoint.op_Inequality(f.m_polygon[g], a[h]) && (g++, f.m_polygon.push(a[h]), a[h].Y > f.m_polygon[b].Y || a[h].Y == f.m_polygon[b].Y && a[h].X < f.m_polygon[b].X) && (b = g);\n      }if (!(c == d.EndType.etClosedPolygon && 2 > g || c != d.EndType.etClosedPolygon && 0 > g) && (this.m_polyNodes.AddChild(f), c == d.EndType.etClosedPolygon)) if (0 > this.m_lowest.X) this.m_lowest = new d.IntPoint(0, b);else if (a = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y], f.m_polygon[b].Y > a.Y || f.m_polygon[b].Y == a.Y && f.m_polygon[b].X < a.X) this.m_lowest = new d.IntPoint(this.m_polyNodes.ChildCount() - 1, b);\n    }\n  };d.ClipperOffset.prototype.AddPaths = function (a, b, c) {\n    for (var e = 0, d = a.length; e < d; e++) {\n      this.AddPath(a[e], b, c);\n    }\n  };d.ClipperOffset.prototype.FixOrientations = function () {\n    if (0 <= this.m_lowest.X && !d.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) for (var a = 0; a < this.m_polyNodes.ChildCount(); a++) {\n      var b = this.m_polyNodes.Childs()[a];(b.m_endtype == d.EndType.etClosedPolygon || b.m_endtype == d.EndType.etClosedLine && d.Clipper.Orientation(b.m_polygon)) && b.m_polygon.reverse();\n    } else for (a = 0; a < this.m_polyNodes.ChildCount(); a++) {\n      b = this.m_polyNodes.Childs()[a], b.m_endtype != d.EndType.etClosedLine || d.Clipper.Orientation(b.m_polygon) || b.m_polygon.reverse();\n    }\n  };d.ClipperOffset.GetUnitNormal = function (a, b) {\n    var c = b.X - a.X,\n        e = b.Y - a.Y;if (0 == c && 0 == e) return new d.DoublePoint(0, 0);var f = 1 / Math.sqrt(c * c + e * e);return new d.DoublePoint(e * f, -(c * f));\n  };d.ClipperOffset.prototype.DoOffset = function (a) {\n    this.m_destPolys = [];this.m_delta = a;if (d.ClipperBase.near_zero(a)) for (var b = 0; b < this.m_polyNodes.ChildCount(); b++) {\n      var c = this.m_polyNodes.Childs()[b];c.m_endtype == d.EndType.etClosedPolygon && this.m_destPolys.push(c.m_polygon);\n    } else {\n      this.m_miterLim = 2 < this.MiterLimit ? 2 / (this.MiterLimit * this.MiterLimit) : 0.5;var b = 0 >= this.ArcTolerance ? d.ClipperOffset.def_arc_tolerance : this.ArcTolerance > Math.abs(a) * d.ClipperOffset.def_arc_tolerance ? Math.abs(a) * d.ClipperOffset.def_arc_tolerance : this.ArcTolerance,\n          e = 3.14159265358979 / Math.acos(1 - b / Math.abs(a));this.m_sin = Math.sin(d.ClipperOffset.two_pi / e);this.m_cos = Math.cos(d.ClipperOffset.two_pi / e);this.m_StepsPerRad = e / d.ClipperOffset.two_pi;0 > a && (this.m_sin = -this.m_sin);for (b = 0; b < this.m_polyNodes.ChildCount(); b++) {\n        c = this.m_polyNodes.Childs()[b];this.m_srcPoly = c.m_polygon;var f = this.m_srcPoly.length;if (!(0 == f || 0 >= a && (3 > f || c.m_endtype != d.EndType.etClosedPolygon))) {\n          this.m_destPoly = [];if (1 == f) {\n            if (c.m_jointype == d.JoinType.jtRound) for (var c = 1, f = 0, g = 1; g <= e; g++) {\n              this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + c * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + f * a)));var h = c,\n                  c = c * this.m_cos - this.m_sin * f,\n                  f = h * this.m_sin + f * this.m_cos;\n            } else for (f = c = -1, g = 0; 4 > g; ++g) {\n              this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + c * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + f * a))), 0 > c ? c = 1 : 0 > f ? f = 1 : c = -1;\n            }\n          } else {\n            for (g = this.m_normals.length = 0; g < f - 1; g++) {\n              this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[g], this.m_srcPoly[g + 1]));\n            }c.m_endtype == d.EndType.etClosedLine || c.m_endtype == d.EndType.etClosedPolygon ? this.m_normals.push(d.ClipperOffset.GetUnitNormal(this.m_srcPoly[f - 1], this.m_srcPoly[0])) : this.m_normals.push(new d.DoublePoint(this.m_normals[f - 2]));if (c.m_endtype == d.EndType.etClosedPolygon) for (h = f - 1, g = 0; g < f; g++) {\n              h = this.OffsetPoint(g, h, c.m_jointype);\n            } else if (c.m_endtype == d.EndType.etClosedLine) {\n              h = f - 1;for (g = 0; g < f; g++) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }this.m_destPolys.push(this.m_destPoly);this.m_destPoly = [];h = this.m_normals[f - 1];for (g = f - 1; 0 < g; g--) {\n                this.m_normals[g] = new d.DoublePoint(-this.m_normals[g - 1].X, -this.m_normals[g - 1].Y);\n              }this.m_normals[0] = new d.DoublePoint(-h.X, -h.Y);h = 0;for (g = f - 1; 0 <= g; g--) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }\n            } else {\n              h = 0;for (g = 1; g < f - 1; ++g) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }c.m_endtype == d.EndType.etOpenButt ? (g = f - 1, h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X + this.m_normals[g].X * a), d.ClipperOffset.Round(this.m_srcPoly[g].Y + this.m_normals[g].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[g].X - this.m_normals[g].X * a), d.ClipperOffset.Round(this.m_srcPoly[g].Y - this.m_normals[g].Y * a)), this.m_destPoly.push(h)) : (g = f - 1, h = f - 2, this.m_sinA = 0, this.m_normals[g] = new d.DoublePoint(-this.m_normals[g].X, -this.m_normals[g].Y), c.m_endtype == d.EndType.etOpenSquare ? this.DoSquare(g, h) : this.DoRound(g, h));for (g = f - 1; 0 < g; g--) {\n                this.m_normals[g] = new d.DoublePoint(-this.m_normals[g - 1].X, -this.m_normals[g - 1].Y);\n              }this.m_normals[0] = new d.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);h = f - 1;for (g = h - 1; 0 < g; --g) {\n                h = this.OffsetPoint(g, h, c.m_jointype);\n              }c.m_endtype == d.EndType.etOpenButt ? (h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * a)), this.m_destPoly.push(h), h = new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * a), d.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * a)), this.m_destPoly.push(h)) : (this.m_sinA = 0, c.m_endtype == d.EndType.etOpenSquare ? this.DoSquare(0, 1) : this.DoRound(0, 1));\n            }\n          }this.m_destPolys.push(this.m_destPoly);\n        }\n      }\n    }\n  };d.ClipperOffset.prototype.Execute = function () {\n    var a = arguments;if (a[0] instanceof d.PolyTree) {\n      if (b = a[0], c = a[1], b.Clear(), this.FixOrientations(), this.DoOffset(c), a = new d.Clipper(0), a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0), 0 < c) a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive);else if (c = d.Clipper.GetBounds(this.m_destPolys), e = new d.Path(), e.push(new d.IntPoint(c.left - 10, c.bottom + 10)), e.push(new d.IntPoint(c.right + 10, c.bottom + 10)), e.push(new d.IntPoint(c.right + 10, c.top - 10)), e.push(new d.IntPoint(c.left - 10, c.top - 10)), a.AddPath(e, d.PolyType.ptSubject, !0), a.ReverseSolution = !0, a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative), 1 == b.ChildCount() && 0 < b.Childs()[0].ChildCount()) for (a = b.Childs()[0], b.Childs()[0] = a.Childs()[0], c = 1; c < a.ChildCount(); c++) {\n        b.AddChild(a.Childs()[c]);\n      } else b.Clear();\n    } else {\n      var b = a[0],\n          c = a[1];d.Clear(b);this.FixOrientations();this.DoOffset(c);a = new d.Clipper(0);a.AddPaths(this.m_destPolys, d.PolyType.ptSubject, !0);if (0 < c) a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftPositive, d.PolyFillType.pftPositive);else {\n        var c = d.Clipper.GetBounds(this.m_destPolys),\n            e = new d.Path();e.push(new d.IntPoint(c.left - 10, c.bottom + 10));e.push(new d.IntPoint(c.right + 10, c.bottom + 10));e.push(new d.IntPoint(c.right + 10, c.top - 10));e.push(new d.IntPoint(c.left - 10, c.top - 10));a.AddPath(e, d.PolyType.ptSubject, !0);a.ReverseSolution = !0;a.Execute(d.ClipType.ctUnion, b, d.PolyFillType.pftNegative, d.PolyFillType.pftNegative);0 < b.length && b.splice(0, 1);\n      }\n    }\n  };d.ClipperOffset.prototype.OffsetPoint = function (a, b, c) {\n    this.m_sinA = this.m_normals[b].X * this.m_normals[a].Y - this.m_normals[a].X * this.m_normals[b].Y;if (5E-5 > this.m_sinA && -5E-5 < this.m_sinA) return b;\n    1 < this.m_sinA ? this.m_sinA = 1 : -1 > this.m_sinA && (this.m_sinA = -1);if (0 > this.m_sinA * this.m_delta) this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[b].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[b].Y * this.m_delta))), this.m_destPoly.push(new d.IntPoint(this.m_srcPoly[a])), this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));else switch (c) {case d.JoinType.jtMiter:\n        c = 1 + (this.m_normals[a].X * this.m_normals[b].X + this.m_normals[a].Y * this.m_normals[b].Y);c >= this.m_miterLim ? this.DoMiter(a, b, c) : this.DoSquare(a, b);break;case d.JoinType.jtSquare:\n        this.DoSquare(a, b);break;case d.JoinType.jtRound:\n        this.DoRound(a, b);}return a;\n  };d.ClipperOffset.prototype.DoSquare = function (a, b) {\n    var c = Math.tan(Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y) / 4);this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[b].X - this.m_normals[b].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[b].Y + this.m_normals[b].X * c))));this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_delta * (this.m_normals[a].X + this.m_normals[a].Y * c)), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_delta * (this.m_normals[a].Y - this.m_normals[a].X * c))));\n  };d.ClipperOffset.prototype.DoMiter = function (a, b, c) {\n    c = this.m_delta / c;this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + (this.m_normals[b].X + this.m_normals[a].X) * c), d.ClipperOffset.Round(this.m_srcPoly[a].Y + (this.m_normals[b].Y + this.m_normals[a].Y) * c)));\n  };d.ClipperOffset.prototype.DoRound = function (a, b) {\n    for (var c = Math.atan2(this.m_sinA, this.m_normals[b].X * this.m_normals[a].X + this.m_normals[b].Y * this.m_normals[a].Y), c = d.Cast_Int32(d.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(c))), e = this.m_normals[b].X, f = this.m_normals[b].Y, g, h = 0; h < c; ++h) {\n      this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + e * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + f * this.m_delta))), g = e, e = e * this.m_cos - this.m_sin * f, f = g * this.m_sin + f * this.m_cos;\n    }this.m_destPoly.push(new d.IntPoint(d.ClipperOffset.Round(this.m_srcPoly[a].X + this.m_normals[a].X * this.m_delta), d.ClipperOffset.Round(this.m_srcPoly[a].Y + this.m_normals[a].Y * this.m_delta)));\n  };d.Error = function (a) {\n    try {\n      throw Error(a);\n    } catch (b) {\n      alert(b.message);\n    }\n  };d.JS = {};d.JS.AreaOfPolygon = function (a, b) {\n    b || (b = 1);return d.Clipper.Area(a) / (b * b);\n  };d.JS.AreaOfPolygons = function (a, b) {\n    b || (b = 1);for (var c = 0, e = 0; e < a.length; e++) {\n      c += d.Clipper.Area(a[e]);\n    }return c / (b * b);\n  };d.JS.BoundsOfPath = function (a, b) {\n    return d.JS.BoundsOfPaths([a], b);\n  };d.JS.BoundsOfPaths = function (a, b) {\n    b || (b = 1);var c = d.Clipper.GetBounds(a);c.left /= b;c.bottom /= b;c.right /= b;c.top /= b;return c;\n  };d.JS.Clean = function (a, b) {\n    if (!(a instanceof Array)) return [];var c = a[0] instanceof Array;a = d.JS.Clone(a);if ("number" != typeof b || null === b) return d.Error("Delta is not a number in Clean()."), a;if (0 === a.length || 1 == a.length && 0 === a[0].length || 0 > b) return a;c || (a = [a]);for (var e = a.length, f, g, h, l, k, n, m, p = [], q = 0; q < e; q++) {\n      if (g = a[q], f = g.length, 0 !== f) if (3 > f) h = g, p.push(h);else {\n        h = g;l = b * b;k = g[0];for (m = n = 1; m < f; m++) {\n          (g[m].X - k.X) * (g[m].X - k.X) + (g[m].Y - k.Y) * (g[m].Y - k.Y) <= l || (h[n] = g[m], k = g[m], n++);\n        }k = g[n - 1];(g[0].X - k.X) * (g[0].X - k.X) + (g[0].Y - k.Y) * (g[0].Y - k.Y) <= l && n--;n < f && h.splice(n, f - n);h.length && p.push(h);\n      }\n    }!c && p.length ? p = p[0] : c || 0 !== p.length ? c && 0 === p.length && (p = [[]]) : p = [];return p;\n  };d.JS.Clone = function (a) {\n    if (!(a instanceof Array) || 0 === a.length) return [];if (1 == a.length && 0 === a[0].length) return [[]];var b = a[0] instanceof Array;b || (a = [a]);var c = a.length,\n        e,\n        d,\n        g,\n        h,\n        l = Array(c);for (d = 0; d < c; d++) {\n      e = a[d].length;h = Array(e);for (g = 0; g < e; g++) {\n        h[g] = { X: a[d][g].X, Y: a[d][g].Y };\n      }l[d] = h;\n    }b || (l = l[0]);return l;\n  };d.JS.Lighten = function (a, b) {\n    if (!(a instanceof Array)) return [];if ("number" != typeof b || null === b) return d.Error("Tolerance is not a number in Lighten()."), d.JS.Clone(a);if (0 === a.length || 1 == a.length && 0 === a[0].length || 0 > b) return d.JS.Clone(a);a[0] instanceof Array || (a = [a]);var c,\n        e,\n        f,\n        g,\n        h,\n        l,\n        k,\n        m,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u,\n        v,\n        x = a.length,\n        y = b * b,\n        w = [];for (c = 0; c < x; c++) {\n      if (f = a[c], l = f.length, 0 != l) {\n        for (g = 0; 1E6 > g; g++) {\n          h = [];l = f.length;f[l - 1].X != f[0].X || f[l - 1].Y != f[0].Y ? (r = 1, f.push({ X: f[0].X, Y: f[0].Y }), l = f.length) : r = 0;q = [];for (e = 0; e < l - 2; e++) {\n            k = f[e];p = f[e + 1];m = f[e + 2];u = k.X;v = k.Y;k = m.X - u;s = m.Y - v;if (0 !== k || 0 !== s) t = ((p.X - u) * k + (p.Y - v) * s) / (k * k + s * s), 1 < t ? (u = m.X, v = m.Y) : 0 < t && (u += k * t, v += s * t);k = p.X - u;s = p.Y - v;m = k * k + s * s;m <= y && (q[e + 1] = 1, e++);\n          }h.push({ X: f[0].X, Y: f[0].Y });for (e = 1; e < l - 1; e++) {\n            q[e] || h.push({ X: f[e].X, Y: f[e].Y });\n          }h.push({ X: f[l - 1].X, Y: f[l - 1].Y });r && f.pop();if (q.length) f = h;else break;\n        }l = h.length;h[l - 1].X == h[0].X && h[l - 1].Y == h[0].Y && h.pop();2 < h.length && w.push(h);\n      }\n    }!a[0] instanceof Array && (w = w[0]);"undefined" == typeof w && (w = [[]]);return w;\n  };d.JS.PerimeterOfPath = function (a, b, c) {\n    if ("undefined" == typeof a) return 0;var e = Math.sqrt,\n        d = 0,\n        g,\n        h,\n        k = 0,\n        m = g = 0;h = 0;var n = a.length;if (2 > n) return 0;b && (a[n] = a[0], n++);for (; --n;) {\n      g = a[n], k = g.X, g = g.Y, h = a[n - 1], m = h.X, h = h.Y, d += e((k - m) * (k - m) + (g - h) * (g - h));\n    }b && a.pop();return d / c;\n  };d.JS.PerimeterOfPaths = function (a, b, c) {\n    c || (c = 1);for (var e = 0, f = 0; f < a.length; f++) {\n      e += d.JS.PerimeterOfPath(a[f], b, c);\n    }return e;\n  };d.JS.ScaleDownPath = function (a, b) {\n    var c, d;b || (b = 1);for (c = a.length; c--;) {\n      d = a[c], d.X /= b, d.Y /= b;\n    }\n  };d.JS.ScaleDownPaths = function (a, b) {\n    var c, d, f;b || (b = 1);for (c = a.length; c--;) {\n      for (d = a[c].length; d--;) {\n        f = a[c][d], f.X /= b, f.Y /= b;\n      }\n    }\n  };d.JS.ScaleUpPath = function (a, b) {\n    var c,\n        d,\n        f = Math.round;b || (b = 1);for (c = a.length; c--;) {\n      d = a[c], d.X = f(d.X * b), d.Y = f(d.Y * b);\n    }\n  };d.JS.ScaleUpPaths = function (a, b) {\n    var c,\n        d,\n        f,\n        g = Math.round;b || (b = 1);for (c = a.length; c--;) {\n      for (d = a[c].length; d--;) {\n        f = a[c][d], f.X = g(f.X * b), f.Y = g(f.Y * b);\n      }\n    }\n  };d.ExPolygons = function () {\n    return [];\n  };d.ExPolygon = function () {\n    this.holes = this.outer = null;\n  };d.JS.AddOuterPolyNodeToExPolygons = function (a, b) {\n    var c = new d.ExPolygon();c.outer = a.Contour();var e = a.Childs(),\n        f = e.length;c.holes = Array(f);var g, h, k, m, n;for (h = 0; h < f; h++) {\n      for (g = e[h], c.holes[h] = g.Contour(), k = 0, m = g.Childs(), n = m.length; k < n; k++) {\n        g = m[k], d.JS.AddOuterPolyNodeToExPolygons(g, b);\n      }\n    }b.push(c);\n  };d.JS.ExPolygonsToPaths = function (a) {\n    var b,\n        c,\n        e,\n        f,\n        g = new d.Paths();b = 0;for (e = a.length; b < e; b++) {\n      for (g.push(a[b].outer), c = 0, f = a[b].holes.length; c < f; c++) {\n        g.push(a[b].holes[c]);\n      }\n    }return g;\n  };d.JS.PolyTreeToExPolygons = function (a) {\n    var b = new d.ExPolygons(),\n        c,\n        e,\n        f;c = 0;e = a.Childs();for (f = e.length; c < f; c++) {\n      a = e[c], d.JS.AddOuterPolyNodeToExPolygons(a, b);\n    }return b;\n  };\n})();'},705:function(t,n,e){e(77)(e(706))},706:function(t,n){t.exports="'use strict';\n\n/*!\n * General purpose geometry functions for polygon/Bezier calculations\n * Copyright 2015 Jack Qiao\n * Licensed under the MIT license\n */\n\n(function (root) {\n\t'use strict';\n\n\t// private shared variables/methods\n\n\t// floating point comparison tolerance\n\n\tvar TOL = Math.pow(10, -9); // Floating point error is likely to be above 1 epsilon\n\n\tfunction _almostEqual(a, b, tolerance) {\n\t\tif (!tolerance) {\n\t\t\ttolerance = TOL;\n\t\t}\n\t\treturn Math.abs(a - b) < tolerance;\n\t}\n\n\t// returns true if points are within the given distance\n\tfunction _withinDistance(p1, p2, distance) {\n\t\tvar dx = p1.x - p2.x;\n\t\tvar dy = p1.y - p2.y;\n\t\treturn dx * dx + dy * dy < distance * distance;\n\t}\n\n\tfunction _degreesToRadians(angle) {\n\t\treturn angle * (Math.PI / 180);\n\t}\n\n\tfunction _radiansToDegrees(angle) {\n\t\treturn angle * (180 / Math.PI);\n\t}\n\n\t// normalize vector into a unit vector\n\tfunction _normalizeVector(v) {\n\t\tif (_almostEqual(v.x * v.x + v.y * v.y, 1)) {\n\t\t\treturn v; // given vector was already a unit vector\n\t\t}\n\t\tvar len = Math.sqrt(v.x * v.x + v.y * v.y);\n\t\tvar inverse = 1 / len;\n\n\t\treturn {\n\t\t\tx: v.x * inverse,\n\t\t\ty: v.y * inverse\n\t\t};\n\t}\n\n\t// returns true if p lies on the line segment defined by AB, but not at any endpoints\n\t// may need work!\n\tfunction _onSegment(A, B, p) {\n\n\t\t// vertical line\n\t\tif (_almostEqual(A.x, B.x) && _almostEqual(p.x, A.x)) {\n\t\t\tif (!_almostEqual(p.y, B.y) && !_almostEqual(p.y, A.y) && p.y < Math.max(B.y, A.y) && p.y > Math.min(B.y, A.y)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// horizontal line\n\t\tif (_almostEqual(A.y, B.y) && _almostEqual(p.y, A.y)) {\n\t\t\tif (!_almostEqual(p.x, B.x) && !_almostEqual(p.x, A.x) && p.x < Math.max(B.x, A.x) && p.x > Math.min(B.x, A.x)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t//range check\n\t\tif (p.x < A.x && p.x < B.x || p.x > A.x && p.x > B.x || p.y < A.y && p.y < B.y || p.y > A.y && p.y > B.y) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// exclude end points\n\t\tif (_almostEqual(p.x, A.x) && _almostEqual(p.y, A.y) || _almostEqual(p.x, B.x) && _almostEqual(p.y, B.y)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar cross = (p.y - A.y) * (B.x - A.x) - (p.x - A.x) * (B.y - A.y);\n\n\t\tif (Math.abs(cross) > TOL) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar dot = (p.x - A.x) * (B.x - A.x) + (p.y - A.y) * (B.y - A.y);\n\n\t\tif (dot < 0 || _almostEqual(dot, 0)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n\n\t\tif (dot > len2 || _almostEqual(dot, len2)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// returns the intersection of AB and EF\n\t// or null if there are no intersections or other numerical error\n\t// if the infinite flag is set, AE and EF describe infinite lines without endpoints, they are finite line segments otherwise\n\tfunction _lineIntersect(A, B, E, F, infinite) {\n\t\tvar a1, a2, b1, b2, c1, c2, x, y;\n\n\t\ta1 = B.y - A.y;\n\t\tb1 = A.x - B.x;\n\t\tc1 = B.x * A.y - A.x * B.y;\n\t\ta2 = F.y - E.y;\n\t\tb2 = E.x - F.x;\n\t\tc2 = F.x * E.y - E.x * F.y;\n\n\t\tvar denom = a1 * b2 - a2 * b1;\n\n\t\tx = (b1 * c2 - b2 * c1) / denom, y = (a2 * c1 - a1 * c2) / denom;\n\n\t\tif (!isFinite(x) || !isFinite(y)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// lines are colinear\n\t\t/*var crossABE = (E.y - A.y) * (B.x - A.x) - (E.x - A.x) * (B.y - A.y);\n  var crossABF = (F.y - A.y) * (B.x - A.x) - (F.x - A.x) * (B.y - A.y);\n  if(_almostEqual(crossABE,0) && _almostEqual(crossABF,0)){\n  \treturn null;\n  }*/\n\n\t\tif (!infinite) {\n\t\t\t// coincident points do not count as intersecting\n\t\t\tif (Math.abs(A.x - B.x) > TOL && (A.x < B.x ? x < A.x || x > B.x : x > A.x || x < B.x)) return null;\n\t\t\tif (Math.abs(A.y - B.y) > TOL && (A.y < B.y ? y < A.y || y > B.y : y > A.y || y < B.y)) return null;\n\n\t\t\tif (Math.abs(E.x - F.x) > TOL && (E.x < F.x ? x < E.x || x > F.x : x > E.x || x < F.x)) return null;\n\t\t\tif (Math.abs(E.y - F.y) > TOL && (E.y < F.y ? y < E.y || y > F.y : y > E.y || y < F.y)) return null;\n\t\t}\n\n\t\treturn { x: x, y: y };\n\t}\n\n\t// public methods\n\troot.GeometryUtil = {\n\n\t\twithinDistance: _withinDistance,\n\n\t\tlineIntersect: _lineIntersect,\n\n\t\talmostEqual: _almostEqual,\n\n\t\t// Bezier algos from http://algorithmist.net/docs/subdivision.pdf\n\t\tQuadraticBezier: {\n\n\t\t\t// Roger Willcocks bezier flatness criterion\n\t\t\tisFlat: function isFlat(p1, p2, c1, tol) {\n\t\t\t\ttol = 4 * tol * tol;\n\n\t\t\t\tvar ux = 2 * c1.x - p1.x - p2.x;\n\t\t\t\tux *= ux;\n\n\t\t\t\tvar uy = 2 * c1.y - p1.y - p2.y;\n\t\t\t\tuy *= uy;\n\n\t\t\t\treturn ux + uy <= tol;\n\t\t\t},\n\n\t\t\t// turn Bezier into line segments via de Casteljau, returns an array of points\n\t\t\tlinearize: function linearize(p1, p2, c1, tol) {\n\t\t\t\tvar finished = [p1]; // list of points to return\n\t\t\t\tvar todo = [{ p1: p1, p2: p2, c1: c1 }]; // list of Beziers to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tvar segment = todo[0];\n\n\t\t\t\t\tif (this.isFlat(segment.p1, segment.p2, segment.c1, tol)) {\n\t\t\t\t\t\t// reached subdivision limit\n\t\t\t\t\t\tfinished.push({ x: segment.p2.x, y: segment.p2.y });\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar divided = this.subdivide(segment.p1, segment.p2, segment.c1, 0.5);\n\t\t\t\t\t\ttodo.splice(0, 1, divided[0], divided[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\t// subdivide a single Bezier\n\t\t\t// t is the percent along the Bezier to divide at. eg. 0.5\n\t\t\tsubdivide: function subdivide(p1, p2, c1, t) {\n\t\t\t\tvar mid1 = {\n\t\t\t\t\tx: p1.x + (c1.x - p1.x) * t,\n\t\t\t\t\ty: p1.y + (c1.y - p1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid2 = {\n\t\t\t\t\tx: c1.x + (p2.x - c1.x) * t,\n\t\t\t\t\ty: c1.y + (p2.y - c1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid3 = {\n\t\t\t\t\tx: mid1.x + (mid2.x - mid1.x) * t,\n\t\t\t\t\ty: mid1.y + (mid2.y - mid1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar seg1 = { p1: p1, p2: mid3, c1: mid1 };\n\t\t\t\tvar seg2 = { p1: mid3, p2: p2, c1: mid2 };\n\n\t\t\t\treturn [seg1, seg2];\n\t\t\t}\n\t\t},\n\n\t\tCubicBezier: {\n\t\t\tisFlat: function isFlat(p1, p2, c1, c2, tol) {\n\t\t\t\ttol = 16 * tol * tol;\n\n\t\t\t\tvar ux = 3 * c1.x - 2 * p1.x - p2.x;\n\t\t\t\tux *= ux;\n\n\t\t\t\tvar uy = 3 * c1.y - 2 * p1.y - p2.y;\n\t\t\t\tuy *= uy;\n\n\t\t\t\tvar vx = 3 * c2.x - 2 * p2.x - p1.x;\n\t\t\t\tvx *= vx;\n\n\t\t\t\tvar vy = 3 * c2.y - 2 * p2.y - p1.y;\n\t\t\t\tvy *= vy;\n\n\t\t\t\tif (ux < vx) {\n\t\t\t\t\tux = vx;\n\t\t\t\t}\n\t\t\t\tif (uy < vy) {\n\t\t\t\t\tuy = vy;\n\t\t\t\t}\n\n\t\t\t\treturn ux + uy <= tol;\n\t\t\t},\n\n\t\t\tlinearize: function linearize(p1, p2, c1, c2, tol) {\n\t\t\t\tvar finished = [p1]; // list of points to return\n\t\t\t\tvar todo = [{ p1: p1, p2: p2, c1: c1, c2: c2 }]; // list of Beziers to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tvar segment = todo[0];\n\n\t\t\t\t\tif (this.isFlat(segment.p1, segment.p2, segment.c1, segment.c2, tol)) {\n\t\t\t\t\t\t// reached subdivision limit\n\t\t\t\t\t\tfinished.push({ x: segment.p2.x, y: segment.p2.y });\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar divided = this.subdivide(segment.p1, segment.p2, segment.c1, segment.c2, 0.5);\n\t\t\t\t\t\ttodo.splice(0, 1, divided[0], divided[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\tsubdivide: function subdivide(p1, p2, c1, c2, t) {\n\t\t\t\tvar mid1 = {\n\t\t\t\t\tx: p1.x + (c1.x - p1.x) * t,\n\t\t\t\t\ty: p1.y + (c1.y - p1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid2 = {\n\t\t\t\t\tx: c2.x + (p2.x - c2.x) * t,\n\t\t\t\t\ty: c2.y + (p2.y - c2.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mid3 = {\n\t\t\t\t\tx: c1.x + (c2.x - c1.x) * t,\n\t\t\t\t\ty: c1.y + (c2.y - c1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar mida = {\n\t\t\t\t\tx: mid1.x + (mid3.x - mid1.x) * t,\n\t\t\t\t\ty: mid1.y + (mid3.y - mid1.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar midb = {\n\t\t\t\t\tx: mid3.x + (mid2.x - mid3.x) * t,\n\t\t\t\t\ty: mid3.y + (mid2.y - mid3.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar midx = {\n\t\t\t\t\tx: mida.x + (midb.x - mida.x) * t,\n\t\t\t\t\ty: mida.y + (midb.y - mida.y) * t\n\t\t\t\t};\n\n\t\t\t\tvar seg1 = { p1: p1, p2: midx, c1: mid1, c2: mida };\n\t\t\t\tvar seg2 = { p1: midx, p2: p2, c1: midb, c2: mid2 };\n\n\t\t\t\treturn [seg1, seg2];\n\t\t\t}\n\t\t},\n\n\t\tArc: {\n\n\t\t\tlinearize: function linearize(p1, p2, rx, ry, angle, largearc, sweep, tol) {\n\n\t\t\t\tvar finished = [p2]; // list of points to return\n\n\t\t\t\tvar arc = this.svgToCenter(p1, p2, rx, ry, angle, largearc, sweep);\n\t\t\t\tvar todo = [arc]; // list of arcs to divide\n\n\t\t\t\t// recursion could stack overflow, loop instead\n\t\t\t\twhile (todo.length > 0) {\n\t\t\t\t\tarc = todo[0];\n\n\t\t\t\t\tvar fullarc = this.centerToSvg(arc.center, arc.rx, arc.ry, arc.theta, arc.extent, arc.angle);\n\t\t\t\t\tvar subarc = this.centerToSvg(arc.center, arc.rx, arc.ry, arc.theta, 0.5 * arc.extent, arc.angle);\n\t\t\t\t\tvar arcmid = subarc.p2;\n\n\t\t\t\t\tvar mid = {\n\t\t\t\t\t\tx: 0.5 * (fullarc.p1.x + fullarc.p2.x),\n\t\t\t\t\t\ty: 0.5 * (fullarc.p1.y + fullarc.p2.y)\n\n\t\t\t\t\t\t// compare midpoint of line with midpoint of arc\n\t\t\t\t\t\t// this is not 100% accurate, but should be a good heuristic for flatness in most cases\n\t\t\t\t\t};if (_withinDistance(mid, arcmid, tol)) {\n\t\t\t\t\t\tfinished.unshift(fullarc.p2);\n\t\t\t\t\t\ttodo.shift();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar arc1 = {\n\t\t\t\t\t\t\tcenter: arc.center,\n\t\t\t\t\t\t\trx: arc.rx,\n\t\t\t\t\t\t\try: arc.ry,\n\t\t\t\t\t\t\ttheta: arc.theta,\n\t\t\t\t\t\t\textent: 0.5 * arc.extent,\n\t\t\t\t\t\t\tangle: arc.angle\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar arc2 = {\n\t\t\t\t\t\t\tcenter: arc.center,\n\t\t\t\t\t\t\trx: arc.rx,\n\t\t\t\t\t\t\try: arc.ry,\n\t\t\t\t\t\t\ttheta: arc.theta + 0.5 * arc.extent,\n\t\t\t\t\t\t\textent: 0.5 * arc.extent,\n\t\t\t\t\t\t\tangle: arc.angle\n\t\t\t\t\t\t};\n\t\t\t\t\t\ttodo.splice(0, 1, arc1, arc2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn finished;\n\t\t\t},\n\n\t\t\t// convert from center point/angle sweep definition to SVG point and flag definition of arcs\n\t\t\t// ported from http://commons.oreilly.com/wiki/index.php/SVG_Essentials/Paths\n\t\t\tcenterToSvg: function centerToSvg(center, rx, ry, theta1, extent, angleDegrees) {\n\n\t\t\t\tvar theta2 = theta1 + extent;\n\n\t\t\t\ttheta1 = _degreesToRadians(theta1);\n\t\t\t\ttheta2 = _degreesToRadians(theta2);\n\t\t\t\tvar angle = _degreesToRadians(angleDegrees);\n\n\t\t\t\tvar cos = Math.cos(angle);\n\t\t\t\tvar sin = Math.sin(angle);\n\n\t\t\t\tvar t1cos = Math.cos(theta1);\n\t\t\t\tvar t1sin = Math.sin(theta1);\n\n\t\t\t\tvar t2cos = Math.cos(theta2);\n\t\t\t\tvar t2sin = Math.sin(theta2);\n\n\t\t\t\tvar x0 = center.x + cos * rx * t1cos + -sin * ry * t1sin;\n\t\t\t\tvar y0 = center.y + sin * rx * t1cos + cos * ry * t1sin;\n\n\t\t\t\tvar x1 = center.x + cos * rx * t2cos + -sin * ry * t2sin;\n\t\t\t\tvar y1 = center.y + sin * rx * t2cos + cos * ry * t2sin;\n\n\t\t\t\tvar largearc = extent > 180 ? 1 : 0;\n\t\t\t\tvar sweep = extent > 0 ? 1 : 0;\n\n\t\t\t\treturn {\n\t\t\t\t\tp1: { x: x0, y: y0 },\n\t\t\t\t\tp2: { x: x1, y: y1 },\n\t\t\t\t\trx: rx,\n\t\t\t\t\try: ry,\n\t\t\t\t\tangle: angle,\n\t\t\t\t\tlargearc: largearc,\n\t\t\t\t\tsweep: sweep\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t// convert from SVG format arc to center point arc\n\t\t\tsvgToCenter: function svgToCenter(p1, p2, rx, ry, angleDegrees, largearc, sweep) {\n\n\t\t\t\tvar mid = {\n\t\t\t\t\tx: 0.5 * (p1.x + p2.x),\n\t\t\t\t\ty: 0.5 * (p1.y + p2.y)\n\t\t\t\t};\n\n\t\t\t\tvar diff = {\n\t\t\t\t\tx: 0.5 * (p2.x - p1.x),\n\t\t\t\t\ty: 0.5 * (p2.y - p1.y)\n\t\t\t\t};\n\n\t\t\t\tvar angle = _degreesToRadians(angleDegrees % 360);\n\n\t\t\t\tvar cos = Math.cos(angle);\n\t\t\t\tvar sin = Math.sin(angle);\n\n\t\t\t\tvar x1 = cos * diff.x + sin * diff.y;\n\t\t\t\tvar y1 = -sin * diff.x + cos * diff.y;\n\n\t\t\t\trx = Math.abs(rx);\n\t\t\t\try = Math.abs(ry);\n\t\t\t\tvar Prx = rx * rx;\n\t\t\t\tvar Pry = ry * ry;\n\t\t\t\tvar Px1 = x1 * x1;\n\t\t\t\tvar Py1 = y1 * y1;\n\n\t\t\t\tvar radiiCheck = Px1 / Prx + Py1 / Pry;\n\t\t\t\tvar radiiSqrt = Math.sqrt(radiiCheck);\n\t\t\t\tif (radiiCheck > 1) {\n\t\t\t\t\trx = radiiSqrt * rx;\n\t\t\t\t\try = radiiSqrt * ry;\n\t\t\t\t\tPrx = rx * rx;\n\t\t\t\t\tPry = ry * ry;\n\t\t\t\t}\n\n\t\t\t\tvar sign = largearc != sweep ? -1 : 1;\n\t\t\t\tvar sq = (Prx * Pry - Prx * Py1 - Pry * Px1) / (Prx * Py1 + Pry * Px1);\n\n\t\t\t\tsq = sq < 0 ? 0 : sq;\n\n\t\t\t\tvar coef = sign * Math.sqrt(sq);\n\t\t\t\tvar cx1 = coef * (rx * y1 / ry);\n\t\t\t\tvar cy1 = coef * -(ry * x1 / rx);\n\n\t\t\t\tvar cx = mid.x + (cos * cx1 - sin * cy1);\n\t\t\t\tvar cy = mid.y + (sin * cx1 + cos * cy1);\n\n\t\t\t\tvar ux = (x1 - cx1) / rx;\n\t\t\t\tvar uy = (y1 - cy1) / ry;\n\t\t\t\tvar vx = (-x1 - cx1) / rx;\n\t\t\t\tvar vy = (-y1 - cy1) / ry;\n\t\t\t\tvar n = Math.sqrt(ux * ux + uy * uy);\n\t\t\t\tvar p = ux;\n\t\t\t\tsign = uy < 0 ? -1 : 1;\n\n\t\t\t\tvar theta = sign * Math.acos(p / n);\n\t\t\t\ttheta = _radiansToDegrees(theta);\n\n\t\t\t\tn = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\n\t\t\t\tp = ux * vx + uy * vy;\n\t\t\t\tsign = ux * vy - uy * vx < 0 ? -1 : 1;\n\t\t\t\tvar delta = sign * Math.acos(p / n);\n\t\t\t\tdelta = _radiansToDegrees(delta);\n\n\t\t\t\tif (sweep == 1 && delta > 0) {\n\t\t\t\t\tdelta -= 360;\n\t\t\t\t} else if (sweep == 0 && delta < 0) {\n\t\t\t\t\tdelta += 360;\n\t\t\t\t}\n\n\t\t\t\tdelta %= 360;\n\t\t\t\ttheta %= 360;\n\n\t\t\t\treturn {\n\t\t\t\t\tcenter: { x: cx, y: cy },\n\t\t\t\t\trx: rx,\n\t\t\t\t\try: ry,\n\t\t\t\t\ttheta: theta,\n\t\t\t\t\textent: delta,\n\t\t\t\t\tangle: angleDegrees\n\t\t\t\t};\n\t\t\t}\n\n\t\t},\n\n\t\t// returns the rectangular bounding box of the given polygon\n\t\tgetPolygonBounds: function getPolygonBounds(polygon) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar xmin = polygon[0].x;\n\t\t\tvar xmax = polygon[0].x;\n\t\t\tvar ymin = polygon[0].y;\n\t\t\tvar ymax = polygon[0].y;\n\n\t\t\tfor (var i = 1; i < polygon.length; i++) {\n\t\t\t\tif (polygon[i].x > xmax) {\n\t\t\t\t\txmax = polygon[i].x;\n\t\t\t\t} else if (polygon[i].x < xmin) {\n\t\t\t\t\txmin = polygon[i].x;\n\t\t\t\t}\n\n\t\t\t\tif (polygon[i].y > ymax) {\n\t\t\t\t\tymax = polygon[i].y;\n\t\t\t\t} else if (polygon[i].y < ymin) {\n\t\t\t\t\tymin = polygon[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: xmin,\n\t\t\t\ty: ymin,\n\t\t\t\twidth: xmax - xmin,\n\t\t\t\theight: ymax - ymin\n\t\t\t};\n\t\t},\n\n\t\t// return true if point is in the polygon, false if outside, and null if exactly on a point or edge\n\t\tpointInPolygon: function pointInPolygon(point, polygon) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar inside = false;\n\t\t\tvar offsetx = polygon.offsetx || 0;\n\t\t\tvar offsety = polygon.offsety || 0;\n\n\t\t\tfor (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n\t\t\t\tvar xi = polygon[i].x + offsetx;\n\t\t\t\tvar yi = polygon[i].y + offsety;\n\t\t\t\tvar xj = polygon[j].x + offsetx;\n\t\t\t\tvar yj = polygon[j].y + offsety;\n\n\t\t\t\tif (_almostEqual(xi, point.x) && _almostEqual(yi, point.y)) {\n\t\t\t\t\treturn null; // no result\n\t\t\t\t}\n\n\t\t\t\tif (_onSegment({ x: xi, y: yi }, { x: xj, y: yj }, point)) {\n\t\t\t\t\treturn null; // exactly on the segment\n\t\t\t\t}\n\n\t\t\t\tif (_almostEqual(xi, xj) && _almostEqual(yi, yj)) {\n\t\t\t\t\t// ignore very small lines\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;\n\t\t\t\tif (intersect) inside = !inside;\n\t\t\t}\n\n\t\t\treturn inside;\n\t\t},\n\n\t\t// returns the area of the polygon, assuming no self-intersections\n\t\t// a negative area indicates counter-clockwise winding direction\n\t\tpolygonArea: function polygonArea(polygon) {\n\t\t\tvar area = 0;\n\t\t\tvar i, j;\n\t\t\tfor (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n\t\t\t\tarea += (polygon[j].x + polygon[i].x) * (polygon[j].y - polygon[i].y);\n\t\t\t}\n\t\t\treturn 0.5 * area;\n\t\t},\n\n\t\t// todo: swap this for a more efficient sweep-line implementation\n\t\t// returnEdges: if set, return all edges on A that have intersections\n\n\t\tintersect: function intersect(A, B) {\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\tfor (var i = 0; i < A.length - 1; i++) {\n\t\t\t\tfor (var j = 0; j < B.length - 1; j++) {\n\t\t\t\t\tvar a1 = { x: A[i].x + Aoffsetx, y: A[i].y + Aoffsety };\n\t\t\t\t\tvar a2 = { x: A[i + 1].x + Aoffsetx, y: A[i + 1].y + Aoffsety };\n\t\t\t\t\tvar b1 = { x: B[j].x + Boffsetx, y: B[j].y + Boffsety };\n\t\t\t\t\tvar b2 = { x: B[j + 1].x + Boffsetx, y: B[j + 1].y + Boffsety };\n\n\t\t\t\t\tvar prevbindex = j == 0 ? B.length - 1 : j - 1;\n\t\t\t\t\tvar prevaindex = i == 0 ? A.length - 1 : i - 1;\n\t\t\t\t\tvar nextbindex = j + 1 == B.length - 1 ? 0 : j + 2;\n\t\t\t\t\tvar nextaindex = i + 1 == A.length - 1 ? 0 : i + 2;\n\n\t\t\t\t\t// go even further back if we happen to hit on a loop end point\n\t\t\t\t\tif (B[prevbindex] == B[j] || _almostEqual(B[prevbindex].x, B[j].x) && _almostEqual(B[prevbindex].y, B[j].y)) {\n\t\t\t\t\t\tprevbindex = prevbindex == 0 ? B.length - 1 : prevbindex - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (A[prevaindex] == A[i] || _almostEqual(A[prevaindex].x, A[i].x) && _almostEqual(A[prevaindex].y, A[i].y)) {\n\t\t\t\t\t\tprevaindex = prevaindex == 0 ? A.length - 1 : prevaindex - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// go even further forward if we happen to hit on a loop end point\n\t\t\t\t\tif (B[nextbindex] == B[j + 1] || _almostEqual(B[nextbindex].x, B[j + 1].x) && _almostEqual(B[nextbindex].y, B[j + 1].y)) {\n\t\t\t\t\t\tnextbindex = nextbindex == B.length - 1 ? 0 : nextbindex + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (A[nextaindex] == A[i + 1] || _almostEqual(A[nextaindex].x, A[i + 1].x) && _almostEqual(A[nextaindex].y, A[i + 1].y)) {\n\t\t\t\t\t\tnextaindex = nextaindex == A.length - 1 ? 0 : nextaindex + 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar a0 = { x: A[prevaindex].x + Aoffsetx, y: A[prevaindex].y + Aoffsety };\n\t\t\t\t\tvar b0 = { x: B[prevbindex].x + Boffsetx, y: B[prevbindex].y + Boffsety };\n\n\t\t\t\t\tvar a3 = { x: A[nextaindex].x + Aoffsetx, y: A[nextaindex].y + Aoffsety };\n\t\t\t\t\tvar b3 = { x: B[nextbindex].x + Boffsetx, y: B[nextbindex].y + Boffsety };\n\n\t\t\t\t\tif (_onSegment(a1, a2, b1) || _almostEqual(a1.x, b1.x) && _almostEqual(a1.y, b1.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar b0in = this.pointInPolygon(b0, A);\n\t\t\t\t\t\tvar b2in = this.pointInPolygon(b2, A);\n\t\t\t\t\t\tif (b0in === true && b2in === false || b0in === false && b2in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(a1, a2, b2) || _almostEqual(a2.x, b2.x) && _almostEqual(a2.y, b2.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar b1in = this.pointInPolygon(b1, A);\n\t\t\t\t\t\tvar b3in = this.pointInPolygon(b3, A);\n\n\t\t\t\t\t\tif (b1in === true && b3in === false || b1in === false && b3in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(b1, b2, a1) || _almostEqual(a1.x, b2.x) && _almostEqual(a1.y, b2.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar a0in = this.pointInPolygon(a0, B);\n\t\t\t\t\t\tvar a2in = this.pointInPolygon(a2, B);\n\n\t\t\t\t\t\tif (a0in === true && a2in === false || a0in === false && a2in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_onSegment(b1, b2, a2) || _almostEqual(a2.x, b1.x) && _almostEqual(a2.y, b1.y)) {\n\t\t\t\t\t\t// if a point is on a segment, it could intersect or it could not. Check via the neighboring points\n\t\t\t\t\t\tvar a1in = this.pointInPolygon(a1, B);\n\t\t\t\t\t\tvar a3in = this.pointInPolygon(a3, B);\n\n\t\t\t\t\t\tif (a1in === true && a3in === false || a1in === false && a3in === true) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar p = _lineIntersect(b1, b2, a1, a2);\n\n\t\t\t\t\tif (p !== null) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t// placement algos as outlined in [1] http://www.cs.stir.ac.uk/~goc/papers/EffectiveHueristic2DAOR2013.pdf\n\n\t\t// returns a continuous polyline representing the normal-most edge of the given polygon\n\t\t// eg. a normal vector of [-1, 0] will return the left-most edge of the polygon\n\t\t// this is essentially algo 8 in [1], generalized for any vector direction\n\t\tpolygonEdge: function polygonEdge(polygon, normal) {\n\t\t\tif (!polygon || polygon.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar direction = {\n\t\t\t\tx: -normal.y,\n\t\t\t\ty: normal.x\n\t\t\t};\n\n\t\t\t// find the max and min points, they will be the endpoints of our edge\n\t\t\tvar min = null;\n\t\t\tvar max = null;\n\n\t\t\tvar dotproduct = [];\n\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tvar dot = polygon[i].x * direction.x + polygon[i].y * direction.y;\n\t\t\t\tdotproduct.push(dot);\n\t\t\t\tif (min === null || dot < min) {\n\t\t\t\t\tmin = dot;\n\t\t\t\t}\n\t\t\t\tif (max === null || dot > max) {\n\t\t\t\t\tmax = dot;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// there may be multiple vertices with min/max values. In which case we choose the one that is normal-most (eg. left most)\n\t\t\tvar indexmin = 0;\n\t\t\tvar indexmax = 0;\n\n\t\t\tvar normalmin = null;\n\t\t\tvar normalmax = null;\n\n\t\t\tfor (i = 0; i < polygon.length; i++) {\n\t\t\t\tif (_almostEqual(dotproduct[i], min)) {\n\t\t\t\t\tvar dot = polygon[i].x * normal.x + polygon[i].y * normal.y;\n\t\t\t\t\tif (normalmin === null || dot > normalmin) {\n\t\t\t\t\t\tnormalmin = dot;\n\t\t\t\t\t\tindexmin = i;\n\t\t\t\t\t}\n\t\t\t\t} else if (_almostEqual(dotproduct[i], max)) {\n\t\t\t\t\tvar dot = polygon[i].x * normal.x + polygon[i].y * normal.y;\n\t\t\t\t\tif (normalmax === null || dot > normalmax) {\n\t\t\t\t\t\tnormalmax = dot;\n\t\t\t\t\t\tindexmax = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we have two edges bound by min and max points, figure out which edge faces our direction vector\n\n\t\t\tvar indexleft = indexmin - 1;\n\t\t\tvar indexright = indexmin + 1;\n\n\t\t\tif (indexleft < 0) {\n\t\t\t\tindexleft = polygon.length - 1;\n\t\t\t}\n\t\t\tif (indexright >= polygon.length) {\n\t\t\t\tindexright = 0;\n\t\t\t}\n\n\t\t\tvar minvertex = polygon[indexmin];\n\t\t\tvar left = polygon[indexleft];\n\t\t\tvar right = polygon[indexright];\n\n\t\t\tvar leftvector = {\n\t\t\t\tx: left.x - minvertex.x,\n\t\t\t\ty: left.y - minvertex.y\n\t\t\t};\n\n\t\t\tvar rightvector = {\n\t\t\t\tx: right.x - minvertex.x,\n\t\t\t\ty: right.y - minvertex.y\n\t\t\t};\n\n\t\t\tvar dotleft = leftvector.x * direction.x + leftvector.y * direction.y;\n\t\t\tvar dotright = rightvector.x * direction.x + rightvector.y * direction.y;\n\n\t\t\t// -1 = left, 1 = right\n\t\t\tvar scandirection = -1;\n\n\t\t\tif (_almostEqual(dotleft, 0)) {\n\t\t\t\tscandirection = 1;\n\t\t\t} else if (_almostEqual(dotright, 0)) {\n\t\t\t\tscandirection = -1;\n\t\t\t} else {\n\t\t\t\tvar normaldotleft;\n\t\t\t\tvar normaldotright;\n\n\t\t\t\tif (_almostEqual(dotleft, dotright)) {\n\t\t\t\t\t// the points line up exactly along the normal vector\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y;\n\t\t\t\t\tnormaldotright = rightvector.x * normal.x + rightvector.y * normal.y;\n\t\t\t\t} else if (dotleft < dotright) {\n\t\t\t\t\t// normalize right vertex so normal projection can be directly compared\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y;\n\t\t\t\t\tnormaldotright = (rightvector.x * normal.x + rightvector.y * normal.y) * (dotleft / dotright);\n\t\t\t\t} else {\n\t\t\t\t\t// normalize left vertex so normal projection can be directly compared\n\t\t\t\t\tnormaldotleft = leftvector.x * normal.x + leftvector.y * normal.y * (dotright / dotleft);\n\t\t\t\t\tnormaldotright = rightvector.x * normal.x + rightvector.y * normal.y;\n\t\t\t\t}\n\n\t\t\t\tif (normaldotleft > normaldotright) {\n\t\t\t\t\tscandirection = -1;\n\t\t\t\t} else {\n\t\t\t\t\t// technically they could be equal, (ie. the segments bound by left and right points are incident)\n\t\t\t\t\t// in which case we'll have to climb up the chain until lines are no longer incident\n\t\t\t\t\t// for now we'll just not handle it and assume people aren't giving us garbage input..\n\t\t\t\t\tscandirection = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// connect all points between indexmin and indexmax along the scan direction\n\t\t\tvar edge = [];\n\t\t\tvar count = 0;\n\t\t\ti = indexmin;\n\t\t\twhile (count < polygon.length) {\n\t\t\t\tif (i >= polygon.length) {\n\t\t\t\t\ti = 0;\n\t\t\t\t} else if (i < 0) {\n\t\t\t\t\ti = polygon.length - 1;\n\t\t\t\t}\n\n\t\t\t\tedge.push(polygon[i]);\n\n\t\t\t\tif (i == indexmax) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti += scandirection;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\treturn edge;\n\t\t},\n\n\t\t// returns the normal distance from p to a line segment defined by s1 s2\n\t\t// this is basically algo 9 in [1], generalized for any vector direction\n\t\t// eg. normal of [-1, 0] returns the horizontal distance between the point and the line segment\n\t\t// sxinclusive: if true, include endpoints instead of excluding them\n\n\t\tpointLineDistance: function pointLineDistance(p, s1, s2, normal, s1inclusive, s2inclusive) {\n\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar dir = {\n\t\t\t\tx: normal.y,\n\t\t\t\ty: -normal.x\n\t\t\t};\n\n\t\t\tvar pdot = p.x * dir.x + p.y * dir.y;\n\t\t\tvar s1dot = s1.x * dir.x + s1.y * dir.y;\n\t\t\tvar s2dot = s2.x * dir.x + s2.y * dir.y;\n\n\t\t\tvar pdotnorm = p.x * normal.x + p.y * normal.y;\n\t\t\tvar s1dotnorm = s1.x * normal.x + s1.y * normal.y;\n\t\t\tvar s2dotnorm = s2.x * normal.x + s2.y * normal.y;\n\n\t\t\t// point is exactly along the edge in the normal direction\n\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot)) {\n\t\t\t\t// point lies on an endpoint\n\t\t\t\tif (_almostEqual(pdotnorm, s1dotnorm)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (_almostEqual(pdotnorm, s2dotnorm)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// point is outside both endpoints\n\t\t\t\tif (pdotnorm > s1dotnorm && pdotnorm > s2dotnorm) {\n\t\t\t\t\treturn Math.min(pdotnorm - s1dotnorm, pdotnorm - s2dotnorm);\n\t\t\t\t}\n\t\t\t\tif (pdotnorm < s1dotnorm && pdotnorm < s2dotnorm) {\n\t\t\t\t\treturn -Math.min(s1dotnorm - pdotnorm, s2dotnorm - pdotnorm);\n\t\t\t\t}\n\n\t\t\t\t// point lies between endpoints\n\t\t\t\tvar diff1 = pdotnorm - s1dotnorm;\n\t\t\t\tvar diff2 = pdotnorm - s2dotnorm;\n\t\t\t\tif (diff1 > 0) {\n\t\t\t\t\treturn diff1;\n\t\t\t\t} else {\n\t\t\t\t\treturn diff2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// point \n\t\t\telse if (_almostEqual(pdot, s1dot)) {\n\t\t\t\t\tif (s1inclusive) {\n\t\t\t\t\t\treturn pdotnorm - s1dotnorm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (_almostEqual(pdot, s2dot)) {\n\t\t\t\t\tif (s2inclusive) {\n\t\t\t\t\t\treturn pdotnorm - s2dotnorm;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (pdot < s1dot && pdot < s2dot || pdot > s1dot && pdot > s2dot) {\n\t\t\t\t\treturn null; // point doesn't collide with segment\n\t\t\t\t}\n\n\t\t\treturn pdotnorm - s1dotnorm + (s1dotnorm - s2dotnorm) * (s1dot - pdot) / (s1dot - s2dot);\n\t\t},\n\n\t\tpointDistance: function pointDistance(p, s1, s2, normal, infinite) {\n\t\t\tnormal = _normalizeVector(normal);\n\n\t\t\tvar dir = {\n\t\t\t\tx: normal.y,\n\t\t\t\ty: -normal.x\n\t\t\t};\n\n\t\t\tvar pdot = p.x * dir.x + p.y * dir.y;\n\t\t\tvar s1dot = s1.x * dir.x + s1.y * dir.y;\n\t\t\tvar s2dot = s2.x * dir.x + s2.y * dir.y;\n\n\t\t\tvar pdotnorm = p.x * normal.x + p.y * normal.y;\n\t\t\tvar s1dotnorm = s1.x * normal.x + s1.y * normal.y;\n\t\t\tvar s2dotnorm = s2.x * normal.x + s2.y * normal.y;\n\n\t\t\tif (!infinite) {\n\t\t\t\tif ((pdot < s1dot || _almostEqual(pdot, s1dot)) && (pdot < s2dot || _almostEqual(pdot, s2dot)) || (pdot > s1dot || _almostEqual(pdot, s1dot)) && (pdot > s2dot || _almostEqual(pdot, s2dot))) {\n\t\t\t\t\treturn null; // dot doesn't collide with segment, or lies directly on the vertex\n\t\t\t\t}\n\t\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot) && pdotnorm > s1dotnorm && pdotnorm > s2dotnorm) {\n\t\t\t\t\treturn Math.min(pdotnorm - s1dotnorm, pdotnorm - s2dotnorm);\n\t\t\t\t}\n\t\t\t\tif (_almostEqual(pdot, s1dot) && _almostEqual(pdot, s2dot) && pdotnorm < s1dotnorm && pdotnorm < s2dotnorm) {\n\t\t\t\t\treturn -Math.min(s1dotnorm - pdotnorm, s2dotnorm - pdotnorm);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -(pdotnorm - s1dotnorm + (s1dotnorm - s2dotnorm) * (s1dot - pdot) / (s1dot - s2dot));\n\t\t},\n\n\t\tsegmentDistance: function segmentDistance(A, B, E, F, direction) {\n\t\t\tvar normal = {\n\t\t\t\tx: direction.y,\n\t\t\t\ty: -direction.x\n\t\t\t};\n\n\t\t\tvar reverse = {\n\t\t\t\tx: -direction.x,\n\t\t\t\ty: -direction.y\n\t\t\t};\n\n\t\t\tvar dotA = A.x * normal.x + A.y * normal.y;\n\t\t\tvar dotB = B.x * normal.x + B.y * normal.y;\n\t\t\tvar dotE = E.x * normal.x + E.y * normal.y;\n\t\t\tvar dotF = F.x * normal.x + F.y * normal.y;\n\n\t\t\tvar crossA = A.x * direction.x + A.y * direction.y;\n\t\t\tvar crossB = B.x * direction.x + B.y * direction.y;\n\t\t\tvar crossE = E.x * direction.x + E.y * direction.y;\n\t\t\tvar crossF = F.x * direction.x + F.y * direction.y;\n\n\t\t\tvar crossABmin = Math.min(crossA, crossB);\n\t\t\tvar crossABmax = Math.max(crossA, crossB);\n\n\t\t\tvar crossEFmax = Math.max(crossE, crossF);\n\t\t\tvar crossEFmin = Math.min(crossE, crossF);\n\n\t\t\tvar ABmin = Math.min(dotA, dotB);\n\t\t\tvar ABmax = Math.max(dotA, dotB);\n\n\t\t\tvar EFmax = Math.max(dotE, dotF);\n\t\t\tvar EFmin = Math.min(dotE, dotF);\n\n\t\t\t// segments that will merely touch at one point\n\t\t\tif (_almostEqual(ABmax, EFmin, TOL) || _almostEqual(ABmin, EFmax, TOL)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// segments miss eachother completely\n\t\t\tif (ABmax < EFmin || ABmin > EFmax) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar overlap;\n\n\t\t\tif (ABmax > EFmax && ABmin < EFmin || EFmax > ABmax && EFmin < ABmin) {\n\t\t\t\toverlap = 1;\n\t\t\t} else {\n\t\t\t\tvar minMax = Math.min(ABmax, EFmax);\n\t\t\t\tvar maxMin = Math.max(ABmin, EFmin);\n\n\t\t\t\tvar maxMax = Math.max(ABmax, EFmax);\n\t\t\t\tvar minMin = Math.min(ABmin, EFmin);\n\n\t\t\t\toverlap = (minMax - maxMin) / (maxMax - minMin);\n\t\t\t}\n\n\t\t\tvar crossABE = (E.y - A.y) * (B.x - A.x) - (E.x - A.x) * (B.y - A.y);\n\t\t\tvar crossABF = (F.y - A.y) * (B.x - A.x) - (F.x - A.x) * (B.y - A.y);\n\n\t\t\t// lines are colinear\n\t\t\tif (_almostEqual(crossABE, 0) && _almostEqual(crossABF, 0)) {\n\n\t\t\t\tvar ABnorm = { x: B.y - A.y, y: A.x - B.x };\n\t\t\t\tvar EFnorm = { x: F.y - E.y, y: E.x - F.x };\n\n\t\t\t\tvar ABnormlength = Math.sqrt(ABnorm.x * ABnorm.x + ABnorm.y * ABnorm.y);\n\t\t\t\tABnorm.x /= ABnormlength;\n\t\t\t\tABnorm.y /= ABnormlength;\n\n\t\t\t\tvar EFnormlength = Math.sqrt(EFnorm.x * EFnorm.x + EFnorm.y * EFnorm.y);\n\t\t\t\tEFnorm.x /= EFnormlength;\n\t\t\t\tEFnorm.y /= EFnormlength;\n\n\t\t\t\t// segment normals must point in opposite directions\n\t\t\t\tif (Math.abs(ABnorm.y * EFnorm.x - ABnorm.x * EFnorm.y) < TOL && ABnorm.y * EFnorm.y + ABnorm.x * EFnorm.x < 0) {\n\t\t\t\t\t// normal of AB segment must point in same direction as given direction vector\n\t\t\t\t\tvar normdot = ABnorm.y * direction.y + ABnorm.x * direction.x;\n\t\t\t\t\t// the segments merely slide along eachother\n\t\t\t\t\tif (_almostEqual(normdot, 0, TOL)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tif (normdot < 0) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar distances = [];\n\n\t\t\t// coincident points\n\t\t\tif (_almostEqual(dotA, dotE)) {\n\t\t\t\tdistances.push(crossA - crossE);\n\t\t\t} else if (_almostEqual(dotA, dotF)) {\n\t\t\t\tdistances.push(crossA - crossF);\n\t\t\t} else if (dotA > EFmin && dotA < EFmax) {\n\t\t\t\tvar d = this.pointDistance(A, E, F, reverse);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t//  A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dB = this.pointDistance(B, E, F, reverse, true);\n\t\t\t\t\tif (dB < 0 || _almostEqual(dB * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_almostEqual(dotB, dotE)) {\n\t\t\t\tdistances.push(crossB - crossE);\n\t\t\t} else if (_almostEqual(dotB, dotF)) {\n\t\t\t\tdistances.push(crossB - crossF);\n\t\t\t} else if (dotB > EFmin && dotB < EFmax) {\n\t\t\t\tvar d = this.pointDistance(B, E, F, reverse);\n\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// crossA>crossB A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dA = this.pointDistance(A, E, F, reverse, true);\n\t\t\t\t\tif (dA < 0 || _almostEqual(dA * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dotE > ABmin && dotE < ABmax) {\n\t\t\t\tvar d = this.pointDistance(E, A, B, direction);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// crossF<crossE A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dF = this.pointDistance(F, A, B, direction, true);\n\t\t\t\t\tif (dF < 0 || _almostEqual(dF * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dotF > ABmin && dotF < ABmax) {\n\t\t\t\tvar d = this.pointDistance(F, A, B, direction);\n\t\t\t\tif (d !== null && _almostEqual(d, 0)) {\n\t\t\t\t\t// && crossE<crossF A currently touches EF, but AB is moving away from EF\n\t\t\t\t\tvar dE = this.pointDistance(E, A, B, direction, true);\n\t\t\t\t\tif (dE < 0 || _almostEqual(dE * overlap, 0)) {\n\t\t\t\t\t\td = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (d !== null) {\n\t\t\t\t\tdistances.push(d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (distances.length == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn Math.min.apply(Math, distances);\n\t\t},\n\n\t\tpolygonSlideDistance: function polygonSlideDistance(A, B, direction, ignoreNegative) {\n\n\t\t\tvar A1, A2, B1, B2, Aoffsetx, Aoffsety, Boffsetx, Boffsety;\n\n\t\t\tAoffsetx = A.offsetx || 0;\n\t\t\tAoffsety = A.offsety || 0;\n\n\t\t\tBoffsetx = B.offsetx || 0;\n\t\t\tBoffsety = B.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tvar edgeA = A;\n\t\t\tvar edgeB = B;\n\n\t\t\tvar distance = null;\n\t\t\tvar p, s1, s2, d;\n\n\t\t\tvar dir = _normalizeVector(direction);\n\n\t\t\tvar normal = {\n\t\t\t\tx: dir.y,\n\t\t\t\ty: -dir.x\n\t\t\t};\n\n\t\t\tvar reverse = {\n\t\t\t\tx: -dir.x,\n\t\t\t\ty: -dir.y\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < edgeB.length - 1; i++) {\n\t\t\t\tvar mind = null;\n\t\t\t\tfor (var j = 0; j < edgeA.length - 1; j++) {\n\t\t\t\t\tA1 = { x: edgeA[j].x + Aoffsetx, y: edgeA[j].y + Aoffsety };\n\t\t\t\t\tA2 = { x: edgeA[j + 1].x + Aoffsetx, y: edgeA[j + 1].y + Aoffsety };\n\t\t\t\t\tB1 = { x: edgeB[i].x + Boffsetx, y: edgeB[i].y + Boffsety };\n\t\t\t\t\tB2 = { x: edgeB[i + 1].x + Boffsetx, y: edgeB[i + 1].y + Boffsety };\n\n\t\t\t\t\tif (_almostEqual(A1.x, A2.x) && _almostEqual(A1.y, A2.y) || _almostEqual(B1.x, B2.x) && _almostEqual(B1.y, B2.y)) {\n\t\t\t\t\t\tcontinue; // ignore extremely small lines\n\t\t\t\t\t}\n\n\t\t\t\t\td = this.segmentDistance(A1, A2, B1, B2, dir);\n\n\t\t\t\t\tif (d !== null && (distance === null || d < distance)) {\n\t\t\t\t\t\tif (!ignoreNegative || d > 0 || _almostEqual(d, 0)) {\n\t\t\t\t\t\t\tdistance = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn distance;\n\t\t},\n\n\t\t// project each point of B onto A in the given direction, and return the \n\t\tpolygonProjectionDistance: function polygonProjectionDistance(A, B, direction) {\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tvar edgeA = A;\n\t\t\tvar edgeB = B;\n\n\t\t\tvar distance = null;\n\t\t\tvar p, d, s1, s2;\n\n\t\t\tfor (var i = 0; i < edgeB.length; i++) {\n\t\t\t\t// the shortest/most negative projection of B onto A\n\t\t\t\tvar minprojection = null;\n\t\t\t\tvar minp = null;\n\t\t\t\tfor (var j = 0; j < edgeA.length - 1; j++) {\n\t\t\t\t\tp = { x: edgeB[i].x + Boffsetx, y: edgeB[i].y + Boffsety };\n\t\t\t\t\ts1 = { x: edgeA[j].x + Aoffsetx, y: edgeA[j].y + Aoffsety };\n\t\t\t\t\ts2 = { x: edgeA[j + 1].x + Aoffsetx, y: edgeA[j + 1].y + Aoffsety };\n\n\t\t\t\t\tif (Math.abs((s2.y - s1.y) * direction.x - (s2.x - s1.x) * direction.y) < TOL) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// project point, ignore edge boundaries\n\t\t\t\t\td = this.pointDistance(p, s1, s2, direction);\n\n\t\t\t\t\tif (d !== null && (minprojection === null || d < minprojection)) {\n\t\t\t\t\t\tminprojection = d;\n\t\t\t\t\t\tminp = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (minprojection !== null && (distance === null || minprojection > distance)) {\n\t\t\t\t\tdistance = minprojection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn distance;\n\t\t},\n\n\t\t// searches for an arrangement of A and B such that they do not overlap\n\t\t// if an NFP is given, only search for startpoints that have not already been traversed in the given NFP\n\t\tsearchStartPoint: function searchStartPoint(A, B, inside, NFP) {\n\t\t\t// clone arrays\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\t// close the loop for polygons\n\t\t\tif (A[0] != A[A.length - 1]) {\n\t\t\t\tA.push(A[0]);\n\t\t\t}\n\n\t\t\tif (B[0] != B[B.length - 1]) {\n\t\t\t\tB.push(B[0]);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < A.length - 1; i++) {\n\t\t\t\tif (!A[i].marked) {\n\t\t\t\t\tA[i].marked = true;\n\t\t\t\t\tfor (var j = 0; j < B.length; j++) {\n\t\t\t\t\t\tB.offsetx = A[i].x - B[j].x;\n\t\t\t\t\t\tB.offsety = A[i].y - B[j].y;\n\n\t\t\t\t\t\tvar Binside = null;\n\t\t\t\t\t\tfor (var k = 0; k < B.length; k++) {\n\t\t\t\t\t\t\tvar inpoly = this.pointInPolygon({ x: B[k].x + B.offsetx, y: B[k].y + B.offsety }, A);\n\t\t\t\t\t\t\tif (inpoly !== null) {\n\t\t\t\t\t\t\t\tBinside = inpoly;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (Binside === null) {\n\t\t\t\t\t\t\t// A and B are the same\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar startPoint = { x: B.offsetx, y: B.offsety };\n\t\t\t\t\t\tif ((Binside && inside || !Binside && !inside) && !this.intersect(A, B) && !inNfp(startPoint, NFP)) {\n\t\t\t\t\t\t\treturn startPoint;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// slide B along vector\n\t\t\t\t\t\tvar vx = A[i + 1].x - A[i].x;\n\t\t\t\t\t\tvar vy = A[i + 1].y - A[i].y;\n\n\t\t\t\t\t\tvar d1 = this.polygonProjectionDistance(A, B, { x: vx, y: vy });\n\t\t\t\t\t\tvar d2 = this.polygonProjectionDistance(B, A, { x: -vx, y: -vy });\n\n\t\t\t\t\t\tvar d = null;\n\n\t\t\t\t\t\t// todo: clean this up\n\t\t\t\t\t\tif (d1 === null && d2 === null) {\n\t\t\t\t\t\t\t// nothin\n\t\t\t\t\t\t} else if (d1 === null) {\n\t\t\t\t\t\t\td = d2;\n\t\t\t\t\t\t} else if (d2 === null) {\n\t\t\t\t\t\t\td = d1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\td = Math.min(d1, d2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only slide until no longer negative\n\t\t\t\t\t\t// todo: clean this up\n\t\t\t\t\t\tif (d !== null && !_almostEqual(d, 0) && d > 0) {} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar vd2 = vx * vx + vy * vy;\n\n\t\t\t\t\t\tif (d * d < vd2 && !_almostEqual(d * d, vd2)) {\n\t\t\t\t\t\t\tvar vd = Math.sqrt(vx * vx + vy * vy);\n\t\t\t\t\t\t\tvx *= d / vd;\n\t\t\t\t\t\t\tvy *= d / vd;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tB.offsetx += vx;\n\t\t\t\t\t\tB.offsety += vy;\n\n\t\t\t\t\t\tfor (k = 0; k < B.length; k++) {\n\t\t\t\t\t\t\tvar inpoly = this.pointInPolygon({ x: B[k].x + B.offsetx, y: B[k].y + B.offsety }, A);\n\t\t\t\t\t\t\tif (inpoly !== null) {\n\t\t\t\t\t\t\t\tBinside = inpoly;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstartPoint = { x: B.offsetx, y: B.offsety };\n\t\t\t\t\t\tif ((Binside && inside || !Binside && !inside) && !this.intersect(A, B) && !inNfp(startPoint, NFP)) {\n\t\t\t\t\t\t\treturn startPoint;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// returns true if point already exists in the given nfp\n\t\t\tfunction inNfp(p, nfp) {\n\t\t\t\tif (!nfp || nfp.length == 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < nfp.length; i++) {\n\t\t\t\t\tfor (var j = 0; j < nfp[i].length; j++) {\n\t\t\t\t\t\tif (_almostEqual(p.x, nfp[i][j].x) && _almostEqual(p.y, nfp[i][j].y)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tisRectangle: function isRectangle(poly, tolerance) {\n\t\t\tvar bb = this.getPolygonBounds(poly);\n\t\t\ttolerance = tolerance || TOL;\n\n\t\t\tfor (var i = 0; i < poly.length; i++) {\n\t\t\t\tif (!_almostEqual(poly[i].x, bb.x) && !_almostEqual(poly[i].x, bb.x + bb.width)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!_almostEqual(poly[i].y, bb.y) && !_almostEqual(poly[i].y, bb.y + bb.height)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t// returns an interior NFP for the special case where A is a rectangle\n\t\tnoFitPolygonRectangle: function noFitPolygonRectangle(A, B) {\n\t\t\tvar minAx = A[0].x;\n\t\t\tvar minAy = A[0].y;\n\t\t\tvar maxAx = A[0].x;\n\t\t\tvar maxAy = A[0].y;\n\n\t\t\tfor (var i = 1; i < A.length; i++) {\n\t\t\t\tif (A[i].x < minAx) {\n\t\t\t\t\tminAx = A[i].x;\n\t\t\t\t}\n\t\t\t\tif (A[i].y < minAy) {\n\t\t\t\t\tminAy = A[i].y;\n\t\t\t\t}\n\t\t\t\tif (A[i].x > maxAx) {\n\t\t\t\t\tmaxAx = A[i].x;\n\t\t\t\t}\n\t\t\t\tif (A[i].y > maxAy) {\n\t\t\t\t\tmaxAy = A[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar minBx = B[0].x;\n\t\t\tvar minBy = B[0].y;\n\t\t\tvar maxBx = B[0].x;\n\t\t\tvar maxBy = B[0].y;\n\t\t\tfor (i = 1; i < B.length; i++) {\n\t\t\t\tif (B[i].x < minBx) {\n\t\t\t\t\tminBx = B[i].x;\n\t\t\t\t}\n\t\t\t\tif (B[i].y < minBy) {\n\t\t\t\t\tminBy = B[i].y;\n\t\t\t\t}\n\t\t\t\tif (B[i].x > maxBx) {\n\t\t\t\t\tmaxBx = B[i].x;\n\t\t\t\t}\n\t\t\t\tif (B[i].y > maxBy) {\n\t\t\t\t\tmaxBy = B[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (maxBx - minBx > maxAx - minAx) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (maxBy - minBy > maxAy - minAy) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn [[{ x: minAx - minBx + B[0].x, y: minAy - minBy + B[0].y }, { x: maxAx - maxBx + B[0].x, y: minAy - minBy + B[0].y }, { x: maxAx - maxBx + B[0].x, y: maxAy - maxBy + B[0].y }, { x: minAx - minBx + B[0].x, y: maxAy - maxBy + B[0].y }]];\n\t\t},\n\n\t\t// given a static polygon A and a movable polygon B, compute a no fit polygon by orbiting B about A\n\t\t// if the inside flag is set, B is orbited inside of A rather than outside\n\t\t// if the searchEdges flag is set, all edges of A are explored for NFPs - multiple \n\t\tnoFitPolygon: function noFitPolygon(A, B, inside, searchEdges) {\n\t\t\tif (!A || A.length < 3 || !B || B.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tA.offsetx = 0;\n\t\t\tA.offsety = 0;\n\n\t\t\tvar i, j;\n\n\t\t\tvar minA = A[0].y;\n\t\t\tvar minAindex = 0;\n\n\t\t\tvar maxB = B[0].y;\n\t\t\tvar maxBindex = 0;\n\n\t\t\tfor (i = 1; i < A.length; i++) {\n\t\t\t\tA[i].marked = false;\n\t\t\t\tif (A[i].y < minA) {\n\t\t\t\t\tminA = A[i].y;\n\t\t\t\t\tminAindex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 1; i < B.length; i++) {\n\t\t\t\tB[i].marked = false;\n\t\t\t\tif (B[i].y > maxB) {\n\t\t\t\t\tmaxB = B[i].y;\n\t\t\t\t\tmaxBindex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inside) {\n\t\t\t\t// shift B such that the bottom-most point of B is at the top-most point of A. This guarantees an initial placement with no intersections\n\t\t\t\tvar startpoint = {\n\t\t\t\t\tx: A[minAindex].x - B[maxBindex].x,\n\t\t\t\t\ty: A[minAindex].y - B[maxBindex].y\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// no reliable heuristic for inside\n\t\t\t\tvar startpoint = this.searchStartPoint(A, B, true);\n\t\t\t}\n\n\t\t\tvar NFPlist = [];\n\n\t\t\twhile (startpoint !== null) {\n\n\t\t\t\tB.offsetx = startpoint.x;\n\t\t\t\tB.offsety = startpoint.y;\n\n\t\t\t\t// maintain a list of touching points/edges\n\t\t\t\tvar touching;\n\n\t\t\t\tvar prevvector = null; // keep track of previous vector\n\t\t\t\tvar NFP = [{\n\t\t\t\t\tx: B[0].x + B.offsetx,\n\t\t\t\t\ty: B[0].y + B.offsety\n\t\t\t\t}];\n\n\t\t\t\tvar referencex = B[0].x + B.offsetx;\n\t\t\t\tvar referencey = B[0].y + B.offsety;\n\t\t\t\tvar startx = referencex;\n\t\t\t\tvar starty = referencey;\n\t\t\t\tvar counter = 0;\n\n\t\t\t\twhile (counter < 10 * (A.length + B.length)) {\n\t\t\t\t\t// sanity check, prevent infinite loop\n\t\t\t\t\ttouching = [];\n\t\t\t\t\t// find touching vertices/edges\n\t\t\t\t\tfor (i = 0; i < A.length; i++) {\n\t\t\t\t\t\tvar nexti = i == A.length - 1 ? 0 : i + 1;\n\t\t\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\t\t\tif (_almostEqual(A[i].x, B[j].x + B.offsetx) && _almostEqual(A[i].y, B[j].y + B.offsety)) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 0, A: i, B: j });\n\t\t\t\t\t\t\t} else if (_onSegment(A[i], A[nexti], { x: B[j].x + B.offsetx, y: B[j].y + B.offsety })) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 1, A: nexti, B: j });\n\t\t\t\t\t\t\t} else if (_onSegment({ x: B[j].x + B.offsetx, y: B[j].y + B.offsety }, { x: B[nextj].x + B.offsetx, y: B[nextj].y + B.offsety }, A[i])) {\n\t\t\t\t\t\t\t\ttouching.push({ type: 2, A: i, B: nextj });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// generate translation vectors from touching vertices/edges\n\t\t\t\t\tvar vectors = [];\n\t\t\t\t\tfor (i = 0; i < touching.length; i++) {\n\t\t\t\t\t\tvar vertexA = A[touching[i].A];\n\t\t\t\t\t\tvertexA.marked = true;\n\n\t\t\t\t\t\t// adjacent A vertices\n\t\t\t\t\t\tvar prevAindex = touching[i].A - 1;\n\t\t\t\t\t\tvar nextAindex = touching[i].A + 1;\n\n\t\t\t\t\t\tprevAindex = prevAindex < 0 ? A.length - 1 : prevAindex; // loop\n\t\t\t\t\t\tnextAindex = nextAindex >= A.length ? 0 : nextAindex; // loop\n\n\t\t\t\t\t\tvar prevA = A[prevAindex];\n\t\t\t\t\t\tvar nextA = A[nextAindex];\n\n\t\t\t\t\t\t// adjacent B vertices\n\t\t\t\t\t\tvar vertexB = B[touching[i].B];\n\n\t\t\t\t\t\tvar prevBindex = touching[i].B - 1;\n\t\t\t\t\t\tvar nextBindex = touching[i].B + 1;\n\n\t\t\t\t\t\tprevBindex = prevBindex < 0 ? B.length - 1 : prevBindex; // loop\n\t\t\t\t\t\tnextBindex = nextBindex >= B.length ? 0 : nextBindex; // loop\n\n\t\t\t\t\t\tvar prevB = B[prevBindex];\n\t\t\t\t\t\tvar nextB = B[nextBindex];\n\n\t\t\t\t\t\tif (touching[i].type == 0) {\n\n\t\t\t\t\t\t\tvar vA1 = {\n\t\t\t\t\t\t\t\tx: prevA.x - vertexA.x,\n\t\t\t\t\t\t\t\ty: prevA.y - vertexA.y,\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: prevA\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar vA2 = {\n\t\t\t\t\t\t\t\tx: nextA.x - vertexA.x,\n\t\t\t\t\t\t\t\ty: nextA.y - vertexA.y,\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: nextA\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// B vectors need to be inverted\n\t\t\t\t\t\t\tvar vB1 = {\n\t\t\t\t\t\t\t\tx: vertexB.x - prevB.x,\n\t\t\t\t\t\t\t\ty: vertexB.y - prevB.y,\n\t\t\t\t\t\t\t\tstart: prevB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar vB2 = {\n\t\t\t\t\t\t\t\tx: vertexB.x - nextB.x,\n\t\t\t\t\t\t\t\ty: vertexB.y - nextB.y,\n\t\t\t\t\t\t\t\tstart: nextB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvectors.push(vA1);\n\t\t\t\t\t\t\tvectors.push(vA2);\n\t\t\t\t\t\t\tvectors.push(vB1);\n\t\t\t\t\t\t\tvectors.push(vB2);\n\t\t\t\t\t\t} else if (touching[i].type == 1) {\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: prevA,\n\t\t\t\t\t\t\t\tend: vertexA\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: prevA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: prevA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: vertexA,\n\t\t\t\t\t\t\t\tend: prevA\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (touching[i].type == 2) {\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (vertexB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (vertexB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: prevB,\n\t\t\t\t\t\t\t\tend: vertexB\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tvectors.push({\n\t\t\t\t\t\t\t\tx: vertexA.x - (prevB.x + B.offsetx),\n\t\t\t\t\t\t\t\ty: vertexA.y - (prevB.y + B.offsety),\n\t\t\t\t\t\t\t\tstart: vertexB,\n\t\t\t\t\t\t\t\tend: prevB\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// todo: there should be a faster way to reject vectors that will cause immediate intersection. For now just check them all\n\n\t\t\t\t\tvar translate = null;\n\t\t\t\t\tvar maxd = 0;\n\n\t\t\t\t\tfor (i = 0; i < vectors.length; i++) {\n\t\t\t\t\t\tif (vectors[i].x == 0 && vectors[i].y == 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if this vector points us back to where we came from, ignore it.\n\t\t\t\t\t\t// ie cross product = 0, dot product < 0\n\t\t\t\t\t\tif (prevvector && vectors[i].y * prevvector.y + vectors[i].x * prevvector.x < 0) {\n\n\t\t\t\t\t\t\t// compare magnitude with unit vectors\n\t\t\t\t\t\t\tvar vectorlength = Math.sqrt(vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y);\n\t\t\t\t\t\t\tvar unitv = { x: vectors[i].x / vectorlength, y: vectors[i].y / vectorlength };\n\n\t\t\t\t\t\t\tvar prevlength = Math.sqrt(prevvector.x * prevvector.x + prevvector.y * prevvector.y);\n\t\t\t\t\t\t\tvar prevunit = { x: prevvector.x / prevlength, y: prevvector.y / prevlength };\n\n\t\t\t\t\t\t\t// we need to scale down to unit vectors to normalize vector length. Could also just do a tan here\n\t\t\t\t\t\t\tif (Math.abs(unitv.y * prevunit.x - unitv.x * prevunit.y) < 0.0001) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar d = this.polygonSlideDistance(A, B, vectors[i], true);\n\t\t\t\t\t\tvar vecd2 = vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y;\n\n\t\t\t\t\t\tif (d === null || d * d > vecd2) {\n\t\t\t\t\t\t\tvar vecd = Math.sqrt(vectors[i].x * vectors[i].x + vectors[i].y * vectors[i].y);\n\t\t\t\t\t\t\td = vecd;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (d !== null && d > maxd) {\n\t\t\t\t\t\t\tmaxd = d;\n\t\t\t\t\t\t\ttranslate = vectors[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (translate === null || _almostEqual(maxd, 0)) {\n\t\t\t\t\t\t// didn't close the loop, something went wrong here\n\t\t\t\t\t\tNFP = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttranslate.start.marked = true;\n\t\t\t\t\ttranslate.end.marked = true;\n\n\t\t\t\t\tprevvector = translate;\n\n\t\t\t\t\t// trim\n\t\t\t\t\tvar vlength2 = translate.x * translate.x + translate.y * translate.y;\n\t\t\t\t\tif (maxd * maxd < vlength2 && !_almostEqual(maxd * maxd, vlength2)) {\n\t\t\t\t\t\tvar scale = Math.sqrt(maxd * maxd / vlength2);\n\t\t\t\t\t\ttranslate.x *= scale;\n\t\t\t\t\t\ttranslate.y *= scale;\n\t\t\t\t\t}\n\n\t\t\t\t\treferencex += translate.x;\n\t\t\t\t\treferencey += translate.y;\n\n\t\t\t\t\tif (_almostEqual(referencex, startx) && _almostEqual(referencey, starty)) {\n\t\t\t\t\t\t// we've made a full loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if A and B start on a touching horizontal line, the end point may not be the start point\n\t\t\t\t\tvar looped = false;\n\t\t\t\t\tif (NFP.length > 0) {\n\t\t\t\t\t\tfor (i = 0; i < NFP.length - 1; i++) {\n\t\t\t\t\t\t\tif (_almostEqual(referencex, NFP[i].x) && _almostEqual(referencey, NFP[i].y)) {\n\t\t\t\t\t\t\t\tlooped = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (looped) {\n\t\t\t\t\t\t// we've made a full loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tNFP.push({\n\t\t\t\t\t\tx: referencex,\n\t\t\t\t\t\ty: referencey\n\t\t\t\t\t});\n\n\t\t\t\t\tB.offsetx += translate.x;\n\t\t\t\t\tB.offsety += translate.y;\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\n\t\t\t\tif (NFP && NFP.length > 0) {\n\t\t\t\t\tNFPlist.push(NFP);\n\t\t\t\t}\n\n\t\t\t\tif (!searchEdges) {\n\t\t\t\t\t// only get outer NFP or first inner NFP\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstartpoint = this.searchStartPoint(A, B, inside, NFPlist);\n\t\t\t}\n\n\t\t\treturn NFPlist;\n\t\t},\n\n\t\t// given two polygons that touch at at least one point, but do not intersect. Return the outer perimeter of both polygons as a single continuous polygon\n\t\t// A and B must have the same winding direction\n\t\tpolygonHull: function polygonHull(A, B) {\n\t\t\tif (!A || A.length < 3 || !B || B.length < 3) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar i, j;\n\n\t\t\tvar Aoffsetx = A.offsetx || 0;\n\t\t\tvar Aoffsety = A.offsety || 0;\n\t\t\tvar Boffsetx = B.offsetx || 0;\n\t\t\tvar Boffsety = B.offsety || 0;\n\n\t\t\t// start at an extreme point that is guaranteed to be on the final polygon\n\t\t\tvar miny = A[0].y;\n\t\t\tvar startPolygon = A;\n\t\t\tvar startIndex = 0;\n\n\t\t\tfor (i = 0; i < A.length; i++) {\n\t\t\t\tif (A[i].y + Aoffsety < miny) {\n\t\t\t\t\tminy = A[i].y + Aoffsety;\n\t\t\t\t\tstartPolygon = A;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < B.length; i++) {\n\t\t\t\tif (B[i].y + Boffsety < miny) {\n\t\t\t\t\tminy = B[i].y + Boffsety;\n\t\t\t\t\tstartPolygon = B;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for simplicity we'll define polygon A as the starting polygon\n\t\t\tif (startPolygon == B) {\n\t\t\t\tB = A;\n\t\t\t\tA = startPolygon;\n\t\t\t\tAoffsetx = A.offsetx || 0;\n\t\t\t\tAoffsety = A.offsety || 0;\n\t\t\t\tBoffsetx = B.offsetx || 0;\n\t\t\t\tBoffsety = B.offsety || 0;\n\t\t\t}\n\n\t\t\tA = A.slice(0);\n\t\t\tB = B.slice(0);\n\n\t\t\tvar C = [];\n\t\t\tvar current = startIndex;\n\t\t\tvar intercept1 = null;\n\t\t\tvar intercept2 = null;\n\n\t\t\t// scan forward from the starting point\n\t\t\tfor (i = 0; i < A.length + 1; i++) {\n\t\t\t\tcurrent = current == A.length ? 0 : current;\n\t\t\t\tvar next = current == A.length - 1 ? 0 : current + 1;\n\t\t\t\tvar touching = false;\n\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\tif (_almostEqual(A[current].x + Aoffsetx, B[j].x + Boffsetx) && _almostEqual(A[current].y + Aoffsety, B[j].y + Boffsety)) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept1 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety }, { x: A[next].x + Aoffsetx, y: A[next].y + Aoffsety }, { x: B[j].x + Boffsetx, y: B[j].y + Boffsety })) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.push({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety });\n\t\t\t\t\t\tintercept1 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety }, { x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety }, { x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety })) {\n\t\t\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.push({ x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety });\n\t\t\t\t\t\tintercept1 = nextj;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (touching) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tC.push({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\n\t\t\t\tcurrent++;\n\t\t\t}\n\n\t\t\t// scan backward from the starting point\n\t\t\tcurrent = startIndex - 1;\n\t\t\tfor (i = 0; i < A.length + 1; i++) {\n\t\t\t\tcurrent = current < 0 ? A.length - 1 : current;\n\t\t\t\tvar next = current == 0 ? A.length - 1 : current - 1;\n\t\t\t\tvar touching = false;\n\t\t\t\tfor (j = 0; j < B.length; j++) {\n\t\t\t\t\tvar nextj = j == B.length - 1 ? 0 : j + 1;\n\t\t\t\t\tif (_almostEqual(A[current].x + Aoffsetx, B[j].x + Boffsetx) && _almostEqual(A[current].y, B[j].y + Boffsety)) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety }, { x: A[next].x + Aoffsetx, y: A[next].y + Aoffsety }, { x: B[j].x + Boffsetx, y: B[j].y + Boffsety })) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tC.unshift({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (_onSegment({ x: B[j].x + Boffsetx, y: B[j].y + Boffsety }, { x: B[nextj].x + Boffsetx, y: B[nextj].y + Boffsety }, { x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety })) {\n\t\t\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\t\t\t\t\t\tintercept2 = j;\n\t\t\t\t\t\ttouching = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (touching) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tC.unshift({ x: A[current].x + Aoffsetx, y: A[current].y + Aoffsety });\n\n\t\t\t\tcurrent--;\n\t\t\t}\n\n\t\t\tif (intercept1 === null || intercept2 === null) {\n\t\t\t\t// polygons not touching?\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// the relevant points on B now lie between intercept1 and intercept2\n\t\t\tcurrent = intercept1 + 1;\n\t\t\tfor (i = 0; i < B.length; i++) {\n\t\t\t\tcurrent = current == B.length ? 0 : current;\n\t\t\t\tC.push({ x: B[current].x + Boffsetx, y: B[current].y + Boffsety });\n\n\t\t\t\tif (current == intercept2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcurrent++;\n\t\t\t}\n\n\t\t\t// dedupe\n\t\t\tfor (i = 0; i < C.length; i++) {\n\t\t\t\tvar next = i == C.length - 1 ? 0 : i + 1;\n\t\t\t\tif (_almostEqual(C[i].x, C[next].x) && _almostEqual(C[i].y, C[next].y)) {\n\t\t\t\t\tC.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn C;\n\t\t},\n\n\t\trotatePolygon: function rotatePolygon(polygon, angle) {\n\t\t\tvar rotated = [];\n\t\t\tangle = angle * Math.PI / 180;\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tvar x = polygon[i].x;\n\t\t\t\tvar y = polygon[i].y;\n\t\t\t\tvar x1 = x * Math.cos(angle) - y * Math.sin(angle);\n\t\t\t\tvar y1 = x * Math.sin(angle) + y * Math.cos(angle);\n\n\t\t\t\trotated.push({ x: x1, y: y1 });\n\t\t\t}\n\t\t\t// reset bounding box\n\t\t\tvar bounds = GeometryUtil.getPolygonBounds(rotated);\n\t\t\trotated.x = bounds.x;\n\t\t\trotated.y = bounds.y;\n\t\t\trotated.width = bounds.width;\n\t\t\trotated.height = bounds.height;\n\n\t\t\treturn rotated;\n\t\t}\n\t};\n})(typeof window !== 'undefined' ? window : self);"},707:function(t,n,e){e(77)(e(708))},708:function(t,n){t.exports="'use strict';\n\n// jsClipper uses X/Y instead of x/y...\nfunction toClipperCoordinates(polygon) {\n\tvar clone = [];\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tclone.push({\n\t\t\tX: polygon[i].x,\n\t\t\tY: polygon[i].y\n\t\t});\n\t}\n\n\treturn clone;\n};\n\nfunction toNestCoordinates(polygon, scale) {\n\tvar clone = [];\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tclone.push({\n\t\t\tx: polygon[i].X / scale,\n\t\t\ty: polygon[i].Y / scale\n\t\t});\n\t}\n\n\treturn clone;\n};\n\nfunction rotatePolygon(polygon, degrees) {\n\tvar rotated = [];\n\tvar angle = degrees * Math.PI / 180;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar x = polygon[i].x;\n\t\tvar y = polygon[i].y;\n\t\tvar x1 = x * Math.cos(angle) - y * Math.sin(angle);\n\t\tvar y1 = x * Math.sin(angle) + y * Math.cos(angle);\n\n\t\trotated.push({ x: x1, y: y1 });\n\t}\n\n\tif (polygon.children && polygon.children.length > 0) {\n\t\trotated.children = [];\n\t\tfor (var j = 0; j < polygon.children.length; j++) {\n\t\t\trotated.children.push(rotatePolygon(polygon.children[j], degrees));\n\t\t}\n\t}\n\n\treturn rotated;\n};\n\nfunction PlacementWorker(binPolygon, paths, ids, rotations, config, nfpCache) {\n\tthis.binPolygon = binPolygon;\n\tthis.paths = paths;\n\tthis.ids = ids;\n\tthis.rotations = rotations;\n\tthis.config = config;\n\tthis.nfpCache = nfpCache || {};\n\n\t// return a placement for the paths/rotations given\n\t// happens inside a webworker\n\tthis.placePaths = function (paths) {\n\n\t\tvar self = global.env.self;\n\n\t\tif (!self.binPolygon) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar i, j, k, m, n, path;\n\n\t\t// rotate paths by given rotation\n\t\tvar rotated = [];\n\t\tfor (i = 0; i < paths.length; i++) {\n\t\t\tvar r = rotatePolygon(paths[i], paths[i].rotation);\n\t\t\tr.rotation = paths[i].rotation;\n\t\t\tr.source = paths[i].source;\n\t\t\tr.id = paths[i].id;\n\t\t\trotated.push(r);\n\t\t}\n\n\t\tpaths = rotated;\n\n\t\tvar allplacements = [];\n\t\tvar fitness = 0;\n\t\tvar binarea = Math.abs(GeometryUtil.polygonArea(self.binPolygon));\n\t\tvar key, nfp;\n\n\t\twhile (paths.length > 0) {\n\n\t\t\tvar placed = [];\n\t\t\tvar placements = [];\n\t\t\tfitness += 1; // add 1 for each new bin opened (lower fitness is better)\n\n\t\t\tfor (i = 0; i < paths.length; i++) {\n\t\t\t\tpath = paths[i];\n\n\t\t\t\t// inner NFP\n\t\t\t\tkey = JSON.stringify({ A: -1, B: path.id, inside: true, Arotation: 0, Brotation: path.rotation });\n\t\t\t\tvar binNfp = self.nfpCache[key];\n\n\t\t\t\t// part unplaceable, skip\n\t\t\t\tif (!binNfp || binNfp.length == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// ensure all necessary NFPs exist\n\t\t\t\tvar error = false;\n\t\t\t\tfor (j = 0; j < placed.length; j++) {\n\t\t\t\t\tkey = JSON.stringify({ A: placed[j].id, B: path.id, inside: false, Arotation: placed[j].rotation, Brotation: path.rotation });\n\t\t\t\t\tnfp = self.nfpCache[key];\n\n\t\t\t\t\tif (!nfp) {\n\t\t\t\t\t\terror = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// part unplaceable, skip\n\t\t\t\tif (error) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar position = null;\n\t\t\t\tif (placed.length == 0) {\n\t\t\t\t\t// first placement, put it on the left\n\t\t\t\t\tfor (j = 0; j < binNfp.length; j++) {\n\t\t\t\t\t\tfor (k = 0; k < binNfp[j].length; k++) {\n\t\t\t\t\t\t\tif (position === null || binNfp[j][k].x - path[0].x < position.x) {\n\t\t\t\t\t\t\t\tposition = {\n\t\t\t\t\t\t\t\t\tx: binNfp[j][k].x - path[0].x,\n\t\t\t\t\t\t\t\t\ty: binNfp[j][k].y - path[0].y,\n\t\t\t\t\t\t\t\t\tid: path.id,\n\t\t\t\t\t\t\t\t\trotation: path.rotation\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tplacements.push(position);\n\t\t\t\t\tplaced.push(path);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar clipperBinNfp = [];\n\t\t\t\tfor (j = 0; j < binNfp.length; j++) {\n\t\t\t\t\tclipperBinNfp.push(toClipperCoordinates(binNfp[j]));\n\t\t\t\t}\n\n\t\t\t\tClipperLib.JS.ScaleUpPaths(clipperBinNfp, self.config.clipperScale);\n\n\t\t\t\tvar clipper = new ClipperLib.Clipper();\n\t\t\t\tvar combinedNfp = new ClipperLib.Paths();\n\n\t\t\t\tfor (j = 0; j < placed.length; j++) {\n\t\t\t\t\tkey = JSON.stringify({ A: placed[j].id, B: path.id, inside: false, Arotation: placed[j].rotation, Brotation: path.rotation });\n\t\t\t\t\tnfp = self.nfpCache[key];\n\n\t\t\t\t\tif (!nfp) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k < nfp.length; k++) {\n\t\t\t\t\t\tvar clone = toClipperCoordinates(nfp[k]);\n\t\t\t\t\t\tfor (m = 0; m < clone.length; m++) {\n\t\t\t\t\t\t\tclone[m].X += placements[j].x;\n\t\t\t\t\t\t\tclone[m].Y += placements[j].y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tClipperLib.JS.ScaleUpPath(clone, self.config.clipperScale);\n\t\t\t\t\t\tclone = ClipperLib.Clipper.CleanPolygon(clone, 0.0001 * self.config.clipperScale);\n\t\t\t\t\t\tvar area = Math.abs(ClipperLib.Clipper.Area(clone));\n\t\t\t\t\t\tif (clone.length > 2 && area > 0.1 * self.config.clipperScale * self.config.clipperScale) {\n\t\t\t\t\t\t\tclipper.AddPath(clone, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!clipper.Execute(ClipperLib.ClipType.ctUnion, combinedNfp, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// difference with bin polygon\n\t\t\t\tvar finalNfp = new ClipperLib.Paths();\n\t\t\t\tclipper = new ClipperLib.Clipper();\n\n\t\t\t\tclipper.AddPaths(combinedNfp, ClipperLib.PolyType.ptClip, true);\n\t\t\t\tclipper.AddPaths(clipperBinNfp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (!clipper.Execute(ClipperLib.ClipType.ctDifference, finalNfp, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinalNfp = ClipperLib.Clipper.CleanPolygons(finalNfp, 0.0001 * self.config.clipperScale);\n\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\tvar area = Math.abs(ClipperLib.Clipper.Area(finalNfp[j]));\n\t\t\t\t\tif (finalNfp[j].length < 3 || area < 0.1 * self.config.clipperScale * self.config.clipperScale) {\n\t\t\t\t\t\tfinalNfp.splice(j, 1);\n\t\t\t\t\t\tj--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!finalNfp || finalNfp.length == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar f = [];\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\t// back to normal scale\n\t\t\t\t\tf.push(toNestCoordinates(finalNfp[j], self.config.clipperScale));\n\t\t\t\t}\n\t\t\t\tfinalNfp = f;\n\n\t\t\t\t// choose placement that results in the smallest bounding box\n\t\t\t\t// could use convex hull instead, but it can create oddly shaped nests (triangles or long slivers) which are not optimal for real-world use\n\t\t\t\t// todo: generalize gravity direction\n\t\t\t\tvar minwidth = null;\n\t\t\t\tvar minarea = null;\n\t\t\t\tvar minx = null;\n\t\t\t\tvar nf, area, shiftvector;\n\n\t\t\t\tfor (j = 0; j < finalNfp.length; j++) {\n\t\t\t\t\tnf = finalNfp[j];\n\t\t\t\t\tif (Math.abs(GeometryUtil.polygonArea(nf)) < 2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k = 0; k < nf.length; k++) {\n\t\t\t\t\t\tvar allpoints = [];\n\t\t\t\t\t\tfor (m = 0; m < placed.length; m++) {\n\t\t\t\t\t\t\tfor (n = 0; n < placed[m].length; n++) {\n\t\t\t\t\t\t\t\tallpoints.push({ x: placed[m][n].x + placements[m].x, y: placed[m][n].y + placements[m].y });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshiftvector = {\n\t\t\t\t\t\t\tx: nf[k].x - path[0].x,\n\t\t\t\t\t\t\ty: nf[k].y - path[0].y,\n\t\t\t\t\t\t\tid: path.id,\n\t\t\t\t\t\t\trotation: path.rotation,\n\t\t\t\t\t\t\tnfp: combinedNfp\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (m = 0; m < path.length; m++) {\n\t\t\t\t\t\t\tallpoints.push({ x: path[m].x + shiftvector.x, y: path[m].y + shiftvector.y });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar rectbounds = GeometryUtil.getPolygonBounds(allpoints);\n\n\t\t\t\t\t\t// weigh width more, to help compress in direction of gravity\n\t\t\t\t\t\tarea = rectbounds.width * 2 + rectbounds.height;\n\n\t\t\t\t\t\tif (minarea === null || area < minarea || GeometryUtil.almostEqual(minarea, area) && (minx === null || shiftvector.x < minx)) {\n\t\t\t\t\t\t\tminarea = area;\n\t\t\t\t\t\t\tminwidth = rectbounds.width;\n\t\t\t\t\t\t\tposition = shiftvector;\n\t\t\t\t\t\t\tminx = shiftvector.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (position) {\n\t\t\t\t\tplaced.push(path);\n\t\t\t\t\tplacements.push(position);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (minwidth) {\n\t\t\t\tfitness += minwidth / binarea;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < placed.length; i++) {\n\t\t\t\tvar index = paths.indexOf(placed[i]);\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tpaths.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (placements && placements.length > 0) {\n\t\t\t\tallplacements.push(placements);\n\t\t\t} else {\n\t\t\t\tbreak; // something went wrong\n\t\t\t}\n\t\t}\n\n\t\t// there were parts that couldn't be placed\n\t\tfitness += 2 * paths.length;\n\n\t\treturn { placements: allplacements, fitness: fitness, paths: paths, area: binarea };\n\t};\n}\n(typeof window !== 'undefined' ? window : self).PlacementWorker = PlacementWorker;\n\n// clipperjs uses alerts for warnings\nfunction alert(message) {\n\tconsole.log('alert: ', message);\n}"},709:function(t,n,e){e(77)(e(710))},710:function(t,n){t.exports="'use strict';\n\n/*!\n * SvgParser\n * A library to convert an SVG string to parse-able segments for CAD/CAM use\n * Licensed under the MIT license\n */\n\n(function (root) {\n\t'use strict';\n\n\tfunction SvgParser() {\n\t\t// the SVG document\n\t\tthis.svg;\n\n\t\t// the top level SVG element of the SVG document\n\t\tthis.svgRoot;\n\n\t\tthis.allowedElements = ['svg', 'circle', 'ellipse', 'path', 'polygon', 'polyline', 'rect'];\n\n\t\tthis.conf = {\n\t\t\ttolerance: 2, // max bound for bezier->line segment conversion, in native SVG units\n\t\t\ttoleranceSvg: 0.005 // fudge factor for browser inaccuracy in SVG unit handling\n\t\t};\n\t}\n\n\tSvgParser.prototype.config = function (config) {\n\t\tthis.conf.tolerance = config.tolerance;\n\t};\n\n\tSvgParser.prototype.load = function (svgString) {\n\n\t\tif (!svgString || typeof svgString !== 'string') {\n\t\t\tthrow Error('invalid SVG string');\n\t\t}\n\n\t\tvar parser = new DOMParser();\n\t\tvar svg = parser.parseFromString(svgString, \"image/svg+xml\");\n\n\t\tif (svg) {\n\t\t\tthis.svg = svg;\n\t\t\tthis.svgRoot = svg.childNodes[0];\n\t\t} else {\n\t\t\tthrow new Error(\"Failed to parse SVG string\");\n\t\t}\n\n\t\tif (!this.svgRoot) {\n\t\t\tthrow new Error(\"SVG has no children\");\n\t\t}\n\t\treturn this.svgRoot;\n\t};\n\n\t// use the utility functions in this class to prepare the svg for CAD-CAM/nest related operations\n\tSvgParser.prototype.cleanInput = function () {\n\n\t\t// apply any transformations, so that all path positions etc will be in the same coordinate space\n\t\tthis.applyTransform(this.svgRoot);\n\n\t\t// remove any g elements and bring all elements to the top level\n\t\tthis.flatten(this.svgRoot);\n\n\t\t// remove any non-contour elements like text\n\t\tthis.filter(this.allowedElements);\n\n\t\t// split any compound paths into individual path elements\n\t\tthis.recurse(this.svgRoot, this.splitPath);\n\n\t\treturn this.svgRoot;\n\t};\n\n\t// return style node, if any\n\tSvgParser.prototype.getStyle = function () {\n\t\tif (!this.svgRoot) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0; i < this.svgRoot.childNodes.length; i++) {\n\t\t\tvar el = this.svgRoot.childNodes[i];\n\t\t\tif (el.tagName == 'style') {\n\t\t\t\treturn el;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t// set the given path as absolute coords (capital commands)\n\t// from http://stackoverflow.com/a/9677915/433888\n\tSvgParser.prototype.pathToAbsolute = function (path) {\n\t\tif (!path || path.tagName != 'path') {\n\t\t\tthrow Error('invalid path');\n\t\t}\n\n\t\tvar seglist = path.pathSegList;\n\t\tvar x = 0,\n\t\t    y = 0,\n\t\t    x0 = 0,\n\t\t    y0 = 0,\n\t\t    x1 = 0,\n\t\t    y1 = 0,\n\t\t    x2 = 0,\n\t\t    y2 = 0;\n\n\t\tfor (var i = 0; i < seglist.numberOfItems; i++) {\n\t\t\tvar command = seglist.getItem(i).pathSegTypeAsLetter;\n\t\t\tvar s = seglist.getItem(i);\n\n\t\t\tif (/[MLHVCSQTA]/.test(command)) {\n\t\t\t\tif ('x' in s) x = s.x;\n\t\t\t\tif ('y' in s) y = s.y;\n\t\t\t} else {\n\t\t\t\tif ('x1' in s) x1 = x + s.x1;\n\t\t\t\tif ('x2' in s) x2 = x + s.x2;\n\t\t\t\tif ('y1' in s) y1 = y + s.y1;\n\t\t\t\tif ('y2' in s) y2 = y + s.y2;\n\t\t\t\tif ('x' in s) x += s.x;\n\t\t\t\tif ('y' in s) y += s.y;\n\t\t\t\tswitch (command) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);break;\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);break;\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);break;\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);break;\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);break;\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);break;\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);break;\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);break;\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tseglist.replaceItem(path.createSVGPathSegArcAbs(x, y, s.r1, s.r2, s.angle, s.largeArcFlag, s.sweepFlag), i);break;\n\t\t\t\t\tcase 'z':case 'Z':\n\t\t\t\t\t\tx = x0;y = y0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Record the start of a subpath\n\t\t\tif (command == 'M' || command == 'm') x0 = x, y0 = y;\n\t\t}\n\t};\n\n\t// takes an SVG transform string and returns corresponding SVGMatrix\n\t// from https://github.com/fontello/svgpath\n\tSvgParser.prototype.transformParse = function (transformString) {\n\t\tvar operations = {\n\t\t\tmatrix: true,\n\t\t\tscale: true,\n\t\t\trotate: true,\n\t\t\ttranslate: true,\n\t\t\tskewX: true,\n\t\t\tskewY: true\n\t\t};\n\n\t\tvar CMD_SPLIT_RE = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/;\n\t\tvar PARAMS_SPLIT_RE = /[\\s,]+/;\n\n\t\tvar matrix = new Matrix();\n\t\tvar cmd, params;\n\n\t\t// Split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate',  '-45', '']\n\t\ttransformString.split(CMD_SPLIT_RE).forEach(function (item) {\n\n\t\t\t// Skip empty elements\n\t\t\tif (!item.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// remember operation\n\t\t\tif (typeof operations[item] !== 'undefined') {\n\t\t\t\tcmd = item;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// extract params & att operation to matrix\n\t\t\tparams = item.split(PARAMS_SPLIT_RE).map(function (i) {\n\t\t\t\treturn +i || 0;\n\t\t\t});\n\n\t\t\t// If params count is not correct - ignore command\n\t\t\tswitch (cmd) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tif (params.length === 6) {\n\t\t\t\t\t\tmatrix.matrix(params);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\tmatrix.scale(params[0], params[0]);\n\t\t\t\t\t} else if (params.length === 2) {\n\t\t\t\t\t\tmatrix.scale(params[0], params[1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\tmatrix.rotate(params[0], 0, 0);\n\t\t\t\t\t} else if (params.length === 3) {\n\t\t\t\t\t\tmatrix.rotate(params[0], params[1], params[2]);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\tmatrix.translate(params[0], 0);\n\t\t\t\t\t} else if (params.length === 2) {\n\t\t\t\t\t\tmatrix.translate(params[0], params[1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\tmatrix.skewX(params[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tif (params.length === 1) {\n\t\t\t\t\t\tmatrix.skewY(params[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\treturn matrix;\n\t};\n\n\t// recursively apply the transform property to the given element\n\tSvgParser.prototype.applyTransform = function (element, globalTransform) {\n\n\t\tglobalTransform = globalTransform || '';\n\t\tvar transformString = element.getAttribute('transform') || '';\n\t\ttransformString = globalTransform + transformString;\n\n\t\tvar transform, scale, rotate;\n\n\t\tif (transformString && transformString.length > 0) {\n\t\t\tvar transform = this.transformParse(transformString);\n\t\t}\n\n\t\tif (!transform) {\n\t\t\ttransform = new Matrix();\n\t\t}\n\n\t\tvar tarray = transform.toArray();\n\n\t\t// decompose affine matrix to rotate, scale components (translate is just the 3rd column)\n\t\tvar rotate = Math.atan2(tarray[1], tarray[3]) * 180 / Math.PI;\n\t\tvar scale = Math.sqrt(tarray[0] * tarray[0] + tarray[2] * tarray[2]);\n\n\t\tif (element.tagName == 'g' || element.tagName == 'svg') {\n\t\t\telement.removeAttribute('transform');\n\t\t\tvar children = Array.prototype.slice.call(element.childNodes);\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tthis.applyTransform(children[i], transformString);\n\t\t\t}\n\t\t} else if (transform && !transform.isIdentity()) {\n\t\t\tswitch (element.tagName) {\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\t// the goal is to remove the transform property, but an ellipse without a transform will have no rotation\n\t\t\t\t\t// for the sake of simplicity, we will replace the ellipse with a path, and apply the transform to that path\n\t\t\t\t\tvar path = this.svg.createElementNS(element.namespaceURI, 'path');\n\t\t\t\t\tvar move = path.createSVGPathSegMovetoAbs(parseFloat(element.getAttribute('cx')) - parseFloat(element.getAttribute('rx')), element.getAttribute('cy'));\n\t\t\t\t\tvar arc1 = path.createSVGPathSegArcAbs(parseFloat(element.getAttribute('cx')) + parseFloat(element.getAttribute('rx')), element.getAttribute('cy'), element.getAttribute('rx'), element.getAttribute('ry'), 0, 1, 0);\n\t\t\t\t\tvar arc2 = path.createSVGPathSegArcAbs(parseFloat(element.getAttribute('cx')) - parseFloat(element.getAttribute('rx')), element.getAttribute('cy'), element.getAttribute('rx'), element.getAttribute('ry'), 0, 1, 0);\n\n\t\t\t\t\tpath.pathSegList.appendItem(move);\n\t\t\t\t\tpath.pathSegList.appendItem(arc1);\n\t\t\t\t\tpath.pathSegList.appendItem(arc2);\n\t\t\t\t\tpath.pathSegList.appendItem(path.createSVGPathSegClosePath());\n\n\t\t\t\t\tvar transformProperty = element.getAttribute('transform');\n\t\t\t\t\tif (transformProperty) {\n\t\t\t\t\t\tpath.setAttribute('transform', transformProperty);\n\t\t\t\t\t}\n\n\t\t\t\t\telement.parentElement.replaceChild(path, element);\n\n\t\t\t\t\telement = path;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tthis.pathToAbsolute(element);\n\t\t\t\t\tvar seglist = element.pathSegList;\n\t\t\t\t\tvar prevx = 0;\n\t\t\t\t\tvar prevy = 0;\n\n\t\t\t\t\tfor (var i = 0; i < seglist.numberOfItems; i++) {\n\t\t\t\t\t\tvar s = seglist.getItem(i);\n\t\t\t\t\t\tvar command = s.pathSegTypeAsLetter;\n\n\t\t\t\t\t\tif (command == 'H') {\n\t\t\t\t\t\t\tseglist.replaceItem(element.createSVGPathSegLinetoAbs(s.x, prevy), i);\n\t\t\t\t\t\t\ts = seglist.getItem(i);\n\t\t\t\t\t\t} else if (command == 'V') {\n\t\t\t\t\t\t\tseglist.replaceItem(element.createSVGPathSegLinetoAbs(prevx, s.y), i);\n\t\t\t\t\t\t\ts = seglist.getItem(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// currently only works for uniform scale, no skew\n\t\t\t\t\t\t// todo: fully support arbitrary affine transforms...\n\t\t\t\t\t\telse if (command == 'A') {\n\t\t\t\t\t\t\t\tseglist.replaceItem(element.createSVGPathSegArcAbs(s.x, s.y, s.r1 * scale, s.r2 * scale, s.angle + rotate, s.largeArcFlag, s.sweepFlag), i);\n\t\t\t\t\t\t\t\ts = seglist.getItem(i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ('x' in s && 'y' in s) {\n\t\t\t\t\t\t\tvar transformed = transform.calc(s.x, s.y);\n\t\t\t\t\t\t\tprevx = s.x;\n\t\t\t\t\t\t\tprevy = s.y;\n\n\t\t\t\t\t\t\ts.x = transformed[0];\n\t\t\t\t\t\t\ts.y = transformed[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('x1' in s && 'y1' in s) {\n\t\t\t\t\t\t\tvar transformed = transform.calc(s.x1, s.y1);\n\t\t\t\t\t\t\ts.x1 = transformed[0];\n\t\t\t\t\t\t\ts.y1 = transformed[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ('x2' in s && 'y2' in s) {\n\t\t\t\t\t\t\tvar transformed = transform.calc(s.x2, s.y2);\n\t\t\t\t\t\t\ts.x2 = transformed[0];\n\t\t\t\t\t\t\ts.y2 = transformed[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telement.removeAttribute('transform');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'circle':\n\t\t\t\t\tvar transformed = transform.calc(element.getAttribute('cx'), element.getAttribute('cy'));\n\t\t\t\t\telement.setAttribute('cx', transformed[0]);\n\t\t\t\t\telement.setAttribute('cy', transformed[1]);\n\n\t\t\t\t\t// skew not supported\n\t\t\t\t\telement.setAttribute('r', element.getAttribute('r') * scale);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\t// similar to the ellipse, we'll replace rect with polygon\n\t\t\t\t\tvar polygon = this.svg.createElementNS(element.namespaceURI, 'polygon');\n\n\t\t\t\t\tvar p1 = this.svgRoot.createSVGPoint();\n\t\t\t\t\tvar p2 = this.svgRoot.createSVGPoint();\n\t\t\t\t\tvar p3 = this.svgRoot.createSVGPoint();\n\t\t\t\t\tvar p4 = this.svgRoot.createSVGPoint();\n\n\t\t\t\t\tp1.x = parseFloat(element.getAttribute('x')) || 0;\n\t\t\t\t\tp1.y = parseFloat(element.getAttribute('y')) || 0;\n\n\t\t\t\t\tp2.x = p1.x + parseFloat(element.getAttribute('width'));\n\t\t\t\t\tp2.y = p1.y;\n\n\t\t\t\t\tp3.x = p2.x;\n\t\t\t\t\tp3.y = p1.y + parseFloat(element.getAttribute('height'));\n\n\t\t\t\t\tp4.x = p1.x;\n\t\t\t\t\tp4.y = p3.y;\n\n\t\t\t\t\tpolygon.points.appendItem(p1);\n\t\t\t\t\tpolygon.points.appendItem(p2);\n\t\t\t\t\tpolygon.points.appendItem(p3);\n\t\t\t\t\tpolygon.points.appendItem(p4);\n\n\t\t\t\t\tvar transformProperty = element.getAttribute('transform');\n\t\t\t\t\tif (transformProperty) {\n\t\t\t\t\t\tpolygon.setAttribute('transform', transformProperty);\n\t\t\t\t\t}\n\n\t\t\t\t\telement.parentElement.replaceChild(polygon, element);\n\t\t\t\t\telement = polygon;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tfor (var i = 0; i < element.points.length; i++) {\n\t\t\t\t\t\tvar point = element.points[i];\n\t\t\t\t\t\tvar transformed = transform.calc(point.x, point.y);\n\t\t\t\t\t\tpoint.x = transformed[0];\n\t\t\t\t\t\tpoint.y = transformed[1];\n\t\t\t\t\t}\n\n\t\t\t\t\telement.removeAttribute('transform');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t// bring all child elements to the top level\n\tSvgParser.prototype.flatten = function (element) {\n\t\tfor (var i = 0; i < element.childNodes.length; i++) {\n\t\t\tthis.flatten(element.childNodes[i]);\n\t\t}\n\n\t\tif (element.tagName != 'svg') {\n\t\t\twhile (element.childNodes.length > 0) {\n\t\t\t\telement.parentElement.appendChild(element.childNodes[0]);\n\t\t\t}\n\t\t}\n\t};\n\n\t// remove all elements with tag name not in the whitelist\n\t// use this to remove <text>, <g> etc that don't represent shapes\n\tSvgParser.prototype.filter = function (whitelist, element) {\n\t\tif (!whitelist || whitelist.length == 0) {\n\t\t\tthrow Error('invalid whitelist');\n\t\t}\n\n\t\telement = element || this.svgRoot;\n\n\t\tfor (var i = 0; i < element.childNodes.length; i++) {\n\t\t\tthis.filter(whitelist, element.childNodes[i]);\n\t\t}\n\n\t\tif (element.childNodes.length == 0 && whitelist.indexOf(element.tagName) < 0) {\n\t\t\telement.parentElement.removeChild(element);\n\t\t}\n\t};\n\n\t// split a compound path (paths with M, m commands) into an array of paths\n\tSvgParser.prototype.splitPath = function (path) {\n\t\tif (!path || path.tagName != 'path' || !path.parentElement) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar seglist = path.pathSegList;\n\t\tvar x = 0,\n\t\t    y = 0,\n\t\t    x0 = 0,\n\t\t    y0 = 0;\n\t\tvar paths = [];\n\n\t\tvar p;\n\n\t\tvar lastM = 0;\n\t\tfor (var i = seglist.numberOfItems - 1; i >= 0; i--) {\n\t\t\tif (i > 0 && seglist.getItem(i).pathSegTypeAsLetter == 'M' || seglist.getItem(i).pathSegTypeAsLetter == 'm') {\n\t\t\t\tlastM = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (lastM == 0) {\n\t\t\treturn false; // only 1 M command, no need to split\n\t\t}\n\n\t\tfor (i = 0; i < seglist.numberOfItems; i++) {\n\t\t\tvar s = seglist.getItem(i);\n\t\t\tvar command = s.pathSegTypeAsLetter;\n\n\t\t\tif (command == 'M' || command == 'm') {\n\t\t\t\tp = path.cloneNode();\n\t\t\t\tp.setAttribute('d', '');\n\t\t\t\tpaths.push(p);\n\t\t\t}\n\n\t\t\tif (/[MLHVCSQTA]/.test(command)) {\n\t\t\t\tif ('x' in s) x = s.x;\n\t\t\t\tif ('y' in s) y = s.y;\n\n\t\t\t\tp.pathSegList.appendItem(s);\n\t\t\t} else {\n\t\t\t\tif ('x' in s) x += s.x;\n\t\t\t\tif ('y' in s) y += s.y;\n\t\t\t\tif (command == 'm') {\n\t\t\t\t\tp.pathSegList.appendItem(path.createSVGPathSegMovetoAbs(x, y));\n\t\t\t\t} else {\n\t\t\t\t\tif (command == 'Z' || command == 'z') {\n\t\t\t\t\t\tx = x0;\n\t\t\t\t\t\ty = y0;\n\t\t\t\t\t}\n\t\t\t\t\tp.pathSegList.appendItem(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Record the start of a subpath\n\t\t\tif (command == 'M' || command == 'm') {\n\t\t\t\tx0 = x, y0 = y;\n\t\t\t}\n\t\t}\n\n\t\tvar addedPaths = [];\n\t\tfor (i = 0; i < paths.length; i++) {\n\t\t\t// don't add trivial paths from sequential M commands\n\t\t\tif (paths[i].pathSegList.numberOfItems > 1) {\n\t\t\t\tpath.parentElement.insertBefore(paths[i], path);\n\t\t\t\taddedPaths.push(paths[i]);\n\t\t\t}\n\t\t}\n\n\t\tpath.remove();\n\n\t\treturn addedPaths;\n\t};\n\n\t// recursively run the given function on the given element\n\tSvgParser.prototype.recurse = function (element, func) {\n\t\t// only operate on original DOM tree, ignore any children that are added. Avoid infinite loops\n\t\tvar children = Array.prototype.slice.call(element.childNodes);\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tthis.recurse(children[i], func);\n\t\t}\n\n\t\tfunc(element);\n\t};\n\n\t// return a polygon from the given SVG element in the form of an array of points\n\tSvgParser.prototype.polygonify = function (element) {\n\t\tvar poly = [];\n\t\tvar i;\n\n\t\tswitch (element.tagName) {\n\t\t\tcase 'polygon':\n\t\t\tcase 'polyline':\n\t\t\t\tfor (var i = 0; i < element.points.numberOfItems; i++) {\n\t\t\t\t\tpoly.push({\n\t\t\t\t\t\tx: element.points.getItem(i).x,\n\t\t\t\t\t\ty: element.points.getItem(i).y\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'rect':\n\t\t\t\tvar p1 = {};\n\t\t\t\tvar p2 = {};\n\t\t\t\tvar p3 = {};\n\t\t\t\tvar p4 = {};\n\n\t\t\t\tp1.x = parseFloat(element.getAttribute('x')) || 0;\n\t\t\t\tp1.y = parseFloat(element.getAttribute('y')) || 0;\n\n\t\t\t\tp2.x = p1.x + parseFloat(element.getAttribute('width'));\n\t\t\t\tp2.y = p1.y;\n\n\t\t\t\tp3.x = p2.x;\n\t\t\t\tp3.y = p1.y + parseFloat(element.getAttribute('height'));\n\n\t\t\t\tp4.x = p1.x;\n\t\t\t\tp4.y = p3.y;\n\n\t\t\t\tpoly.push(p1);\n\t\t\t\tpoly.push(p2);\n\t\t\t\tpoly.push(p3);\n\t\t\t\tpoly.push(p4);\n\t\t\t\tbreak;\n\t\t\tcase 'circle':\n\t\t\t\tvar radius = parseFloat(element.getAttribute('r'));\n\t\t\t\tvar cx = parseFloat(element.getAttribute('cx'));\n\t\t\t\tvar cy = parseFloat(element.getAttribute('cy'));\n\n\t\t\t\t// num is the smallest number of segments required to approximate the circle to the given tolerance\n\t\t\t\tvar num = Math.ceil(2 * Math.PI / Math.acos(1 - this.conf.tolerance / radius));\n\n\t\t\t\tif (num < 3) {\n\t\t\t\t\tnum = 3;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tvar theta = i * (2 * Math.PI / num);\n\t\t\t\t\tvar point = {};\n\t\t\t\t\tpoint.x = radius * Math.cos(theta) + cx;\n\t\t\t\t\tpoint.y = radius * Math.sin(theta) + cy;\n\n\t\t\t\t\tpoly.push(point);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'ellipse':\n\t\t\t\t// same as circle case. There is probably a way to reduce points but for convenience we will just flatten the equivalent circular polygon\n\t\t\t\tvar rx = parseFloat(element.getAttribute('rx'));\n\t\t\t\tvar ry = parseFloat(element.getAttribute('ry'));\n\t\t\t\tvar maxradius = Math.max(rx, ry);\n\n\t\t\t\tvar cx = parseFloat(element.getAttribute('cx'));\n\t\t\t\tvar cy = parseFloat(element.getAttribute('cy'));\n\n\t\t\t\tvar num = Math.ceil(2 * Math.PI / Math.acos(1 - this.conf.tolerance / maxradius));\n\n\t\t\t\tif (num < 3) {\n\t\t\t\t\tnum = 3;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < num; i++) {\n\t\t\t\t\tvar theta = i * (2 * Math.PI / num);\n\t\t\t\t\tvar point = {};\n\t\t\t\t\tpoint.x = rx * Math.cos(theta) + cx;\n\t\t\t\t\tpoint.y = ry * Math.sin(theta) + cy;\n\n\t\t\t\t\tpoly.push(point);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'path':\n\t\t\t\t// we'll assume that splitpath has already been run on this path, and it only has one M/m command \n\t\t\t\tvar seglist = element.pathSegList;\n\n\t\t\t\tvar firstCommand = seglist.getItem(0);\n\t\t\t\tvar lastCommand = seglist.getItem(seglist.numberOfItems - 1);\n\n\t\t\t\tvar x = 0,\n\t\t\t\t    y = 0,\n\t\t\t\t    x0 = 0,\n\t\t\t\t    y0 = 0,\n\t\t\t\t    x1 = 0,\n\t\t\t\t    y1 = 0,\n\t\t\t\t    x2 = 0,\n\t\t\t\t    y2 = 0,\n\t\t\t\t    prevx = 0,\n\t\t\t\t    prevy = 0,\n\t\t\t\t    prevx1 = 0,\n\t\t\t\t    prevy1 = 0,\n\t\t\t\t    prevx2 = 0,\n\t\t\t\t    prevy2 = 0;\n\n\t\t\t\tfor (var i = 0; i < seglist.numberOfItems; i++) {\n\t\t\t\t\tvar s = seglist.getItem(i);\n\t\t\t\t\tvar command = s.pathSegTypeAsLetter;\n\n\t\t\t\t\tprevx = x;\n\t\t\t\t\tprevy = y;\n\n\t\t\t\t\tprevx1 = x1;\n\t\t\t\t\tprevy1 = y1;\n\n\t\t\t\t\tprevx2 = x2;\n\t\t\t\t\tprevy2 = y2;\n\n\t\t\t\t\tif (/[MLHVCSQTA]/.test(command)) {\n\t\t\t\t\t\tif ('x1' in s) x1 = s.x1;\n\t\t\t\t\t\tif ('x2' in s) x2 = s.x2;\n\t\t\t\t\t\tif ('y1' in s) y1 = s.y1;\n\t\t\t\t\t\tif ('y2' in s) y2 = s.y2;\n\t\t\t\t\t\tif ('x' in s) x = s.x;\n\t\t\t\t\t\tif ('y' in s) y = s.y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ('x1' in s) x1 = x + s.x1;\n\t\t\t\t\t\tif ('x2' in s) x2 = x + s.x2;\n\t\t\t\t\t\tif ('y1' in s) y1 = y + s.y1;\n\t\t\t\t\t\tif ('y2' in s) y2 = y + s.y2;\n\t\t\t\t\t\tif ('x' in s) x += s.x;\n\t\t\t\t\t\tif ('y' in s) y += s.y;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (command) {\n\t\t\t\t\t\t// linear line types\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t\tvar point = {};\n\t\t\t\t\t\t\tpoint.x = x;\n\t\t\t\t\t\t\tpoint.y = y;\n\t\t\t\t\t\t\tpoly.push(point);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// Quadratic Beziers\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\t// implicit control point\n\t\t\t\t\t\t\tif (i > 0 && /[QqTt]/.test(seglist.getItem(i - 1).pathSegTypeAsLetter)) {\n\t\t\t\t\t\t\t\tx1 = prevx + (prevx - prevx1);\n\t\t\t\t\t\t\t\ty1 = prevy + (prevy - prevy1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tx1 = prevx;\n\t\t\t\t\t\t\t\ty1 = prevy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tvar pointlist = GeometryUtil.QuadraticBezier.linearize({ x: prevx, y: prevy }, { x: x, y: y }, { x: x1, y: y1 }, this.conf.tolerance);\n\t\t\t\t\t\t\tpointlist.shift(); // firstpoint would already be in the poly\n\t\t\t\t\t\t\tfor (var j = 0; j < pointlist.length; j++) {\n\t\t\t\t\t\t\t\tvar point = {};\n\t\t\t\t\t\t\t\tpoint.x = pointlist[j].x;\n\t\t\t\t\t\t\t\tpoint.y = pointlist[j].y;\n\t\t\t\t\t\t\t\tpoly.push(point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\tif (i > 0 && /[CcSs]/.test(seglist.getItem(i - 1).pathSegTypeAsLetter)) {\n\t\t\t\t\t\t\t\tx1 = prevx + (prevx - prevx2);\n\t\t\t\t\t\t\t\ty1 = prevy + (prevy - prevy2);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tx1 = prevx;\n\t\t\t\t\t\t\t\ty1 = prevy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\tvar pointlist = GeometryUtil.CubicBezier.linearize({ x: prevx, y: prevy }, { x: x, y: y }, { x: x1, y: y1 }, { x: x2, y: y2 }, this.conf.tolerance);\n\t\t\t\t\t\t\tpointlist.shift(); // firstpoint would already be in the poly\n\t\t\t\t\t\t\tfor (var j = 0; j < pointlist.length; j++) {\n\t\t\t\t\t\t\t\tvar point = {};\n\t\t\t\t\t\t\t\tpoint.x = pointlist[j].x;\n\t\t\t\t\t\t\t\tpoint.y = pointlist[j].y;\n\t\t\t\t\t\t\t\tpoly.push(point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\tvar pointlist = GeometryUtil.Arc.linearize({ x: prevx, y: prevy }, { x: x, y: y }, s.r1, s.r2, s.angle, s.largeArcFlag, s.sweepFlag, this.conf.tolerance);\n\t\t\t\t\t\t\tpointlist.shift();\n\n\t\t\t\t\t\t\tfor (var j = 0; j < pointlist.length; j++) {\n\t\t\t\t\t\t\t\tvar point = {};\n\t\t\t\t\t\t\t\tpoint.x = pointlist[j].x;\n\t\t\t\t\t\t\t\tpoint.y = pointlist[j].y;\n\t\t\t\t\t\t\t\tpoly.push(point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'z':case 'Z':\n\t\t\t\t\t\t\tx = x0;y = y0;break;\n\t\t\t\t\t}\n\t\t\t\t\t// Record the start of a subpath\n\t\t\t\t\tif (command == 'M' || command == 'm') x0 = x, y0 = y;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// do not include last point if coincident with starting point\n\t\twhile (poly.length > 0 && GeometryUtil.almostEqual(poly[0].x, poly[poly.length - 1].x, this.conf.toleranceSvg) && GeometryUtil.almostEqual(poly[0].y, poly[poly.length - 1].y, this.conf.toleranceSvg)) {\n\t\t\tpoly.pop();\n\t\t}\n\n\t\treturn poly;\n\t};\n\n\t// expose public methods\n\tvar parser = new SvgParser();\n\n\troot.SvgParser = {\n\t\tconfig: parser.config.bind(parser),\n\t\tload: parser.load.bind(parser),\n\t\tgetStyle: parser.getStyle.bind(parser),\n\t\tclean: parser.cleanInput.bind(parser),\n\t\tpolygonify: parser.polygonify.bind(parser)\n\t};\n})(window);"},711:function(t,n,e){e(77)(e(712))},712:function(t,n){t.exports="'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (root) {\n\tvar isCommonJS = typeof module !== 'undefined' && module.exports;\n\tvar isNode = !(typeof window !== 'undefined' && root === window);\n\tvar setImmediate = setImmediate || function (cb) {\n\t\tsetTimeout(cb, 0);\n\t};\n\tvar Worker = isNode ? require(__dirname + '/Worker.js') : root.Worker;\n\tvar URL = typeof root !== 'undefined' ? root.URL ? root.URL : root.webkitURL : null;\n\tvar _supports = isNode || root.Worker ? true : false; // node always supports parallel\n\n\tfunction extend(from, to) {\n\t\tif (!to) to = {};\n\t\tfor (var i in from) {\n\t\t\tif (to[i] === undefined) to[i] = from[i];\n\t\t}\n\t\treturn to;\n\t}\n\n\tfunction Operation() {\n\t\tthis._callbacks = [];\n\t\tthis._errCallbacks = [];\n\n\t\tthis._resolved = 0;\n\t\tthis._result = null;\n\t}\n\n\tOperation.prototype.resolve = function (err, res) {\n\t\tif (!err) {\n\t\t\tthis._resolved = 1;\n\t\t\tthis._result = res;\n\n\t\t\tfor (var i = 0; i < this._callbacks.length; ++i) {\n\t\t\t\tthis._callbacks[i](res);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._resolved = 2;\n\t\t\tthis._result = err;\n\n\t\t\tfor (var iE = 0; iE < this._errCallbacks.length; ++iE) {\n\t\t\t\tthis._errCallbacks[iE](err);\n\t\t\t}\n\t\t}\n\n\t\tthis._callbacks = [];\n\t\tthis._errCallbacks = [];\n\t};\n\n\tOperation.prototype.then = function (cb, errCb) {\n\t\tif (this._resolved === 1) {\n\t\t\t// result\n\t\t\tif (cb) {\n\t\t\t\tcb(this._result);\n\t\t\t}\n\n\t\t\treturn;\n\t\t} else if (this._resolved === 2) {\n\t\t\t// error\n\t\t\tif (errCb) {\n\t\t\t\terrCb(this._result);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (cb) {\n\t\t\tthis._callbacks[this._callbacks.length] = cb;\n\t\t}\n\n\t\tif (errCb) {\n\t\t\tthis._errCallbacks[this._errCallbacks.length] = errCb;\n\t\t}\n\t\treturn this;\n\t};\n\n\tvar defaults = {\n\t\tevalPath: isNode ? __dirname + '/eval.js' : null,\n\t\tmaxWorkers: isNode ? require('os').cpus().length : navigator.hardwareConcurrency || 4,\n\t\tsynchronous: true,\n\t\tenv: {},\n\t\tenvNamespace: 'env'\n\t};\n\n\tfunction Parallel(data, options) {\n\t\tthis.data = data;\n\t\tthis.options = extend(defaults, options);\n\t\tthis.operation = new Operation();\n\t\tthis.operation.resolve(null, this.data);\n\t\tthis.requiredScripts = [];\n\t\tthis.requiredFunctions = [];\n\t}\n\n\t// static method\n\tParallel.isSupported = function () {\n\t\treturn _supports;\n\t};\n\n\tParallel.prototype.getWorkerSource = function (cb, env) {\n\t\tvar that = this;\n\t\tvar preStr = '';\n\t\tvar i = 0;\n\t\tif (!isNode && this.requiredScripts.length !== 0) {\n\t\t\tpreStr += 'importScripts(\"' + this.requiredScripts.join('\",\"') + '\");\\r\\n';\n\t\t}\n\n\t\tfor (i = 0; i < this.requiredFunctions.length; ++i) {\n\t\t\tif (this.requiredFunctions[i].name) {\n\t\t\t\tpreStr += 'var ' + this.requiredFunctions[i].name + ' = ' + this.requiredFunctions[i].fn.toString() + ';';\n\t\t\t} else {\n\t\t\t\tpreStr += this.requiredFunctions[i].fn.toString();\n\t\t\t}\n\t\t}\n\n\t\tenv = JSON.stringify(env || {});\n\n\t\tvar ns = this.options.envNamespace;\n\n\t\tif (isNode) {\n\t\t\treturn preStr + 'process.on(\"message\", function(e) {global.' + ns + ' = ' + env + ';process.send(JSON.stringify((' + cb.toString() + ')(JSON.parse(e).data)))})';\n\t\t} else {\n\t\t\treturn preStr + 'self.onmessage = function(e) {var global = {}; global.' + ns + ' = ' + env + ';self.postMessage((' + cb.toString() + ')(e.data))}';\n\t\t}\n\t};\n\n\tParallel.prototype.require = function () {\n\t\tvar args = Array.prototype.slice.call(arguments, 0),\n\t\t    func;\n\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tfunc = args[i];\n\n\t\t\tif (typeof func === 'string') {\n\t\t\t\tthis.requiredScripts.push(func);\n\t\t\t} else if (typeof func === 'function') {\n\t\t\t\tthis.requiredFunctions.push({ fn: func });\n\t\t\t} else if ((typeof func === 'undefined' ? 'undefined' : _typeof(func)) === 'object') {\n\t\t\t\tthis.requiredFunctions.push(func);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\tParallel.prototype._spawnWorker = function (cb, env) {\n\t\tvar wrk;\n\t\tvar src = this.getWorkerSource(cb, env);\n\t\tif (isNode) {\n\t\t\twrk = new Worker(this.options.evalPath);\n\t\t\twrk.postMessage(src);\n\t\t} else {\n\t\t\tif (Worker === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (this.requiredScripts.length !== 0) {\n\t\t\t\t\tif (this.options.evalPath !== null) {\n\t\t\t\t\t\twrk = new Worker(this.options.evalPath);\n\t\t\t\t\t\twrk.postMessage(src);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Can\\'t use required scripts without eval.js!');\n\t\t\t\t\t}\n\t\t\t\t} else if (!URL) {\n\t\t\t\t\tthrow new Error('Can\\'t create a blob URL in this browser!');\n\t\t\t\t} else {\n\t\t\t\t\tvar blob = new Blob([src], { type: 'text/javascript' });\n\t\t\t\t\tvar url = URL.createObjectURL(blob);\n\n\t\t\t\t\twrk = new Worker(url);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tif (this.options.evalPath !== null) {\n\t\t\t\t\t// blob/url unsupported, cross-origin error\n\t\t\t\t\twrk = new Worker(this.options.evalPath);\n\t\t\t\t\twrk.postMessage(src);\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn wrk;\n\t};\n\n\tParallel.prototype.spawn = function (cb, env) {\n\t\tvar that = this;\n\t\tvar newOp = new Operation();\n\n\t\tenv = extend(this.options.env, env || {});\n\n\t\tthis.operation.then(function () {\n\t\t\tvar wrk = that._spawnWorker(cb, env);\n\t\t\tif (wrk !== undefined) {\n\t\t\t\twrk.onmessage = function (msg) {\n\t\t\t\t\twrk.terminate();\n\t\t\t\t\tthat.data = msg.data;\n\t\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t\t};\n\t\t\t\twrk.onerror = function (e) {\n\t\t\t\t\twrk.terminate();\n\t\t\t\t\tnewOp.resolve(e, null);\n\t\t\t\t};\n\t\t\t\twrk.postMessage(that.data);\n\t\t\t} else if (that.options.synchronous) {\n\t\t\t\tsetImmediate(function () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthat.data = cb(that.data);\n\t\t\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tnewOp.resolve(e, null);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\n\t\t\t}\n\t\t});\n\t\tthis.operation = newOp;\n\t\treturn this;\n\t};\n\n\tParallel.prototype._spawnMapWorker = function (i, cb, done, env, wrk) {\n\t\tvar that = this;\n\n\t\tif (!wrk) wrk = that._spawnWorker(cb, env);\n\n\t\tif (wrk !== undefined) {\n\t\t\twrk.onmessage = function (msg) {\n\t\t\t\tthat.data[i] = msg.data;\n\t\t\t\tdone(null, wrk);\n\t\t\t};\n\t\t\twrk.onerror = function (e) {\n\t\t\t\twrk.terminate();\n\t\t\t\tdone(e);\n\t\t\t};\n\t\t\twrk.postMessage(that.data[i]);\n\t\t} else if (that.options.synchronous) {\n\t\t\tsetImmediate(function () {\n\t\t\t\tthat.data[i] = cb(that.data[i]);\n\t\t\t\tdone();\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\n\t\t}\n\t};\n\n\tParallel.prototype.map = function (cb, env) {\n\t\tenv = extend(this.options.env, env || {});\n\n\t\tif (!this.data.length) {\n\t\t\treturn this.spawn(cb, env);\n\t\t}\n\n\t\tvar that = this;\n\t\tvar startedOps = 0;\n\t\tvar doneOps = 0;\n\t\tfunction done(err, wrk) {\n\t\t\tif (err) {\n\t\t\t\tnewOp.resolve(err, null);\n\t\t\t} else if (++doneOps === that.data.length) {\n\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t\tif (wrk) wrk.terminate();\n\t\t\t} else if (startedOps < that.data.length) {\n\t\t\t\tthat._spawnMapWorker(startedOps++, cb, done, env, wrk);\n\t\t\t} else {\n\t\t\t\tif (wrk) wrk.terminate();\n\t\t\t}\n\t\t}\n\n\t\tvar newOp = new Operation();\n\t\tthis.operation.then(function () {\n\t\t\tfor (; startedOps - doneOps < that.options.maxWorkers && startedOps < that.data.length; ++startedOps) {\n\t\t\t\tthat._spawnMapWorker(startedOps, cb, done, env);\n\t\t\t}\n\t\t}, function (err) {\n\t\t\tnewOp.resolve(err, null);\n\t\t});\n\t\tthis.operation = newOp;\n\t\treturn this;\n\t};\n\n\tParallel.prototype._spawnReduceWorker = function (data, cb, done, env, wrk) {\n\t\tvar that = this;\n\t\tif (!wrk) wrk = that._spawnWorker(cb, env);\n\n\t\tif (wrk !== undefined) {\n\t\t\twrk.onmessage = function (msg) {\n\t\t\t\tthat.data[that.data.length] = msg.data;\n\t\t\t\tdone(null, wrk);\n\t\t\t};\n\t\t\twrk.onerror = function (e) {\n\t\t\t\twrk.terminate();\n\t\t\t\tdone(e, null);\n\t\t\t};\n\t\t\twrk.postMessage(data);\n\t\t} else if (that.options.synchronous) {\n\t\t\tsetImmediate(function () {\n\t\t\t\tthat.data[that.data.length] = cb(data);\n\t\t\t\tdone();\n\t\t\t});\n\t\t} else {\n\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\n\t\t}\n\t};\n\n\tParallel.prototype.reduce = function (cb, env) {\n\t\tenv = extend(this.options.env, env || {});\n\n\t\tif (!this.data.length) {\n\t\t\tthrow new Error('Can\\'t reduce non-array data');\n\t\t}\n\n\t\tvar runningWorkers = 0;\n\t\tvar that = this;\n\t\tfunction done(err, wrk) {\n\t\t\t--runningWorkers;\n\t\t\tif (err) {\n\t\t\t\tnewOp.resolve(err, null);\n\t\t\t} else if (that.data.length === 1 && runningWorkers === 0) {\n\t\t\t\tthat.data = that.data[0];\n\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t\tif (wrk) wrk.terminate();\n\t\t\t} else if (that.data.length > 1) {\n\t\t\t\t++runningWorkers;\n\t\t\t\tthat._spawnReduceWorker([that.data[0], that.data[1]], cb, done, env, wrk);\n\t\t\t\tthat.data.splice(0, 2);\n\t\t\t} else {\n\t\t\t\tif (wrk) wrk.terminate();\n\t\t\t}\n\t\t}\n\n\t\tvar newOp = new Operation();\n\t\tthis.operation.then(function () {\n\t\t\tif (that.data.length === 1) {\n\t\t\t\tnewOp.resolve(null, that.data[0]);\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < that.options.maxWorkers && i < Math.floor(that.data.length / 2); ++i) {\n\t\t\t\t\t++runningWorkers;\n\t\t\t\t\tthat._spawnReduceWorker([that.data[i * 2], that.data[i * 2 + 1]], cb, done, env);\n\t\t\t\t}\n\n\t\t\t\tthat.data.splice(0, i * 2);\n\t\t\t}\n\t\t});\n\t\tthis.operation = newOp;\n\t\treturn this;\n\t};\n\n\tParallel.prototype.then = function (cb, errCb) {\n\t\tvar that = this;\n\t\tvar newOp = new Operation();\n\t\terrCb = typeof errCb === 'function' ? errCb : function () {};\n\n\t\tthis.operation.then(function () {\n\t\t\tvar retData;\n\n\t\t\ttry {\n\t\t\t\tif (cb) {\n\t\t\t\t\tretData = cb(that.data);\n\t\t\t\t\tif (retData !== undefined) {\n\t\t\t\t\t\tthat.data = retData;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t} catch (e) {\n\t\t\t\tif (errCb) {\n\t\t\t\t\tretData = errCb(e);\n\t\t\t\t\tif (retData !== undefined) {\n\t\t\t\t\t\tthat.data = retData;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t\t} else {\n\t\t\t\t\tnewOp.resolve(null, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}, function (err) {\n\t\t\tif (errCb) {\n\t\t\t\tvar retData = errCb(err);\n\t\t\t\tif (retData !== undefined) {\n\t\t\t\t\tthat.data = retData;\n\t\t\t\t}\n\n\t\t\t\tnewOp.resolve(null, that.data);\n\t\t\t} else {\n\t\t\t\tnewOp.resolve(null, err);\n\t\t\t}\n\t\t});\n\t\tthis.operation = newOp;\n\t\treturn this;\n\t};\n\n\troot.Parallel = Parallel;\n})(typeof window !== 'undefined' ? window : undefined);"},713:function(t,n,e){e(77)(e(714))},714:function(t,n){t.exports="'use strict';\n\n/*!\n * SvgNest\n * Licensed under the MIT license\n */\n\n(function (root) {\n\t'use strict';\n\n\troot.SvgNest = new SvgNest();\n\n\tfunction SvgNest() {\n\t\tvar self = this;\n\n\t\tvar svg = null;\n\n\t\t// keep a reference to any style nodes, to maintain color/fill info\n\t\tthis.style = null;\n\n\t\tvar parts = null;\n\n\t\tvar tree = null;\n\n\t\tvar bin = null;\n\t\tvar binPolygon = null;\n\t\tvar binBounds = null;\n\t\tvar nfpCache = {};\n\t\tvar config = {\n\t\t\tclipperScale: 10000000,\n\t\t\tcurveTolerance: 0.3,\n\t\t\tspacing: 0,\n\t\t\trotations: 4,\n\t\t\tpopulationSize: 10,\n\t\t\tmutationRate: 10,\n\t\t\tuseHoles: false,\n\t\t\texploreConcave: false\n\t\t};\n\n\t\tthis.working = false;\n\n\t\tvar GA = null;\n\t\tvar best = null;\n\t\tvar workerTimer = null;\n\t\tvar progress = 0;\n\n\t\tthis.parsesvg = function (svgstring) {\n\t\t\t// reset if in progress\n\t\t\tthis.stop();\n\n\t\t\tbin = null;\n\t\t\tbinPolygon = null;\n\t\t\ttree = null;\n\n\t\t\t// parse svg\n\t\t\tsvg = SvgParser.load(svgstring);\n\n\t\t\tthis.style = SvgParser.getStyle();\n\n\t\t\tsvg = SvgParser.clean();\n\n\t\t\ttree = this.getParts(svg.childNodes);\n\n\t\t\t//re-order elements such that deeper elements are on top, so they can be moused over\n\t\t\tfunction zorder(paths) {\n\t\t\t\t// depth-first\n\t\t\t\tvar length = paths.length;\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (paths[i].children && paths[i].children.length > 0) {\n\t\t\t\t\t\tzorder(paths[i].children);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn svg;\n\t\t};\n\n\t\tthis.setbin = function (element) {\n\t\t\tif (!svg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbin = element;\n\t\t};\n\n\t\tthis.config = function (c) {\n\t\t\t// clean up inputs\n\n\t\t\tif (!c) {\n\t\t\t\treturn config;\n\t\t\t}\n\n\t\t\tif (c.curveTolerance && !GeometryUtil.almostEqual(parseFloat(c.curveTolerance), 0)) {\n\t\t\t\tconfig.curveTolerance = parseFloat(c.curveTolerance);\n\t\t\t}\n\n\t\t\tif ('spacing' in c) {\n\t\t\t\tconfig.spacing = parseFloat(c.spacing);\n\t\t\t}\n\n\t\t\tif (c.rotations && parseInt(c.rotations) > 0) {\n\t\t\t\tconfig.rotations = parseInt(c.rotations);\n\t\t\t}\n\n\t\t\tif (c.populationSize && parseInt(c.populationSize) > 2) {\n\t\t\t\tconfig.populationSize = parseInt(c.populationSize);\n\t\t\t}\n\n\t\t\tif (c.mutationRate && parseInt(c.mutationRate) > 0) {\n\t\t\t\tconfig.mutationRate = parseInt(c.mutationRate);\n\t\t\t}\n\n\t\t\tif ('useHoles' in c) {\n\t\t\t\tconfig.useHoles = !!c.useHoles;\n\t\t\t}\n\n\t\t\tif ('exploreConcave' in c) {\n\t\t\t\tconfig.exploreConcave = !!c.exploreConcave;\n\t\t\t}\n\n\t\t\tSvgParser.config({ tolerance: config.curveTolerance });\n\n\t\t\tbest = null;\n\t\t\tnfpCache = {};\n\t\t\tbinPolygon = null;\n\t\t\tGA = null;\n\n\t\t\treturn config;\n\t\t};\n\n\t\t// progressCallback is called when progress is made\n\t\t// displayCallback is called when a new placement has been made\n\t\tthis.start = function (progressCallback, displayCallback) {\n\t\t\tif (!svg || !bin) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tparts = Array.prototype.slice.call(svg.childNodes);\n\t\t\tvar binindex = parts.indexOf(bin);\n\n\t\t\tif (binindex >= 0) {\n\t\t\t\t// don't process bin as a part of the tree\n\t\t\t\tparts.splice(binindex, 1);\n\t\t\t}\n\n\t\t\t// build tree without bin\n\t\t\ttree = this.getParts(parts.slice(0));\n\n\t\t\toffsetTree(tree, 0.5 * config.spacing, this.polygonOffset.bind(this));\n\n\t\t\t// offset tree recursively\n\t\t\tfunction offsetTree(t, offset, offsetFunction) {\n\t\t\t\tfor (var i = 0; i < t.length; i++) {\n\t\t\t\t\tvar offsetpaths = offsetFunction(t[i], offset);\n\t\t\t\t\tif (offsetpaths.length == 1) {\n\t\t\t\t\t\t// replace array items in place\n\t\t\t\t\t\tArray.prototype.splice.apply(t[i], [0, t[i].length].concat(offsetpaths[0]));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (t[i].childNodes && t[i].childNodes.length > 0) {\n\t\t\t\t\t\toffsetTree(t[i].childNodes, -offset, offsetFunction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbinPolygon = SvgParser.polygonify(bin);\n\t\t\tbinPolygon = this.cleanPolygon(binPolygon);\n\n\t\t\tif (!binPolygon || binPolygon.length < 3) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbinBounds = GeometryUtil.getPolygonBounds(binPolygon);\n\n\t\t\tif (config.spacing > 0) {\n\t\t\t\tvar offsetBin = this.polygonOffset(binPolygon, -0.5 * config.spacing);\n\t\t\t\tif (offsetBin.length == 1) {\n\t\t\t\t\t// if the offset contains 0 or more than 1 path, something went wrong.\n\t\t\t\t\tbinPolygon = offsetBin.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbinPolygon.id = -1;\n\n\t\t\t// put bin on origin\n\t\t\tvar xbinmax = binPolygon[0].x;\n\t\t\tvar xbinmin = binPolygon[0].x;\n\t\t\tvar ybinmax = binPolygon[0].y;\n\t\t\tvar ybinmin = binPolygon[0].y;\n\n\t\t\tfor (var i = 1; i < binPolygon.length; i++) {\n\t\t\t\tif (binPolygon[i].x > xbinmax) {\n\t\t\t\t\txbinmax = binPolygon[i].x;\n\t\t\t\t} else if (binPolygon[i].x < xbinmin) {\n\t\t\t\t\txbinmin = binPolygon[i].x;\n\t\t\t\t}\n\t\t\t\tif (binPolygon[i].y > ybinmax) {\n\t\t\t\t\tybinmax = binPolygon[i].y;\n\t\t\t\t} else if (binPolygon[i].y < ybinmin) {\n\t\t\t\t\tybinmin = binPolygon[i].y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < binPolygon.length; i++) {\n\t\t\t\tbinPolygon[i].x -= xbinmin;\n\t\t\t\tbinPolygon[i].y -= ybinmin;\n\t\t\t}\n\n\t\t\tbinPolygon.width = xbinmax - xbinmin;\n\t\t\tbinPolygon.height = ybinmax - ybinmin;\n\n\t\t\t// all paths need to have the same winding direction\n\t\t\tif (GeometryUtil.polygonArea(binPolygon) > 0) {\n\t\t\t\tbinPolygon.reverse();\n\t\t\t}\n\n\t\t\t// remove duplicate endpoints, ensure counterclockwise winding direction\n\t\t\tfor (i = 0; i < tree.length; i++) {\n\t\t\t\tvar start = tree[i][0];\n\t\t\t\tvar end = tree[i][tree[i].length - 1];\n\t\t\t\tif (start == end || GeometryUtil.almostEqual(start.x, end.x) && GeometryUtil.almostEqual(start.y, end.y)) {\n\t\t\t\t\ttree[i].pop();\n\t\t\t\t}\n\n\t\t\t\tif (GeometryUtil.polygonArea(tree[i]) > 0) {\n\t\t\t\t\ttree[i].reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar self = this;\n\t\t\tthis.working = false;\n\n\t\t\tworkerTimer = setInterval(function () {\n\t\t\t\tif (!self.working) {\n\t\t\t\t\tself.launchWorkers.call(self, tree, binPolygon, config, progressCallback, displayCallback);\n\t\t\t\t\tself.working = true;\n\t\t\t\t}\n\n\t\t\t\tprogressCallback(progress);\n\t\t\t}, 100);\n\t\t};\n\n\t\tthis.launchWorkers = function (tree, binPolygon, config, progressCallback, displayCallback) {\n\t\t\tfunction shuffle(array) {\n\t\t\t\tvar currentIndex = array.length,\n\t\t\t\t    temporaryValue,\n\t\t\t\t    randomIndex;\n\n\t\t\t\t// While there remain elements to shuffle...\n\t\t\t\twhile (0 !== currentIndex) {\n\n\t\t\t\t\t// Pick a remaining element...\n\t\t\t\t\trandomIndex = Math.floor(Math.random() * currentIndex);\n\t\t\t\t\tcurrentIndex -= 1;\n\n\t\t\t\t\t// And swap it with the current element.\n\t\t\t\t\ttemporaryValue = array[currentIndex];\n\t\t\t\t\tarray[currentIndex] = array[randomIndex];\n\t\t\t\t\tarray[randomIndex] = temporaryValue;\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t\t}\n\n\t\t\tvar i, j;\n\n\t\t\tif (GA === null) {\n\t\t\t\t// initiate new GA\n\t\t\t\tvar adam = tree.slice(0);\n\n\t\t\t\t// seed with decreasing area\n\t\t\t\tadam.sort(function (a, b) {\n\t\t\t\t\treturn Math.abs(GeometryUtil.polygonArea(b)) - Math.abs(GeometryUtil.polygonArea(a));\n\t\t\t\t});\n\n\t\t\t\tGA = new GeneticAlgorithm(adam, binPolygon, config);\n\t\t\t}\n\n\t\t\tvar individual = null;\n\n\t\t\t// evaluate all members of the population\n\t\t\tfor (i = 0; i < GA.population.length; i++) {\n\t\t\t\tif (!GA.population[i].fitness) {\n\t\t\t\t\tindividual = GA.population[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (individual === null) {\n\t\t\t\t// all individuals have been evaluated, start next generation\n\t\t\t\tGA.generation();\n\t\t\t\tindividual = GA.population[1];\n\t\t\t}\n\n\t\t\tvar placelist = individual.placement;\n\t\t\tvar rotations = individual.rotation;\n\n\t\t\tvar ids = [];\n\t\t\tfor (i = 0; i < placelist.length; i++) {\n\t\t\t\tids.push(placelist[i].id);\n\t\t\t\tplacelist[i].rotation = rotations[i];\n\t\t\t}\n\n\t\t\tvar nfpPairs = [];\n\t\t\tvar key;\n\t\t\tvar newCache = {};\n\n\t\t\tfor (i = 0; i < placelist.length; i++) {\n\t\t\t\tvar part = placelist[i];\n\t\t\t\tkey = { A: binPolygon.id, B: part.id, inside: true, Arotation: 0, Brotation: rotations[i] };\n\t\t\t\tif (!nfpCache[JSON.stringify(key)]) {\n\t\t\t\t\tnfpPairs.push({ A: binPolygon, B: part, key: key });\n\t\t\t\t} else {\n\t\t\t\t\tnewCache[JSON.stringify(key)] = nfpCache[JSON.stringify(key)];\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tvar placed = placelist[j];\n\t\t\t\t\tkey = { A: placed.id, B: part.id, inside: false, Arotation: rotations[j], Brotation: rotations[i] };\n\t\t\t\t\tif (!nfpCache[JSON.stringify(key)]) {\n\t\t\t\t\t\tnfpPairs.push({ A: placed, B: part, key: key });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewCache[JSON.stringify(key)] = nfpCache[JSON.stringify(key)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// only keep cache for one cycle\n\t\t\tnfpCache = newCache;\n\n\t\t\tvar worker = new PlacementWorker(binPolygon, placelist.slice(0), ids, rotations, config, nfpCache);\n\n\t\t\tvar p = new Parallel(nfpPairs, {\n\t\t\t\tenv: {\n\t\t\t\t\tbinPolygon: binPolygon,\n\t\t\t\t\tsearchEdges: config.exploreConcave,\n\t\t\t\t\tuseHoles: config.useHoles\n\t\t\t\t},\n\t\t\t\tevalPath: null\n\t\t\t});\n\n\t\t\tvar self = this;\n\t\t\tvar spawncount = 0;\n\t\t\tp.getWorkerSource = function (cb, env) {\n\t\t\t\tvar deps = root.SvgNest.workerCode;\n\t\t\t\tvar code = Parallel.prototype.getWorkerSource.call(p, cb, env);\n\t\t\t\treturn deps + code;\n\t\t\t};\n\t\t\tp._spawnMapWorker = function (i, cb, done, env, wrk) {\n\t\t\t\t// hijack the worker call to check progress\n\t\t\t\tprogress = spawncount++ / nfpPairs.length;\n\t\t\t\treturn Parallel.prototype._spawnMapWorker.call(p, i, cb, done, env, wrk);\n\t\t\t};\n\n\t\t\tconsole.log('first map start 222');\n\t\t\tp.map(function (pair) {\n\t\t\t\tif (!pair || pair.length == 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar searchEdges = global.env.searchEdges;\n\t\t\t\tvar useHoles = global.env.useHoles;\n\n\t\t\t\tvar A = rotatePolygon(pair.A, pair.key.Arotation);\n\t\t\t\tvar B = rotatePolygon(pair.B, pair.key.Brotation);\n\n\t\t\t\tvar nfp;\n\n\t\t\t\tif (pair.key.inside) {\n\t\t\t\t\tif (GeometryUtil.isRectangle(A, 0.001)) {\n\t\t\t\t\t\tnfp = GeometryUtil.noFitPolygonRectangle(A, B);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnfp = GeometryUtil.noFitPolygon(A, B, true, searchEdges);\n\t\t\t\t\t}\n\n\t\t\t\t\t// ensure all interior NFPs have the same winding direction\n\t\t\t\t\tif (nfp && nfp.length > 0) {\n\t\t\t\t\t\tfor (var i = 0; i < nfp.length; i++) {\n\t\t\t\t\t\t\tif (GeometryUtil.polygonArea(nfp[i]) > 0) {\n\t\t\t\t\t\t\t\tnfp[i].reverse();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// warning on null inner NFP\n\t\t\t\t\t\t// this is not an error, as the part may simply be larger than the bin or otherwise unplaceable due to geometry\n\t\t\t\t\t\tlog('NFP Warning: ', pair.key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (searchEdges) {\n\t\t\t\t\t\tnfp = GeometryUtil.noFitPolygon(A, B, false, searchEdges);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnfp = minkowskiDifference(A, B);\n\t\t\t\t\t}\n\t\t\t\t\t// sanity check\n\t\t\t\t\tif (!nfp || nfp.length == 0) {\n\t\t\t\t\t\tlog('NFP Error: ', pair.key);\n\t\t\t\t\t\tlog('A: ', JSON.stringify(A));\n\t\t\t\t\t\tlog('B: ', JSON.stringify(B));\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < nfp.length; i++) {\n\t\t\t\t\t\tif (!searchEdges || i == 0) {\n\t\t\t\t\t\t\t// if searchedges is active, only the first NFP is guaranteed to pass sanity check\n\t\t\t\t\t\t\tif (Math.abs(GeometryUtil.polygonArea(nfp[i])) < Math.abs(GeometryUtil.polygonArea(A))) {\n\t\t\t\t\t\t\t\tlog('NFP Area Error: ', Math.abs(GeometryUtil.polygonArea(nfp[i])), pair.key);\n\t\t\t\t\t\t\t\tlog('NFP:', JSON.stringify(nfp[i]));\n\t\t\t\t\t\t\t\tlog('A: ', JSON.stringify(A));\n\t\t\t\t\t\t\t\tlog('B: ', JSON.stringify(B));\n\t\t\t\t\t\t\t\tnfp.splice(i, 1);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (nfp.length == 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// for outer NFPs, the first is guaranteed to be the largest. Any subsequent NFPs that lie inside the first are holes\n\t\t\t\t\tfor (var i = 0; i < nfp.length; i++) {\n\t\t\t\t\t\tif (GeometryUtil.polygonArea(nfp[i]) > 0) {\n\t\t\t\t\t\t\tnfp[i].reverse();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\t\tif (GeometryUtil.pointInPolygon(nfp[i][0], nfp[0])) {\n\t\t\t\t\t\t\t\tif (GeometryUtil.polygonArea(nfp[i]) < 0) {\n\t\t\t\t\t\t\t\t\tnfp[i].reverse();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// generate nfps for children (holes of parts) if any exist\n\t\t\t\t\tif (useHoles && A.childNodes && A.childNodes.length > 0) {\n\t\t\t\t\t\tvar Bbounds = GeometryUtil.getPolygonBounds(B);\n\n\t\t\t\t\t\tfor (var i = 0; i < A.childNodes.length; i++) {\n\t\t\t\t\t\t\tvar Abounds = GeometryUtil.getPolygonBounds(A.childNodes[i]);\n\n\t\t\t\t\t\t\t// no need to find nfp if B's bounding box is too big\n\t\t\t\t\t\t\tif (Abounds.width > Bbounds.width && Abounds.height > Bbounds.height) {\n\n\t\t\t\t\t\t\t\tvar cnfp = GeometryUtil.noFitPolygon(A.childNodes[i], B, true, searchEdges);\n\t\t\t\t\t\t\t\t// ensure all interior NFPs have the same winding direction\n\t\t\t\t\t\t\t\tif (cnfp && cnfp.length > 0) {\n\t\t\t\t\t\t\t\t\tfor (var j = 0; j < cnfp.length; j++) {\n\t\t\t\t\t\t\t\t\t\tif (GeometryUtil.polygonArea(cnfp[j]) < 0) {\n\t\t\t\t\t\t\t\t\t\t\tcnfp[j].reverse();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tnfp.push(cnfp[j]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction log() {\n\t\t\t\t\tif (typeof console !== \"undefined\") {\n\t\t\t\t\t\tconsole.log.apply(console, arguments);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction toClipperCoordinates(polygon) {\n\t\t\t\t\tvar clone = [];\n\t\t\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\t\t\tclone.push({\n\t\t\t\t\t\t\tX: polygon[i].x,\n\t\t\t\t\t\t\tY: polygon[i].y\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\t\t\t\t};\n\n\t\t\t\tfunction toNestCoordinates(polygon, scale) {\n\t\t\t\t\tvar clone = [];\n\t\t\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\t\t\tclone.push({\n\t\t\t\t\t\t\tx: polygon[i].X / scale,\n\t\t\t\t\t\t\ty: polygon[i].Y / scale\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn clone;\n\t\t\t\t};\n\n\t\t\t\tfunction minkowskiDifference(A, B) {\n\t\t\t\t\tvar Ac = toClipperCoordinates(A);\n\t\t\t\t\tClipperLib.JS.ScaleUpPath(Ac, 10000000);\n\t\t\t\t\tvar Bc = toClipperCoordinates(B);\n\t\t\t\t\tClipperLib.JS.ScaleUpPath(Bc, 10000000);\n\t\t\t\t\tfor (var i = 0; i < Bc.length; i++) {\n\t\t\t\t\t\tBc[i].X *= -1;\n\t\t\t\t\t\tBc[i].Y *= -1;\n\t\t\t\t\t}\n\t\t\t\t\tvar solution = ClipperLib.Clipper.MinkowskiSum(Ac, Bc, true);\n\t\t\t\t\tvar clipperNfp;\n\n\t\t\t\t\tvar largestArea = null;\n\t\t\t\t\tfor (i = 0; i < solution.length; i++) {\n\t\t\t\t\t\tvar n = toNestCoordinates(solution[i], 10000000);\n\t\t\t\t\t\tvar sarea = GeometryUtil.polygonArea(n);\n\t\t\t\t\t\tif (largestArea === null || largestArea > sarea) {\n\t\t\t\t\t\t\tclipperNfp = n;\n\t\t\t\t\t\t\tlargestArea = sarea;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < clipperNfp.length; i++) {\n\t\t\t\t\t\tclipperNfp[i].x += B[0].x;\n\t\t\t\t\t\tclipperNfp[i].y += B[0].y;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [clipperNfp];\n\t\t\t\t}\n\n\t\t\t\treturn { key: pair.key, value: nfp };\n\t\t\t}).then(function (generatedNfp) {\n\t\t\t\tif (generatedNfp) {\n\t\t\t\t\tfor (var i = 0; i < generatedNfp.length; i++) {\n\t\t\t\t\t\tvar Nfp = generatedNfp[i];\n\n\t\t\t\t\t\tif (Nfp) {\n\t\t\t\t\t\t\t// a null nfp means the nfp could not be generated, either because the parts simply don't fit or an error in the nfp algo\n\t\t\t\t\t\t\tvar key = JSON.stringify(Nfp.key);\n\t\t\t\t\t\t\tnfpCache[key] = Nfp.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tworker.nfpCache = nfpCache;\n\n\t\t\t\t// can't use .spawn because our data is an array\n\t\t\t\tvar p2 = new Parallel([placelist.slice(0)], {\n\t\t\t\t\tenv: {\n\t\t\t\t\t\tself: worker\n\t\t\t\t\t},\n\t\t\t\t\tevalPath: null\n\t\t\t\t});\n\n\t\t\t\tp2.getWorkerSource = function (cb, env) {\n\t\t\t\t\tvar deps = root.SvgNest.workerCode;\n\t\t\t\t\tvar code = Parallel.prototype.getWorkerSource.call(p2, cb, env);\n\t\t\t\t\treturn deps + code;\n\t\t\t\t};\n\n\t\t\t\tp2.map(worker.placePaths).then(function (placements) {\n\t\t\t\t\tif (!placements || placements.length == 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tindividual.fitness = placements[0].fitness;\n\t\t\t\t\tvar bestresult = placements[0];\n\n\t\t\t\t\tfor (var i = 1; i < placements.length; i++) {\n\t\t\t\t\t\tif (placements[i].fitness < bestresult.fitness) {\n\t\t\t\t\t\t\tbestresult = placements[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!best || bestresult.fitness < best.fitness) {\n\t\t\t\t\t\tbest = bestresult;\n\n\t\t\t\t\t\tvar placedArea = 0;\n\t\t\t\t\t\tvar totalArea = 0;\n\t\t\t\t\t\tvar numParts = placelist.length;\n\t\t\t\t\t\tvar numPlacedParts = 0;\n\n\t\t\t\t\t\tfor (i = 0; i < best.placements.length; i++) {\n\t\t\t\t\t\t\ttotalArea += Math.abs(GeometryUtil.polygonArea(binPolygon));\n\t\t\t\t\t\t\tfor (var j = 0; j < best.placements[i].length; j++) {\n\t\t\t\t\t\t\t\tplacedArea += Math.abs(GeometryUtil.polygonArea(tree[best.placements[i][j].id]));\n\t\t\t\t\t\t\t\tnumPlacedParts++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdisplayCallback(self.applyPlacement(best.placements), placedArea / totalArea, numPlacedParts, numParts);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisplayCallback();\n\t\t\t\t\t}\n\t\t\t\t\tself.working = false;\n\t\t\t\t}, function (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t});\n\t\t\t}, function (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t});\n\t\t};\n\n\t\t// assuming no intersections, return a tree where odd leaves are parts and even ones are holes\n\t\t// might be easier to use the DOM, but paths can't have paths as children. So we'll just make our own tree.\n\t\tthis.getParts = function (paths) {\n\n\t\t\tvar i, j;\n\t\t\tvar polygons = [];\n\n\t\t\tvar numChildren = paths.length;\n\t\t\tfor (i = 0; i < numChildren; i++) {\n\t\t\t\tvar poly = SvgParser.polygonify(paths[i]);\n\t\t\t\tpoly = this.cleanPolygon(poly);\n\n\t\t\t\t// todo: warn user if poly could not be processed and is excluded from the nest\n\t\t\t\tif (poly && poly.length > 2 && Math.abs(GeometryUtil.polygonArea(poly)) > config.curveTolerance * config.curveTolerance) {\n\t\t\t\t\tpoly.source = i;\n\t\t\t\t\tpolygons.push(poly);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn the list into a tree\n\t\t\ttoTree(polygons);\n\n\t\t\tfunction toTree(list, idstart) {\n\t\t\t\tvar parents = [];\n\t\t\t\tvar i, j;\n\n\t\t\t\t// assign a unique id to each leaf\n\t\t\t\tvar id = idstart || 0;\n\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tvar p = list[i];\n\n\t\t\t\t\tvar ischild = false;\n\t\t\t\t\tfor (j = 0; j < list.length; j++) {\n\t\t\t\t\t\tif (j == i) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (GeometryUtil.pointInPolygon(p[0], list[j]) === true) {\n\t\t\t\t\t\t\tif (!list[j].children) {\n\t\t\t\t\t\t\t\tlist[j].children = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist[j].children.push(p);\n\t\t\t\t\t\t\tp.parent = list[j];\n\t\t\t\t\t\t\tischild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ischild) {\n\t\t\t\t\t\tparents.push(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < list.length; i++) {\n\t\t\t\t\tif (parents.indexOf(list[i]) < 0) {\n\t\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < parents.length; i++) {\n\t\t\t\t\tparents[i].id = id;\n\t\t\t\t\tid++;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < parents.length; i++) {\n\t\t\t\t\tif (parents[i].children) {\n\t\t\t\t\t\tid = toTree(parents[i].children, id);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn id;\n\t\t\t};\n\n\t\t\treturn polygons;\n\t\t};\n\n\t\t// use the clipper library to return an offset to the given polygon. Positive offset expands the polygon, negative contracts\n\t\t// note that this returns an array of polygons\n\t\tthis.polygonOffset = function (polygon, offset) {\n\t\t\tif (!offset || offset == 0 || GeometryUtil.almostEqual(offset, 0)) {\n\t\t\t\treturn polygon;\n\t\t\t}\n\n\t\t\tvar p = this.svgToClipper(polygon);\n\n\t\t\tvar miterLimit = 2;\n\t\t\tvar co = new ClipperLib.ClipperOffset(miterLimit, config.curveTolerance * config.clipperScale);\n\t\t\tco.AddPath(p, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etClosedPolygon);\n\n\t\t\tvar newpaths = new ClipperLib.Paths();\n\t\t\tco.Execute(newpaths, offset * config.clipperScale);\n\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < newpaths.length; i++) {\n\t\t\t\tresult.push(this.clipperToSvg(newpaths[i]));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\t// returns a less complex polygon that satisfies the curve tolerance\n\t\tthis.cleanPolygon = function (polygon) {\n\t\t\tvar p = this.svgToClipper(polygon);\n\t\t\t// remove self-intersections and find the biggest polygon that's left\n\t\t\tvar simple = ClipperLib.Clipper.SimplifyPolygon(p, ClipperLib.PolyFillType.pftNonZero);\n\n\t\t\tif (!simple || simple.length == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar biggest = simple[0];\n\t\t\tvar biggestarea = Math.abs(ClipperLib.Clipper.Area(biggest));\n\t\t\tfor (var i = 1; i < simple.length; i++) {\n\t\t\t\tvar area = Math.abs(ClipperLib.Clipper.Area(simple[i]));\n\t\t\t\tif (area > biggestarea) {\n\t\t\t\t\tbiggest = simple[i];\n\t\t\t\t\tbiggestarea = area;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// clean up singularities, coincident points and edges\n\t\t\tvar clean = ClipperLib.Clipper.CleanPolygon(biggest, config.curveTolerance * config.clipperScale);\n\n\t\t\tif (!clean || clean.length == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.clipperToSvg(clean);\n\t\t};\n\n\t\t// converts a polygon from normal float coordinates to integer coordinates used by clipper, as well as x/y -> X/Y\n\t\tthis.svgToClipper = function (polygon) {\n\t\t\tvar clip = [];\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tclip.push({ X: polygon[i].x, Y: polygon[i].y });\n\t\t\t}\n\n\t\t\tClipperLib.JS.ScaleUpPath(clip, config.clipperScale);\n\n\t\t\treturn clip;\n\t\t};\n\n\t\tthis.clipperToSvg = function (polygon) {\n\t\t\tvar normal = [];\n\n\t\t\tfor (var i = 0; i < polygon.length; i++) {\n\t\t\t\tnormal.push({ x: polygon[i].X / config.clipperScale, y: polygon[i].Y / config.clipperScale });\n\t\t\t}\n\n\t\t\treturn normal;\n\t\t};\n\n\t\t// returns an array of SVG elements that represent the placement, for export or rendering\n\t\tthis.applyPlacement = function (placement) {\n\t\t\tvar i, j, k;\n\t\t\tvar clone = [];\n\t\t\tfor (i = 0; i < parts.length; i++) {\n\t\t\t\tclone.push(parts[i].cloneNode(false));\n\t\t\t}\n\n\t\t\tvar svglist = [];\n\n\t\t\tfor (i = 0; i < placement.length; i++) {\n\t\t\t\tvar newsvg = svg.cloneNode(false);\n\t\t\t\tnewsvg.setAttribute('viewBox', '0 0 ' + binBounds.width + ' ' + binBounds.height);\n\t\t\t\tnewsvg.setAttribute('width', binBounds.width + 'px');\n\t\t\t\tnewsvg.setAttribute('height', binBounds.height + 'px');\n\t\t\t\tvar binclone = bin.cloneNode(false);\n\n\t\t\t\tbinclone.setAttribute('class', 'bin');\n\t\t\t\tbinclone.setAttribute('transform', 'translate(' + -binBounds.x + ' ' + -binBounds.y + ')');\n\t\t\t\tnewsvg.appendChild(binclone);\n\n\t\t\t\tfor (j = 0; j < placement[i].length; j++) {\n\t\t\t\t\tvar p = placement[i][j];\n\t\t\t\t\tvar part = tree[p.id];\n\n\t\t\t\t\t// the original path could have transforms and stuff on it, so apply our transforms on a group\n\t\t\t\t\tvar partgroup = document.createElementNS(svg.namespaceURI, 'g');\n\t\t\t\t\tpartgroup.setAttribute('transform', 'translate(' + p.x + ' ' + p.y + ') rotate(' + p.rotation + ')');\n\t\t\t\t\tpartgroup.appendChild(clone[part.source]);\n\n\t\t\t\t\tif (part.children && part.children.length > 0) {\n\t\t\t\t\t\tvar flattened = _flattenTree(part.children, true);\n\t\t\t\t\t\tfor (k = 0; k < flattened.length; k++) {\n\n\t\t\t\t\t\t\tvar c = clone[flattened[k].source];\n\t\t\t\t\t\t\t// add class to indicate hole\n\t\t\t\t\t\t\tif (flattened[k].hole && (!c.getAttribute('class') || c.getAttribute('class').indexOf('hole') < 0)) {\n\t\t\t\t\t\t\t\tc.setAttribute('class', c.getAttribute('class') + ' hole');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpartgroup.appendChild(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnewsvg.appendChild(partgroup);\n\t\t\t\t}\n\n\t\t\t\tsvglist.push(newsvg);\n\t\t\t}\n\n\t\t\t// flatten the given tree into a list\n\t\t\tfunction _flattenTree(t, hole) {\n\t\t\t\tvar flat = [];\n\t\t\t\tfor (var i = 0; i < t.length; i++) {\n\t\t\t\t\tflat.push(t[i]);\n\t\t\t\t\tt[i].hole = hole;\n\t\t\t\t\tif (t[i].children && t[i].children.length > 0) {\n\t\t\t\t\t\tflat = flat.concat(_flattenTree(t[i].children, !hole));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn flat;\n\t\t\t}\n\n\t\t\treturn svglist;\n\t\t};\n\n\t\tthis.stop = function () {\n\t\t\tthis.working = false;\n\t\t\tif (workerTimer) {\n\t\t\t\tclearInterval(workerTimer);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction GeneticAlgorithm(adam, bin, config) {\n\n\t\tthis.config = config || { populationSize: 10, mutationRate: 10, rotations: 4 };\n\t\tthis.binBounds = GeometryUtil.getPolygonBounds(bin);\n\n\t\t// population is an array of individuals. Each individual is a object representing the order of insertion and the angle each part is rotated\n\t\tvar angles = [];\n\t\tfor (var i = 0; i < adam.length; i++) {\n\t\t\tangles.push(this.randomAngle(adam[i]));\n\t\t}\n\n\t\tthis.population = [{ placement: adam, rotation: angles }];\n\n\t\twhile (this.population.length < config.populationSize) {\n\t\t\tvar mutant = this.mutate(this.population[0]);\n\t\t\tthis.population.push(mutant);\n\t\t}\n\t}\n\n\t// returns a random angle of insertion\n\tGeneticAlgorithm.prototype.randomAngle = function (part) {\n\n\t\tvar angleList = [];\n\t\tfor (var i = 0; i < Math.max(this.config.rotations, 1); i++) {\n\t\t\tangleList.push(i * (360 / this.config.rotations));\n\t\t}\n\n\t\tfunction shuffleArray(array) {\n\t\t\tfor (var i = array.length - 1; i > 0; i--) {\n\t\t\t\tvar j = Math.floor(Math.random() * (i + 1));\n\t\t\t\tvar temp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = temp;\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tangleList = shuffleArray(angleList);\n\n\t\tfor (i = 0; i < angleList.length; i++) {\n\t\t\tvar rotatedPart = GeometryUtil.rotatePolygon(part, angleList[i]);\n\n\t\t\t// don't use obviously bad angles where the part doesn't fit in the bin\n\t\t\tif (rotatedPart.width < this.binBounds.width && rotatedPart.height < this.binBounds.height) {\n\t\t\t\treturn angleList[i];\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t};\n\n\t// returns a mutated individual with the given mutation rate\n\tGeneticAlgorithm.prototype.mutate = function (individual) {\n\t\tvar clone = { placement: individual.placement.slice(0), rotation: individual.rotation.slice(0) };\n\t\tfor (var i = 0; i < clone.placement.length; i++) {\n\t\t\tvar rand = Math.random();\n\t\t\tif (rand < 0.01 * this.config.mutationRate) {\n\t\t\t\t// swap current part with next part\n\t\t\t\tvar j = i + 1;\n\n\t\t\t\tif (j < clone.placement.length) {\n\t\t\t\t\tvar temp = clone.placement[i];\n\t\t\t\t\tclone.placement[i] = clone.placement[j];\n\t\t\t\t\tclone.placement[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trand = Math.random();\n\t\t\tif (rand < 0.01 * this.config.mutationRate) {\n\t\t\t\tclone.rotation[i] = this.randomAngle(clone.placement[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn clone;\n\t};\n\n\t// single point crossover\n\tGeneticAlgorithm.prototype.mate = function (male, female) {\n\t\tvar cutpoint = Math.round(Math.min(Math.max(Math.random(), 0.1), 0.9) * (male.placement.length - 1));\n\n\t\tvar gene1 = male.placement.slice(0, cutpoint);\n\t\tvar rot1 = male.rotation.slice(0, cutpoint);\n\n\t\tvar gene2 = female.placement.slice(0, cutpoint);\n\t\tvar rot2 = female.rotation.slice(0, cutpoint);\n\n\t\tvar i;\n\n\t\tfor (i = 0; i < female.placement.length; i++) {\n\t\t\tif (!contains(gene1, female.placement[i].id)) {\n\t\t\t\tgene1.push(female.placement[i]);\n\t\t\t\trot1.push(female.rotation[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < male.placement.length; i++) {\n\t\t\tif (!contains(gene2, male.placement[i].id)) {\n\t\t\t\tgene2.push(male.placement[i]);\n\t\t\t\trot2.push(male.rotation[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction contains(gene, id) {\n\t\t\tfor (var i = 0; i < gene.length; i++) {\n\t\t\t\tif (gene[i].id == id) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn [{ placement: gene1, rotation: rot1 }, { placement: gene2, rotation: rot2 }];\n\t};\n\n\tGeneticAlgorithm.prototype.generation = function () {\n\n\t\t// Individuals with higher fitness are more likely to be selected for mating\n\t\tthis.population.sort(function (a, b) {\n\t\t\treturn a.fitness - b.fitness;\n\t\t});\n\n\t\t// fittest individual is preserved in the new generation (elitism)\n\t\tvar newpopulation = [this.population[0]];\n\n\t\twhile (newpopulation.length < this.population.length) {\n\t\t\tvar male = this.randomWeightedIndividual();\n\t\t\tvar female = this.randomWeightedIndividual(male);\n\n\t\t\t// each mating produces two children\n\t\t\tvar children = this.mate(male, female);\n\n\t\t\t// slightly mutate children\n\t\t\tnewpopulation.push(this.mutate(children[0]));\n\n\t\t\tif (newpopulation.length < this.population.length) {\n\t\t\t\tnewpopulation.push(this.mutate(children[1]));\n\t\t\t}\n\t\t}\n\n\t\tthis.population = newpopulation;\n\t};\n\n\t// returns a random individual from the population, weighted to the front of the list (lower fitness value is more likely to be selected)\n\tGeneticAlgorithm.prototype.randomWeightedIndividual = function (exclude) {\n\t\tvar pop = this.population.slice(0);\n\n\t\tif (exclude && pop.indexOf(exclude) >= 0) {\n\t\t\tpop.splice(pop.indexOf(exclude), 1);\n\t\t}\n\n\t\tvar rand = Math.random();\n\n\t\tvar lower = 0;\n\t\tvar weight = 1 / pop.length;\n\t\tvar upper = weight;\n\n\t\tfor (var i = 0; i < pop.length; i++) {\n\t\t\t// if the random number falls between lower and upper bounds, select this individual\n\t\t\tif (rand > lower && rand < upper) {\n\t\t\t\treturn pop[i];\n\t\t\t}\n\t\t\tlower = upper;\n\t\t\tupper += 2 * weight * ((pop.length - i) / pop.length);\n\t\t}\n\n\t\treturn pop[0];\n\t};\n})(window);"},77:function(t,n){t.exports=function(t){try{"undefined"!=typeof eval?eval.call(null,t):"undefined"!=typeof execScript?execScript(t):console.error("[Script Loader] EvalError: No eval function available")}catch(t){console.error("[Script Loader] ",t.message)}}}})});